
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="yEuEEZ7phu">
  
    <title>使用LWJGL3开发3D游戏 第十五章 地形碰撞 | 耗子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Mouse0w0">
    

    
    <meta name="description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter15 英文标题：Terrain Collisions  此前我们创建了一个地形，接下来就是检测碰撞以避免穿过它。回忆一下之前的内容，一个地形是由地形块组成的，每个地形块都是由高度图生成的，高度图用于设置构成地形的三角形的顶点高度。 为了检测碰撞，我们必须将当前所在位置的Y值与当前地形点">
<meta name="keywords" content="Java,LWJGL,OpenGL">
<meta property="og:type" content="article">
<meta property="og:title" content="使用LWJGL3开发3D游戏 第十五章 地形碰撞">
<meta property="og:url" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/index.html">
<meta property="og:site_name" content="耗子的博客">
<meta property="og:description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter15 英文标题：Terrain Collisions  此前我们创建了一个地形，接下来就是检测碰撞以避免穿过它。回忆一下之前的内容，一个地形是由地形块组成的，每个地形块都是由高度图生成的，高度图用于设置构成地形的三角形的顶点高度。 为了检测碰撞，我们必须将当前所在位置的Y值与当前地形点">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_grid.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/model_to_world_coordinates.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_block_variables_n.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/cell.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/tunnelling.png">
<meta property="og:updated_time" content="2019-02-27T14:42:51.585Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用LWJGL3开发3D游戏 第十五章 地形碰撞">
<meta name="twitter:description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter15 英文标题：Terrain Collisions  此前我们创建了一个地形，接下来就是检测碰撞以避免穿过它。回忆一下之前的内容，一个地形是由地形块组成的，每个地形块都是由高度图生成的，高度图用于设置构成地形的三角形的顶点高度。 为了检测碰撞，我们必须将当前所在位置的Y值与当前地形点">
<meta name="twitter:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_grid.png">

    
    <link rel="alternative" href="./atom.xml" title="耗子的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="耗子的博客">耗子的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/archives">全部博文</a></li>
					
						<li><a href="https://afdian.net/@mouse">捐助作者</a></li>
					
						<li><a href="https://github.com/Mouse0w0/mouse0w0.github.io/issues/new">反馈建议</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:mouse0w0.github.io">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope="" itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/02/07/Lwjglbook-15-terrain-collisions/" title="使用LWJGL3开发3D游戏 第十五章 地形碰撞" itemprop="url">使用LWJGL3开发3D游戏 第十五章 地形碰撞</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mouse0w0" target="_blank" itemprop="author">Mouse0w0</a>
		
  </p><p class="article-time">
    <time datetime="2019-02-07T09:20:57.000Z" itemprop="datePublished"> 发表于 2019-02-07</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			
		
		</div>
		
		<blockquote>
<p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter15" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter15</a></p>
<p>英文标题：Terrain Collisions</p>
</blockquote>
<p>此前我们创建了一个地形，接下来就是检测碰撞以避免穿过它。回忆一下之前的内容，一个地形是由地形块组成的，每个地形块都是由高度图生成的，高度图用于设置构成地形的三角形的顶点高度。</p>
<p>为了检测碰撞，我们必须将当前所在位置的<strong>Y</strong>值与当前地形点的<strong>Y</strong>值进行比较。如果有碰撞，我们需要回到地形上方。很简单的想法，是吗？确实是这样，但在比较之前，我们需要进行几次计算。</p>
<p>我们首先要定义的是我们对“当前位置”这个词的理解。由于我们还没有一个球员的概念，答案很简单，当前的位置将是相机的位置。因此，我们已经有了比较的组成部分之一，因此，接下来要计算的是当前位置的地形高度。<br>首先要定义的是“当前位置”这个词的概念。由于我们还没有一个“玩家”的概念，因此当前位置将是摄像机的位置。这样我们就有了比较的一方，因此接下来要计算当前位置的地形高度。</p>
<p>如上所是，地形由地形块组成，如下图所示。</p>
<p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_grid.png" alt="地形网格"></p>
<p>每个地形块都是由相同的高度图网格构成，但被精确地缩放和位移，以形成看起来像是连续的景观的地形网格。</p>
<p>所以首先要做的是确定当前位置(摄像机位置)在哪个地形块。为了得到它，我们将基于位移和缩放来计算每个地形块的包围盒(<strong>BoundingBox</strong>)。因为地形在运行时不会移动或缩放，所以我们可以在<code>Terrain</code>类的构造方法中计算。这样就可以在任何时候访问它们，而不需要在每个游戏循环周期中重复这些计算。</p>
<p>我们将创建一个新的方法来计算一个地形块的包围盒，名为<code>getBoundingBox</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Box2D <span class="title">getBoundingBox</span><span class="params">(GameItem terrainBlock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> scale = terrainBlock.getScale();</span><br><span class="line">    Vector3f position = terrainBlock.getPosition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topLeftX = HeightMapMesh.STARTX * scale + position.x;</span><br><span class="line">    <span class="keyword">float</span> topLeftZ = HeightMapMesh.STARTZ * scale + position.z;</span><br><span class="line">    <span class="keyword">float</span> width = Math.abs(HeightMapMesh.STARTX * <span class="number">2</span>) * scale;</span><br><span class="line">    <span class="keyword">float</span> height = Math.abs(HeightMapMesh.STARTZ * <span class="number">2</span>) * scale;</span><br><span class="line">    Box2D boundingBox = <span class="keyword">new</span> Box2D(topLeftX, topLeftZ, width, height);</span><br><span class="line">    <span class="keyword">return</span> boundingBox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Box2D</code>是<code>java.awt.Rectangle2D.Float</code>类的简化版本，为了避免使用AWT而创建。</p>
<p>限制我们需要计算地形块的世界坐标。在上一章中，你看到所有的地形网格都是在一个正方形中创建的，它的原点设置为<code>[STARTX, STARTZ]</code>。因此，我们需要把这些坐标转换为世界坐标，这要考虑下图所示的位移与缩放。</p>
<p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/model_to_world_coordinates.png" alt="模型坐标系到世界坐标系"></p>
<p>如上所述，这可以在<code>Terrain</code>类构造方法中计算，因为它不会在运行时发生变化，所以我们要添加一个新的属性来保存包围盒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Box2D[][] boundingBoxes;</span><br></pre></td></tr></table></figure>
<p>在<code>Terrain</code>类的构造方法中，当我们创建地形块时，只需调用计算包围盒的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Terrain</span><span class="params">(<span class="keyword">int</span> terrainSize, <span class="keyword">float</span> scale, <span class="keyword">float</span> minY, <span class="keyword">float</span> maxY, String heightMapFile, String textureFile, <span class="keyword">int</span> textInc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.terrainSize = terrainSize;</span><br><span class="line">    gameItems = <span class="keyword">new</span> GameItem[terrainSize * terrainSize];</span><br><span class="line"></span><br><span class="line">    PNGDecoder decoder = <span class="keyword">new</span> PNGDecoder(getClass().getResourceAsStream(heightMapFile));</span><br><span class="line">    <span class="keyword">int</span> height = decoder.getHeight();</span><br><span class="line">    <span class="keyword">int</span> width = decoder.getWidth();</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocateDirect(</span><br><span class="line">            <span class="number">4</span> * decoder.getWidth() * decoder.getHeight());</span><br><span class="line">    decoder.decode(buf, decoder.getWidth() * <span class="number">4</span>, PNGDecoder.Format.RGBA);</span><br><span class="line">    buf.flip();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每行与每列的顶点数</span></span><br><span class="line">    verticesPerCol = heightMapImage.getWidth();</span><br><span class="line">    verticesPerRow = heightMapImage.getHeight();</span><br><span class="line"></span><br><span class="line">    heightMapMesh = <span class="keyword">new</span> HeightMapMesh(minY, maxY, buf, width, textureFile, textInc);</span><br><span class="line">    boundingBoxes = <span class="keyword">new</span> Box2D[terrainSize][terrainSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; terrainSize; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; terrainSize; col++) &#123;</span><br><span class="line">            <span class="keyword">float</span> xDisplacement = (col - ((<span class="keyword">float</span>) terrainSize - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getXLength();</span><br><span class="line">            <span class="keyword">float</span> zDisplacement = (row - ((<span class="keyword">float</span>) terrainSize - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getZLength();</span><br><span class="line"></span><br><span class="line">            GameItem terrainBlock = <span class="keyword">new</span> GameItem(heightMapMesh.getMesh());</span><br><span class="line">            terrainBlock.setScale(scale);</span><br><span class="line">            terrainBlock.setPosition(xDisplacement, <span class="number">0</span>, zDisplacement);</span><br><span class="line">            gameItems[row * terrainSize + col] = terrainBlock;</span><br><span class="line"></span><br><span class="line">            boundingBoxes[row][col] = getBoundingBox(terrainBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，有了所有预先计算的包围盒，我们将创建一个新的方法，这个方法将以当前位置为参数，返回对应地形高度。该方法名为<code>getHeight</code>，其定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHeight</span><span class="params">(Vector3f position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = Float.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 对于每个地形块，我们获取包围盒，将其转换到观察坐标系</span></span><br><span class="line">    <span class="comment">// 检查坐标是否包含在包围盒中</span></span><br><span class="line">    Box2D boundingBox = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    GameItem terrainBlock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; terrainSize &amp;&amp; !found; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; terrainSize &amp;&amp; !found; col++) &#123;</span><br><span class="line">            terrainBlock = gameItems[row * terrainSize + col];</span><br><span class="line">            boundingBox = boundingBoxes[row][col];</span><br><span class="line">            found = boundingBox.contains(position.x, position.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们找到了一个包含我们位置的地形块</span></span><br><span class="line">    <span class="comment">// 计算该位置的地形高度</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        Vector3f[] triangle = getTriangle(position, boundingBox, terrainBlock);</span><br><span class="line">        result = interpolateHeight(triangle[<span class="number">0</span>], triangle[<span class="number">1</span>], triangle[<span class="number">2</span>], position.x, position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此方法中第一件事是确定我们所在的地形块。由于我们已经有了每个地形块的包围盒，所以算法很简单。我们只需要迭代包围盒数组，并检查当前位置是否位于其中(<code>Box2D</code>提供了该方法)。</p>
<p>一旦找到了地形块，我们需要计算所处的三角形，这是由之后的<code>getTriangle</code>方法计算的。之后，我们得到了所在三角形的坐标，包括它的高度。但是，我们需要的是一个点的高度，这个点不位于这些顶点中的任何一点，而位于它们之间的位置。这将在<code>interpolateHeight</code>方法中计算，我们也将解释这是如何计算的。</p>
<p>让我们先从确定所处的三角形开始。构成地形块的正方形可以看作一个网格，其中每个单元由两个三角形组成。首先我们定义一些变量：</p>
<ul>
<li><strong>boundingBox.x</strong>是与包围盒相关联的地形块的原<strong>x</strong>坐标。</li>
<li><strong>boundingBox.y</strong>是与包围盒相关联的地形块的原<strong>z</strong>坐标(即使你看到一个<strong>y</strong>，但它是在<strong>z</strong>轴的)。</li>
<li><strong>boundingBox.width</strong>是地形块正方形的宽度。</li>
<li><strong>boundingBox.height</strong>是地形块正方形的高度。</li>
<li><strong>cellWidth</strong>是一个单元的宽度。</li>
<li><strong>cellHeight</strong>是一个单元的高度。</li>
</ul>
<p>上面定义的所有变量都用世界坐标来表示。为了计算单元的宽度，我们只需要将包围盒宽度除以每列的顶点数：</p>
<script type="math/tex; mode=display">cellWidth = \frac{boundingBox.width}{verticesPerCol}</script><p><code>cellHeight</code>的计算也相似：</p>
<script type="math/tex; mode=display">cellHeight = \frac{boundingBox.height}{verticesPerRow}</script><p>一旦有了这些变量，我们就可以计算所在的单元格的行和列了：</p>
<script type="math/tex; mode=display">col = \frac{position.x - boundingBox.x}{boundingBox.width}</script><script type="math/tex; mode=display">row = \frac{position.z - boundingBox.y}{boundingBox.height}</script><p>下图在示例地形块展示了此前描述的所有变量。</p>
<p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_block_variables_n.png" alt="地形块变量"></p>
<p>有了这些信息，就可以计算单元格中包含的三角形顶点的位置。我们怎么才能做到呢？让我们来看看组成一个单元格的三角形。</p>
<p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/cell.png" alt="单元格"></p>
<p>你可以看到，单元格是被一个对角线分开为两个三角形的。确定与当前位置相关的三角形的方法，是检查<strong>z</strong>坐标在对角线的上方还是下方。在本例中，将对角线的<strong>x</strong>值设置为当前位置的<strong>x</strong>值，求出对应的对角线<strong>z</strong>值，如果当前位置的<strong>z</strong>值小于对角线的<strong>z</strong>值，那么我们在<strong>T1</strong>中。反之如果当前位置的<strong>z</strong>值大于对角线的<strong>z</strong>值，我们就在<strong>T2</strong>中。</p>
<p>我们可以通过计算与对角线相匹配的直线方程来确定。</p>
<p>如果你还记得学校的数学课，从两点通过的直线(在二维中)的方程为:</p>
<script type="math/tex; mode=display">y-y1=m\cdot(x-x1)</script><p>其中m是直线的斜率，也就是说，当沿<strong>x</strong>轴移动时，其高度会发生变化。请注意，在本例中，<strong>y</strong>坐标其实是一个<strong>z</strong>。还要注意的是，我们使用的是二维坐标，因为在这里不计算高度，只要<strong>x</strong>坐标和<strong>z</strong>坐标就足够了。因此，在本例中，直线方程应该是这样。</p>
<script type="math/tex; mode=display">z-z1=m\cdot(x-x1)</script><p>斜率可以按如下方式计算：</p>
<script type="math/tex; mode=display">m=\frac{z1-z2}{x1-x2}</script><p>所以给定一个<strong>x</strong>坐标得到一个<strong>z</strong>值的对角线方程就像这样：</p>
<script type="math/tex; mode=display">z=m\cdot(xpos-x1)+z1=\frac{z1-z2}{x1-x2}\cdot(zpos-x1)+z1</script><p>其中<strong>x1</strong>、<strong>x2</strong>、<strong>z1</strong>和<strong>z2</strong>分别是顶点<strong>V1</strong>和<strong>V2</strong>的<strong>x</strong>和<strong>z</strong>坐标。</p>
<p>因此，通过上述方式来获得当前位置所在的三角形的方法，名为<code>getTriangle</code>，其实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Vector3f[] getTriangle(Vector3f position, Box2D boundingBox, GameItem terrainBlock) &#123;</span><br><span class="line">    <span class="comment">// 获得与当前位置相关的高度图的行列</span></span><br><span class="line">    <span class="keyword">float</span> cellWidth = boundingBox.width / (<span class="keyword">float</span>) verticesPerCol;</span><br><span class="line">    <span class="keyword">float</span> cellHeight = boundingBox.height / (<span class="keyword">float</span>) verticesPerRow;</span><br><span class="line">    <span class="keyword">int</span> col = (<span class="keyword">int</span>) ((position.x - boundingBox.x) / cellWidth);</span><br><span class="line">    <span class="keyword">int</span> row = (<span class="keyword">int</span>) ((position.z - boundingBox.y) / cellHeight);</span><br><span class="line"></span><br><span class="line">    Vector3f[] triangle = <span class="keyword">new</span> Vector3f[<span class="number">3</span>];</span><br><span class="line">    triangle[<span class="number">1</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">        boundingBox.x + col * cellWidth,</span><br><span class="line">        getWorldHeight(row + <span class="number">1</span>, col, terrainBlock),</span><br><span class="line">        boundingBox.y + (row + <span class="number">1</span>) * cellHeight);</span><br><span class="line">    triangle[<span class="number">2</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">        boundingBox.x + (col + <span class="number">1</span>) * cellWidth,</span><br><span class="line">        getWorldHeight(row, col + <span class="number">1</span>, terrainBlock),</span><br><span class="line">        boundingBox.y + row * cellHeight);</span><br><span class="line">    <span class="keyword">if</span> (position.z &lt; getDiagonalZCoord(triangle[<span class="number">1</span>].x, triangle[<span class="number">1</span>].z, triangle[<span class="number">2</span>].x, triangle[<span class="number">2</span>].z, position.x)) &#123;</span><br><span class="line">        triangle[<span class="number">0</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">            boundingBox.x + col * cellWidth,</span><br><span class="line">            getWorldHeight(row, col, terrainBlock),</span><br><span class="line">            boundingBox.y + row * cellHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        triangle[<span class="number">0</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">            boundingBox.x + (col + <span class="number">1</span>) * cellWidth,</span><br><span class="line">            getWorldHeight(row + <span class="number">2</span>, col + <span class="number">1</span>, terrainBlock),</span><br><span class="line">            boundingBox.y + (row + <span class="number">1</span>) * cellHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> triangle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getDiagonalZCoord</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> z1, <span class="keyword">float</span> x2, <span class="keyword">float</span> z2, <span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> z = ((z1 - z2) / (x1 - x2)) * (x - x1) + z1;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getWorldHeight</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, GameItem gameItem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> y = heightMapMesh.getHeight(row, col);</span><br><span class="line">    <span class="keyword">return</span> y * gameItem.getScale() + gameItem.getPosition().y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到我们有另外两个反复。第一个名为<code>getDiagonalZCoord</code>，给定<strong>x</strong>位置和两个顶点计算对角线的<strong>z</strong>坐标。另一个名为<code>getWorldHeight</code>，用来获得三角形顶点的高度(即<strong>y</strong>坐标)。当地形网格被创建时，每个顶点的高度都被预先计算和储存，我们只需将其转换为世界坐标。</p>
<p>好，我们有当前位置的三角形坐标。最后，我们准备在当前位置计算地形高度。怎么做呢？我们的三角形在一个平面上，一个平面可以由三个点定义，在本例中，三个顶点定义了一个三角形。</p>
<p>平面方程如下：</p>
<script type="math/tex; mode=display">a\cdot x+b\cdot y+c\cdot z+d=0</script><p>上述方程的常数值是：</p>
<script type="math/tex; mode=display">a=(B_{y}-A_{y}) \cdot (C_{z} - A_{z}) - (C_{y} - A_{y}) \cdot (B_{z}-A_{z})</script><script type="math/tex; mode=display">b=(B_{z}-A_{z}) \cdot (C_{x} - A_{x}) - (C_{z} - A_{z}) \cdot (B_{z}-A_{z})</script><script type="math/tex; mode=display">c=(B_{x}-A_{x}) \cdot (C_{y} - A_{y}) - (C_{x} - A_{x}) \cdot (B_{y}-A_{y})</script><p>其中<strong>A</strong>、<strong>B</strong>和<strong>C</strong>是定义平面所需的三个顶点。</p>
<p>然后，利用之前的方程以及当前位置的<strong>x</strong>和<strong>z</strong>坐标值，我们能够计算<strong>y</strong>值，即当前位置的地形高度：</p>
<script type="math/tex; mode=display">y = (-d - a \cdot x - c \cdot z) / b</script><p>实现了如上运算的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">interpolateHeight</span><span class="params">(Vector3f pA, Vector3f pB, Vector3f pC, <span class="keyword">float</span> x, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平面方程 ax+by+cz+d=0</span></span><br><span class="line">    <span class="keyword">float</span> a = (pB.y - pA.y) * (pC.z - pA.z) - (pC.y - pA.y) * (pB.z - pA.z);</span><br><span class="line">    <span class="keyword">float</span> b = (pB.z - pA.z) * (pC.x - pA.x) - (pC.z - pA.z) * (pB.x - pA.x);</span><br><span class="line">    <span class="keyword">float</span> c = (pB.x - pA.x) * (pC.y - pA.y) - (pC.x - pA.x) * (pB.y - pA.y);</span><br><span class="line">    <span class="keyword">float</span> d = -(a * pA.x + b * pA.y + c * pA.z);</span><br><span class="line">    <span class="comment">// y = (-d -ax -cz) / b</span></span><br><span class="line">    <span class="keyword">float</span> y = (-d - a * x - c * z) / b;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就完了！现在我们能够检测碰撞，所以在<code>DummyGame</code>类中，在更新摄像机位置时，修改如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新摄像机位置</span></span><br><span class="line">Vector3f prevPos = <span class="keyword">new</span> Vector3f(camera.getPosition());</span><br><span class="line">camera.movePosition(cameraInc.x * CAMERA_POS_STEP, cameraInc.y * CAMERA_POS_STEP, cameraInc.z * CAMERA_POS_STEP);        </span><br><span class="line"><span class="comment">// 检查是否发生碰撞。如果为true，将y坐标设置为</span></span><br><span class="line"><span class="comment">// 最大高度</span></span><br><span class="line"><span class="keyword">float</span> height = terrain.getHeight(camera.getPosition());</span><br><span class="line"><span class="keyword">if</span> ( camera.getPosition().y &lt;= height )  &#123;</span><br><span class="line">    camera.setPosition(prevPos.x, prevPos.y, prevPos.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，检测地形碰撞的概念很容易理解，但是我们需要仔细地进行计算并了解正处理的不同坐标系。</p>
<p>此外，虽然这里给出的算法在大多数情况下都是可用的，但仍存在需要仔细处理的情况。你可以发现的一个问题是隧道效应(<code>Tunnelling</code>)。设想一个情况，我们正以高速穿过地形，正因如此，位置增量值较高。这个值变得如此之高，以至于因为我们检测的是最终位置的碰撞，所以可能已经穿过了位于两点之间的障碍。</p>
<p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/tunnelling.png" alt="隧道效应"></p>
<p>有许多可行的解决方案可以避免这个效应，最简单的解决方法是将要进行的计算分成增量较小的多份。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/LwjglBook/">LwjglBook</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/LWJGL/">LWJGL</a><a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/" data-title="使用LWJGL3开发3D游戏 第十五章 地形碰撞 | 耗子的博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2019/02/07/Lwjglbook-16-fog/" title="使用LWJGL3开发3D游戏 第十六章 雾">
  <strong>上一篇：</strong><br>
  <span>
  使用LWJGL3开发3D游戏 第十六章 雾</span>
</a>
</div>


<div class="next">
<a href="/2019/02/07/Lwjglbook-14-height-maps/" title="使用LWJGL3开发3D游戏 第十四章 高度图">
 <strong>下一篇：</strong><br> 
 <span>使用LWJGL3开发3D游戏 第十四章 高度图
</span>
</a>
</div>

</nav>

	



	
  <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '7aa03b00f01b00627546',
  clientSecret: '3b6ba50fa682ea7b0acced5106630a95921bfd92',
  repo: 'mouse0w0.github.io',
  owner: 'Mouse0w0',
  admin: ['Mouse0w0'],
  id: '使用LWJGL3开发3D游戏 第十五章 地形碰撞',      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')
</script>
  
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Mouse0w0" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
</div>



  
<div class="afdian-card">
<p class="asidetitle">给作者发电</p>
<iframe class="afdian_iframe" src="https://afdian.net/leaflet?slug=mouse" height="260" scrolling="no" frameborder="0"></iframe>
</div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/LwjglBook/" title="LwjglBook">LwjglBook<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mixin/" title="Mixin">Mixin<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/LWJGL/" title="LWJGL">LWJGL<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/Mixin/" title="Mixin">Mixin<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Bytecode/" title="Bytecode">Bytecode<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C/C++">C/C++<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Tool/" title="Tool">Tool<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Script/" title="Script">Script<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Windows/" title="Windows">Windows<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Programming/" title="Programming">Programming<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Nukkit/" title="Nukkit">Nukkit<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Nashorn/" title="Nashorn">Nashorn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JNI/" title="JNI">JNI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/VSCode/" title="VSCode">VSCode<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Graphics/" title="Graphics">Graphics<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Forge/" title="Forge">Forge<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Kotlin/" title="Kotlin">Kotlin<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mcbbs.net/group-1181-1.html" target="_blank" title="一个综合性开发团队">未知之域</a>
            
          </li>
        
          <li>
            
            	<a href="https://mouse0w0.github.io/lwjglbook-CN-Translation/" target="_blank" title="《用LWJGL3开发3D游戏》中文翻译">《用LWJGL3开发3D游戏》中文翻译</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="./atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 这是耗子的博客。 <br>
			喜欢Java，MineCraft和二次元。</p>
	</section>
	 
	<div class="social-font">
		
		
		<a href="https://github.com/Mouse0w0" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc-sa.svg" alt="Creative Commons">
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Mouse0w0">Mouse0w0</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
    </script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] } });
    </script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i
        < all.length; i +=1 ) { all[i].SourceElement().parentNode.className +=' has-jax' ; } }); </script>

            <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
            </script>
            
<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
