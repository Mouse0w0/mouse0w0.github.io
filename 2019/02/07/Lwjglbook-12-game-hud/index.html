
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="yEuEEZ7phu">
  
    <title>使用LWJGL3开发3D游戏 第十二章 游戏HUD | 耗子的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Mouse0w0">
    

    
    <meta name="description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter12 英文标题：Game HUD  本章中我们将为游戏实现一个HUD(平视显示器)。换句话说，就是在三维场景上用一组二维图形和文本显示相关信息。我们将创建一个简单的HUD，接下来将说明一些如何显示这些信息的基本方法。 当你查看本章的源代码时，还将看到我们重构了一些代码，特别是Rende">
<meta name="keywords" content="Java,LWJGL,OpenGL">
<meta property="og:type" content="article">
<meta property="og:title" content="使用LWJGL3开发3D游戏 第十二章 游戏HUD">
<meta property="og:url" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/index.html">
<meta property="og:site_name" content="耗子的博客">
<meta property="og:description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter12 英文标题：Game HUD  本章中我们将为游戏实现一个HUD(平视显示器)。换句话说，就是在三维场景上用一组二维图形和文本显示相关信息。我们将创建一个简单的HUD，接下来将说明一些如何显示这些信息的基本方法。 当你查看本章的源代码时，还将看到我们重构了一些代码，特别是Rende">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/CBG.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/font_texture.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_quad.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_quad_coords.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/orthographic_projections.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/orthographic_matrix.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/orthographic_projection_sample.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_result.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_opaque.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_transparent.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/compass.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/hud_compass.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/texture_font.png">
<meta property="og:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/text_rendered_improved.png">
<meta property="og:updated_time" content="2019-02-27T14:42:51.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用LWJGL3开发3D游戏 第十二章 游戏HUD">
<meta name="twitter:description" content="本文翻译自：https://ahbejarano.gitbook.io/lwjglgamedev/chapter12 英文标题：Game HUD  本章中我们将为游戏实现一个HUD(平视显示器)。换句话说，就是在三维场景上用一组二维图形和文本显示相关信息。我们将创建一个简单的HUD，接下来将说明一些如何显示这些信息的基本方法。 当你查看本章的源代码时，还将看到我们重构了一些代码，特别是Rende">
<meta name="twitter:image" content="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/CBG.png">

    
    <link rel="alternative" href="./atom.xml" title="耗子的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="耗子的博客">耗子的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/archives">全部博文</a></li>
					
						<li><a href="https://afdian.net/@mouse">捐助作者</a></li>
					
						<li><a href="https://github.com/Mouse0w0/mouse0w0.github.io/issues/new">反馈建议</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索">
						<input type="hidden" name="q" value="site:mouse0w0.github.io">
					</form>
					
					</li>
				</ul>
			</ul></nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope="" itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/02/07/Lwjglbook-12-game-hud/" title="使用LWJGL3开发3D游戏 第十二章 游戏HUD" itemprop="url">使用LWJGL3开发3D游戏 第十二章 游戏HUD</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mouse0w0" target="_blank" itemprop="author">Mouse0w0</a>
		
  </p><p class="article-time">
    <time datetime="2019-02-07T09:20:38.000Z" itemprop="datePublished"> 发表于 2019-02-07</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#文本渲染"><span class="toc-number">1.</span> <span class="toc-text">文本渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完成HUD"><span class="toc-number">2.</span> <span class="toc-text">完成HUD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再谈文本渲染"><span class="toc-number">3.</span> <span class="toc-text">再谈文本渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSX"><span class="toc-number">4.</span> <span class="toc-text">OSX</span></a></li></ol>
		
		</div>
		
		<blockquote>
<p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter12" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter12</a></p>
<p>英文标题：Game HUD</p>
</blockquote>
<p>本章中我们将为游戏实现一个HUD(平视显示器)。换句话说，就是在三维场景上用一组二维图形和文本显示相关信息。我们将创建一个简单的HUD，接下来将说明一些如何显示这些信息的基本方法。</p>
<p>当你查看本章的源代码时，还将看到我们重构了一些代码，特别是<code>Renderer</code>类，以便为HUD渲染做好准备。</p>
<h2 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h2><p>创建HUD所要做的第一件事是渲染文本。为了实现它，我们将把包含字母字符的纹理的纹理映射到一个矩形中，该矩形将被分割为一组表示各个字符的片段。之后，我们将使用该纹理绘制文本。所以第一步是创建含有所有字符的纹理，你可以使用很多程序来做，例如<a href="http://www.codehead.co.uk/cbfg/" target="_blank" rel="noopener">CBFG</a>、<a href="http://sourceforge.net/projects/f2ibuilder/" target="_blank" rel="noopener">F2IBuilder</a>等等。现在我们使用Codehead’s Bitmap Font Generator(CBFG)。</p>
<p>CBFG有很多设置，例如纹理大小、字体类型、要使用的反走样等等。下图是我们将用来生成纹理文件的配置。在本章中，我们将假设文本编码为ISO-8859-1格式，如果需要处理不同的编码格式，则需要稍微修改代码。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/CBG.png" alt="CBFG配置"></p>
<p>当你设置CBFG的所有配置后，可以导出为多种图片格式。现在我们将它导出为BMP文件，然后再转换为PNG文件，以便将它作为纹理加载。当转换为PNG格式时，我们也可以将黑色背景设置为透明，也就是说，我们将黑色的Alpha值设置为0(可以使用GIMP这样的工具)。最后，你会得到与下图类似的东西。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/font_texture.png" alt="字体纹理"></p>
<p>如上所试，所有的字符都排列在图像中。现在图像有15列和17行。通过<br>As you can see, the image has all the characters displayed in rows and columns. In this case the image is composed by 15 columns  and 17 rows. By using the character code of a specific letter we can calculate the row and the column that is enclosed in the image. The column can be calculated as follows:  <script type="math/tex">column = code \space mod \space numberOfColumns</script>. Where <script type="math/tex">mod</script> is the module operator. The row can be calculated as follows: <script type="math/tex">row = code / numberOfCols</script>, in this case we will do a integer by integer operation so we can ignore the decimal part.</p>
<p>我们将创建一个名为<code>TextItem</code>的类，它将储存渲染文本所需的内容。这是一个简化的实现，不考虑多行文本等特性，但它能在HUD中显示文本信息。下面是这个类的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Material;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Mesh;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextItem</span> <span class="keyword">extends</span> <span class="title">GameItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> ZPOS = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICES_PER_QUAD = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numCols;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numRows;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextItem</span><span class="params">(String text, String fontFileName, <span class="keyword">int</span> numCols, <span class="keyword">int</span> numRows)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.numCols = numCols;</span><br><span class="line">        <span class="keyword">this</span>.numRows = numRows;</span><br><span class="line">        Texture texture = <span class="keyword">new</span> Texture(fontFileName);</span><br><span class="line">        <span class="keyword">this</span>.setMesh(buildMesh(texture, numCols, numRows));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个类继承了<code>GameItem</code>，这是因为我们希望改变文本在屏幕上的位置，也可能需要缩放和旋转它。构造函数接收腰显示的文本和用于渲染的纹理数据(包括图像数据和行列数目)。</p>
<p>在构造函数中，我们加载纹理图像文件，并调用一个方法来创建一个<code>Mesh</code>实例用于模拟文本。让我们看看<code>buildMesh</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mesh <span class="title">buildMesh</span><span class="params">(Texture texture, <span class="keyword">int</span> numCols, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] chars = text.getBytes(Charset.forName(<span class="string">"ISO-8859-1"</span>));</span><br><span class="line">    <span class="keyword">int</span> numChars = chars.length;</span><br><span class="line"></span><br><span class="line">    List&lt;Float&gt; positions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List&lt;Float&gt; textCoords = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">float</span>[] normals   = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">0</span>];</span><br><span class="line">    List&lt;Integer&gt; indices   = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> tileWidth = (<span class="keyword">float</span>)texture.getWidth() / (<span class="keyword">float</span>)numCols;</span><br><span class="line">    <span class="keyword">float</span> tileHeight = (<span class="keyword">float</span>)texture.getHeight() / (<span class="keyword">float</span>)numRows;</span><br></pre></td></tr></table></figure>
<p>代码创建了用于储存Mesh的位置、纹理坐标、法线和索引的数据结构。现在我们不使用照明，因此法线数列是空的。我们要做的是构造一组字符片段，每个字符片段代表一个字符。我们还需要根据每个字符片段对应的字符来分配适当的纹理坐标。下图表示了文本矩形和字符片段的关系。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_quad.png" alt="文本矩形"></p>
<p>因此，对于每个字符，我们需要创建由两个三角形构成的字符片段，这两个三角形可以用四个顶点(V1、V2、V3和V4)定义。第一个三角形(左下角的那个)的索引为(0, 1, 2)，而第二个三角形(右上角的那个)的索引为(3, 0, 2)。纹理坐标是基于与纹理图像中每个字符相关连的行和列计算的，纹理坐标的范围为[0,1]，所以我们只需要将当前行或当前列除以总行数和总列数就可以获得V1的坐标。对于其他顶点，我们只需要适当加上行宽或列宽就可以。</p>
<p>下面的循环语句块就创建了与显示文本的矩形相关的所有顶点、纹理坐标和索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numChars; i++) &#123;</span><br><span class="line">    <span class="keyword">byte</span> currChar = chars[i];</span><br><span class="line">    <span class="keyword">int</span> col = currChar % numCols;</span><br><span class="line">    <span class="keyword">int</span> row = currChar / numCols;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造由两个三角形组成的字符片段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)col / (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)row / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左下角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(tileHeight); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)col / (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(row + <span class="number">1</span>) / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右下角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth + tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(tileHeight); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(col + <span class="number">1</span>)/ (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(row + <span class="number">1</span>) / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右上角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth + tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(col + <span class="number">1</span>)/ (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)row / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加左上角和右下角顶点的索引</span></span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中需要注意的一些事情是：</p>
<ul>
<li>我们将使用屏幕坐标来表示顶点(记住屏幕坐标系的原点位于屏幕左上角)。三角形上顶点的Y坐标小于三角形底部顶点的Y坐标。</li>
<li>我们不缩放图形，因此每个字符片段的X宽度等于字符宽度。三角形的高度将是每个字符的高度。这是因为我们希望尽可能地使文本渲染得像原始纹理(不管怎样，我们可以稍后对它进行缩放，因为<code>TextItem</code>类继承了<code>GameItem</code>类。</li>
<li>Z坐标为固定值，因为它与绘制这个图像无关。</li>
</ul>
<p>下图显示了一些顶点的坐标。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_quad_coords.png" alt="文本矩形坐标"></p>
<p>为什么我们使用屏幕坐标？首先，我们将在HUD中渲染2D对象，这样通常更容易使用它们。其次，我们将使用正投影(<code>Orthographic Projection</code>)绘制它们，稍后再解释什么是正投影。</p>
<p><code>TextItem</code>类最后还需添加一些方法，以获取文本并在运行时更改文本。每当文本被更改时，我们需要清理之前的VAO(储存在<code>Mesh</code>实例中)并创建一个新的VAO。我们不需要清理纹理，所以在<code>Mesh</code>类中添加了一个新方法来删除这些数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    Texture texture = <span class="keyword">this</span>.getMesh().getMaterial().getTexture();</span><br><span class="line">    <span class="keyword">this</span>.getMesh().deleteBuffers();</span><br><span class="line">    <span class="keyword">this</span>.setMesh(buildMesh(texture, numCols, numRows));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然我们已经建立了渲染文本所需要的基础结构，接下来该怎么做呢？首先是渲染三维场景，在之前的章节已经说明了，然后再在上面渲染二维HUD。为了渲染HUD，我们将使用正投影(也称为正交投影(<code>Orthogonal Projection</code>))。正投影是三维物体的二维表示，你可能已经在三维模型的蓝图中看到了一些例子，它们用来表示某些物体的顶部或某些侧面的样子。下图展示了圆柱体从顶部和前面的正投影。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_projections.png" alt="正投影"></p>
<p>为了绘制二维物体，这个投影是非常方便的，因为它“忽略”了Z坐标的值，也就是说，忽略了到屏幕的距离。有了这种矩阵，物体的体积不会随着距离的增大而减小(如投影矩阵)。为了使用正投影投影物体，我们需要使用另一个矩阵。正投影矩阵的公式如下所示。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_matrix.png" alt="正投影矩阵"></p>
<p>这个矩阵还矫正了失真，因为我们的窗口并不总是完美的正方形，而是一个矩形。<code>right</code>和<code>bottom</code>是屏幕大小，而<code>left</code>和<code>top</code>是原点坐标。正投影矩阵用于将屏幕坐标转换为三维空间坐标。下图展示了这个投影是如何完成的。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_projection_sample.png" alt="正投影示例"></p>
<p>这个矩阵允许我们使用屏幕坐标。</p>
<p>我们现在可以继续实现HUD了。接下来我们要做的是创建另一组着色器，一个顶点着色器和一个片元着色器，来绘制HUD。顶点着色器很简单：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projModelMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projModelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它仅接收顶点坐标、纹理坐标、索引和法线，并将使用矩阵将它们转换为三维空间坐标。该矩阵即是正投影矩阵与模型矩阵相乘，即<script type="math/tex">projModelMatrix  =  ortographicMatrix \cdot modelMatrix</script>。由于我们没有在模型坐标系中使用任何坐标，所以在Java代码中将两个矩阵相乘比在着色器中相乘更高效。这样，我们只需为每个顶点做一次乘法运算。还要记住顶点应该用屏幕坐标表示。</p>
<p>片元着色器也很简单：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> mvPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> colour;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = colour * <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它只是将基本颜色与纹理颜色相乘，这样可以改变渲染文本的颜色，而不需要创建多个纹理文件。现在既然我们已经创建了一组新的着色器，就可以在<code>Renderer</code>类中使用它们。但在此之前，我们要创建一个名为<code>IHud</code>的接口，该接口储存要在HUD上显示的所有元素，还提供一个默认的<code>cleanup</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHud</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GameItem[] getGameItems();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GameItem[] gameItems = getGameItems();</span><br><span class="line">        <span class="keyword">for</span> (GameItem gameItem : gameItems) &#123;</span><br><span class="line">            gameItem.getMesh().cleanUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用该接口，不同的游戏可以定义自定义的HUD，而不需要改变渲染机制。现在回到<code>Renderer</code>类，顺便说一下，它已经被移动到<code>engine.graph</code>包下，因为现在它的通用性足以不依赖任何游戏的具体实现了。在<code>Renderer</code>类中，我们添加了一个新的方法来创建、连接和初始化一个新的<code>ShaderProgram</code>，以便使用之前所述的着色器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupHudShader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    hudShaderProgram = <span class="keyword">new</span> ShaderProgram();</span><br><span class="line">    hudShaderProgram.createVertexShader(Utils.loadResource(<span class="string">"/shaders/hud_vertex.vs"</span>));</span><br><span class="line">    hudShaderProgram.createFragmentShader(Utils.loadResource(<span class="string">"/shaders/hud_fragment.fs"</span>));</span><br><span class="line">    hudShaderProgram.link();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为正投影模型矩阵和颜色创建Uniform</span></span><br><span class="line">    hudShaderProgram.createUniform(<span class="string">"projModelMatrix"</span>);</span><br><span class="line">    hudShaderProgram.createUniform(<span class="string">"colour"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>render</code>方法首先会调用<code>renderScene</code>方法，里面包含了之前章节所述的渲染三维场景的代码，然后调用一个名为<code>renderHud</code>的新方法，用于渲染HUD。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window, Camera camera, GameItem[] gameItems,</span></span></span><br><span class="line"><span class="function"><span class="params">    SceneLight sceneLight, IHud hud)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">        window.setResized(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderScene(window, camera, gameItems, sceneLight);</span><br><span class="line"></span><br><span class="line">    renderHud(window, hud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>renderHud</code>方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renderHud</span><span class="params">(Window window, IHud hud)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hudShaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    Matrix4f ortho = transformation.getOrthoProjectionMatrix(<span class="number">0</span>, window.getWidth(), window.getHeight(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (GameItem gameItem : hud.getGameItems()) &#123;</span><br><span class="line">        Mesh mesh = gameItem.getMesh();</span><br><span class="line">        <span class="comment">// HUD元素的正投影矩阵与模型矩阵相乘</span></span><br><span class="line">        Matrix4f projModelMatrix = transformation.getOrtoProjModelMatrix(gameItem, ortho);</span><br><span class="line">        hudShaderProgram.setUniform(<span class="string">"projModelMatrix"</span>, projModelMatrix);</span><br><span class="line">        hudShaderProgram.setUniform(<span class="string">"colour"</span>, gameItem.getMesh().getMaterial().getAmbientColour());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染HUD元素</span></span><br><span class="line">        mesh.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hudShaderProgram.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们遍历了HUD的所有元素，并将与每个元素关联的模型矩阵和正投影矩阵相乘。正投影矩阵在每次<code>render</code>调用时被刷新（因为屏幕大小可以改变），并且通过如下方式计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Matrix4f <span class="title">getOrthoProjectionMatrix</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top)</span> </span>&#123;</span><br><span class="line">    orthoMatrix.identity();</span><br><span class="line">    orthoMatrix.setOrtho2D(left, right, bottom, top);</span><br><span class="line">    <span class="keyword">return</span> orthoMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>game</code>包中，我们将创建一个<code>Hud</code>类，它实现了<code>IHud</code>接口，并在构造函数接收一个文本用于在内部创建<code>TextItem</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector4f;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.GameItem;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.IHud;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.TextItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hud</span> <span class="keyword">implements</span> <span class="title">IHud</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FONT_COLS = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FONT_ROWS = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT_TEXTURE = <span class="string">"/textures/font_texture.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GameItem[] gameItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TextItem statusTextItem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hud</span><span class="params">(String statusText)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem = <span class="keyword">new</span> TextItem(statusText, FONT_TEXTURE, FONT_COLS, FONT_ROWS);</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.getMesh().getMaterial().setColour(<span class="keyword">new</span> Vector4f(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        gameItems = <span class="keyword">new</span> GameItem[]&#123;statusTextItem&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusText</span><span class="params">(String statusText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.setText(statusText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GameItem[] getGameItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> gameItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSize</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.setPosition(<span class="number">10f</span>, window.getHeight() - <span class="number">50f</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>DummyGame</code>类中我们创建该类的实例，用默认文本初始化它，最后得到如下所示的东西。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_result.png" alt="文本渲染结果"></p>
<p>在<code>Texture</code>类中，我们可以通过修改纹理的过滤来提高文本的可读性(如果你想要缩放文本的话，你需要注意)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure>
<p>但是例子还没有完成。如果你要缩放，使文本与立方体重叠时，就会看到这样的效果。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_opaque.png" alt="背景不透明的文本"></p>
<p>绘制的文本背景不透明。为了实现背景透明，我们必须明确启用混合(<code>Blend</code>)，这样就可以使用Alpha量。我们将在<code>Window</code>类中用下面的代码设置其他初始化参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持透明背景</span></span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>
<p>现在你可以看到文本以透明背景绘制了。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_transparent.png" alt="透明背景的文本"></p>
<h2 id="完成HUD"><a href="#完成HUD" class="headerlink" title="完成HUD"></a>完成HUD</h2><p>现在我们已经渲染了文本，但还可以向HUD添加更多的元素。我们将添加一个根据摄像机朝向旋转的指针。现在，我们将向<code>Hud</code>类添加一个新的<code>GameItem</code>，它将有一个指针的模型。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/compass.png" alt="指针"></p>
<p>指针的模型是.obj文件，但它不会关联任何纹理，相反，它只有背景颜色。所以我们需要修改HUD的片段着色器，来检测是否使用纹理。我们将通过设置一个名为<code>hasTexture</code>的新Uniform来实现它。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> mvPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> colour;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> hasTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( hasTexture == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = colour * <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = colour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要添加指针到HUD上，我们只需要在<code>Hud</code>类中创建一个新的<code>GameItem</code>实例。它加载指针模型，并将其添加到数组中。现在，我们需要放大指针。因为它在屏幕坐标中渲染，所以通常你需要放大它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指针</span></span><br><span class="line">Mesh mesh = OBJLoader.loadMesh(<span class="string">"/models/compass.obj"</span>);</span><br><span class="line">Material material = <span class="keyword">new</span> Material();</span><br><span class="line">material.setAmbientColour(<span class="keyword">new</span> Vector4f(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">mesh.setMaterial(material);</span><br><span class="line">compassItem = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">compassItem.setScale(<span class="number">40.0f</span>);</span><br><span class="line"><span class="comment">// 进行旋转变换，使它转换到屏幕坐标系</span></span><br><span class="line">compassItem.setRotation(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">180f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组，用于储存HUD组件</span></span><br><span class="line">gameItems = <span class="keyword">new</span> GameItem[]&#123;statusTextItem, compassItem&#125;;</span><br></pre></td></tr></table></figure>
<p>还要注意的是，为了使罗盘向上指，我们需要旋转180°，因为模型通常倾向于使用OpenGL空间坐标系。如果我们要求使用屏幕坐标，它会指向下方。<code>Hud</code>类还提供一个方法来更新指针的指向，这也必须要考虑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateCompass</span><span class="params">(<span class="keyword">float</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.compassItem.setRotation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span> + angle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>DummyGame</code>类中，每当摄像机移动时，我们需要更新角度。我们需要使用Y角旋转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据鼠标更新摄像机            </span></span><br><span class="line"><span class="keyword">if</span> (mouseInput.isRightButtonPressed()) &#123;</span><br><span class="line">    Vector2f rotVec = mouseInput.getDisplVec();</span><br><span class="line">    camera.moveRotation(rotVec.x * MOUSE_SENSITIVITY, rotVec.y * MOUSE_SENSITIVITY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新HUD指针</span></span><br><span class="line">    hud.rotateCompass(camera.getRotation().y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会看到这样的东西(记住它只是个例子，在实际的游戏中，你可能想使用一些纹理来更改指针的外观)。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/hud_compass.png" alt="有指针的HUD"></p>
<h2 id="再谈文本渲染"><a href="#再谈文本渲染" class="headerlink" title="再谈文本渲染"></a>再谈文本渲染</h2><p>在回顾其他主题之前，让我们再谈谈之前介绍的文本渲染方法。该方案非常简单和方便地介绍了渲染HUD所涉及的概念，但它有一些问题：</p>
<ul>
<li>它不支持非拉丁字符。</li>
<li>如果你想使用多种字体，则需要为每种字体创建单独的纹理文件。此外，改变文本大小的唯一方法是缩放，这会导致渲染文本的质量较差，或者需要创建额外的纹理文件。</li>
<li>最重要的是，大多数字体中的字符之间的大小并不同，而我们将字体纹理分割成同样大小的元素。我们使用了<a href="https://en.wikipedia.org/wiki/Monospaced_font" target="_blank" rel="noopener">Monospaced</a>风格(即所有字符具有相同的宽度)的“Consolas”字体，但如果使用非Monospaced的字体，就会看到字符之间恼人的空白。</li>
</ul>
<p>我们需要更改方法，提供一种更灵活的渲染文本方式。如果你思考一下，整个想法是可行的，也就是通过单独渲染每个字符的矩形来渲染文本。这里的问题就是该如何生成纹理。我们需要通过系统中可用的字体动态地生成这些纹理。</p>
<p>这就需要<code>java.awt.Font</code>出马了，我们将通过指定字体系列和大小动态地绘制每一个字符来生成纹理。该纹理的使用方式与之前描述的相同，但它将完美地解决上述所有问题。我们将创建一个名为<code>FontTexture</code>的新类，该类将接受<code>Font</code>实例和字符集名称，并将动态地创建包含所有可用字符的纹理。下面是构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FontTexture</span><span class="params">(Font font, String charSetName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.font = font;</span><br><span class="line">    <span class="keyword">this</span>.charSetName = charSetName;</span><br><span class="line">    charMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    buildTexture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要处理非拉丁字符问题，指定字符集和字体，我们将创建一个包含所有可渲染字符的<code>String</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getAllAvailableChars</span><span class="params">(String charsetName)</span> </span>&#123;</span><br><span class="line">    CharsetEncoder ce = Charset.forName(charsetName).newEncoder();</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; Character.MAX_VALUE; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ce.canEncode(c)) &#123;</span><br><span class="line">            result.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来看看实际创建纹理的<code>buildTexture</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTexture</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FontMetrics获取每个字符信息</span></span><br><span class="line">    BufferedImage img = <span class="keyword">new</span> BufferedImage(<span class="number">1</span>, <span class="number">1</span>, BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">    Graphics2D g2D = img.createGraphics();</span><br><span class="line">    g2D.setFont(font);</span><br><span class="line">    FontMetrics fontMetrics = g2D.getFontMetrics();</span><br><span class="line"></span><br><span class="line">    String allChars = getAllAvailableChars(charSetName);</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : allChars.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 获取每个字符的大小，并更新图像大小</span></span><br><span class="line">        CharInfo charInfo = <span class="keyword">new</span> CharInfo(width, fontMetrics.charWidth(c));</span><br><span class="line">        charMap.put(c, charInfo);</span><br><span class="line">        width += charInfo.getWidth();</span><br><span class="line">        height = Math.max(height, fontMetrics.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    g2D.dispose();</span><br></pre></td></tr></table></figure>
<p>我们首先通过创建创建临时图像来获得<code>FontMetrics</code>，然后遍历包含所有可用字符的<code>String</code>，并在<code>FontMetrics</code>的帮助下获取字体的宽度。我们把这些信息储存在一个<code>charMap</code>上，以字符作为<code>Map</code>的键。这样，我们就确定了纹理图像的大小(图像的高度等于所有字符的最大高度，而宽度等于所有字符的宽度总和)。<br><code>ChatSet</code>是一个内部类，它储存关于字符的信息(它的宽度和它在纹理图像中的起点)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharInfo</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startX = startX;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStartX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们将创建一个包含所有可用字符的图像，只需要在<code>BufferedImage</code>上绘制字符串即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建与字符集相关的图像</span></span><br><span class="line">img = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">g2D = img.createGraphics();</span><br><span class="line">g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">g2D.setFont(font);</span><br><span class="line">fontMetrics = g2D.getFontMetrics();</span><br><span class="line">g2D.setColor(Color.WHITE);</span><br><span class="line">g2D.drawString(allChars, <span class="number">0</span>, fontMetrics.getAscent());</span><br><span class="line">g2D.dispose();</span><br></pre></td></tr></table></figure>
<p>我们正在生成一个包含所有字符的单行图像(可能不满足纹理大小应该为二的幂的前提，但是它仍适用于大多数现代显卡。在任何情况下，你都可以通过增加额外的空白来解决这个问题)。你甚至可以看到生成的图像，在代码之后，添加这样的一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageIO.write(img, IMAGE_FORMAT, <span class="keyword">new</span> java.io.File(<span class="string">"Temp.png"</span>));</span><br></pre></td></tr></table></figure>
<p>图像将被写入一个临时文件。该文件将包含一长条可用的所有字符，在白色背景下启用反走样绘制。</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/texture_font.png" alt="字体纹理"></p>
<p>最后只需要从那个图像创建一个<code>Texture</code>实例，我们只需使用PNG格式转储图像字节(这就是<code>Texture</code>类所需要的)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 将图像转储到字节缓冲区</span></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">        ImageIO.write(img, IMAGE_FORMAT, out);</span><br><span class="line">        out.flush();</span><br><span class="line">        is = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    texture = <span class="keyword">new</span> Texture(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到，我们已经稍微修改了<code>Texture</code>类，以便可以使用一个接收<code>InputStream</code>的构造函数。现在我们只需要修改<code>TextItem</code>类，就可以在构造函数中接收<code>FontTexture</code>实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextItem</span><span class="params">(String text, FontTexture fontTexture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.fontTexture = fontTexture;</span><br><span class="line">    setMesh(buildMesh());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buildMesh</code>方法只需要稍稍改变矩形坐标和纹理坐标的设置，这是其中一个顶点的示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> startx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numChars; i++) &#123;</span><br><span class="line">    FontTexture.CharInfo charInfo = fontTexture.getCharInfo(characters[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造由两个三角形组成的字符片段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上角顶点</span></span><br><span class="line">    positions.add(startx); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">// y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">// z</span></span><br><span class="line">    textCoords.add( (<span class="keyword">float</span>)charInfo.getStartX() / (<span class="keyword">float</span>)fontTexture.getWidth());</span><br><span class="line">    textCoords.add(<span class="number">0.0f</span>);</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更多代码...</span></span><br><span class="line">  startx += charInfo.getWidth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在源代码中查看其他修改。下面的图片是一个大小为20的Arial字体的渲染结果：</p>
<p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_rendered_improved.png" alt="改进后的文本"></p>
<p>你可以看到文本渲染的质量已经有了很大的提升，你可以用不同的字体和大小来渲染。这仍然有很大的改进空间(比如支持多行文本、特效等)，但这留给各位读者作为练习。</p>
<p>你可能还注意到，我们仍然能够缩放文本(通过着色器中的模型观察矩阵)。文本可能不需要，但对其他的HUD元素可能有用。</p>
<p>我们已经建立了所有的基础结构来为游戏创建一个HUD。现在，只剩一个问题，那就是创建所有的元素，传递相关信息给用户，并给他们一个专业的外观。</p>
<h2 id="OSX"><a href="#OSX" class="headerlink" title="OSX"></a>OSX</h2><p>如果你试图运行本章中的示例，以及下一个渲染文本的示例，则可能会发现应用程序和屏幕上没有显示任何内容。这是由于AWT和GLFW在OSX下相处得“很好”。但这和AWT有什么关系呢？我们使用的是<code>Font</code>类，它属于AWT，如果要实例化它，AWT也需要初始化。在OSX中，AWT试图在主线程运行，但GLFW也需要这样。这就是造成这种混乱的原因。</p>
<p>为了能够使用<code>Font</code>类，GLFW必须在AWT之前初始化，并且示例需要以Headless模式运行。你需要在任何东西被初始化之前设置这个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.awt.headless"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
<p>你也许会得到一个警告，但示例成功运行了。</p>
<p>一个更简洁的方法是使用<a href="https://github.com/nothings/stb/" target="_blank" rel="noopener">stb</a>库来渲染文本。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/LwjglBook/">LwjglBook</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a><a href="/tags/LWJGL/">LWJGL</a><a href="/tags/OpenGL/">OpenGL</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/" data-title="使用LWJGL3开发3D游戏 第十二章 游戏HUD | 耗子的博客" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/" title="使用LWJGL3开发3D游戏 第十三章 天空盒与一些优化">
  <strong>上一篇：</strong><br>
  <span>
  使用LWJGL3开发3D游戏 第十三章 天空盒与一些优化</span>
</a>
</div>


<div class="next">
<a href="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/" title="使用LWJGL3开发3D游戏 第十一章 要有更多的光">
 <strong>下一篇：</strong><br> 
 <span>使用LWJGL3开发3D游戏 第十一章 要有更多的光
</span>
</a>
</div>

</nav>

	



	
  <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '7aa03b00f01b00627546',
  clientSecret: '3b6ba50fa682ea7b0acced5106630a95921bfd92',
  repo: 'mouse0w0.github.io',
  owner: 'Mouse0w0',
  admin: ['Mouse0w0'],
  id: '使用LWJGL3开发3D游戏 第十二章 游戏HUD',      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')
</script>
  
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#文本渲染"><span class="toc-number">1.</span> <span class="toc-text">文本渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完成HUD"><span class="toc-number">2.</span> <span class="toc-text">完成HUD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再谈文本渲染"><span class="toc-number">3.</span> <span class="toc-text">再谈文本渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSX"><span class="toc-number">4.</span> <span class="toc-text">OSX</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Mouse0w0" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>
</div>



  
<div class="afdian-card">
<p class="asidetitle">给作者发电</p>
<iframe class="afdian_iframe" src="https://afdian.net/leaflet?slug=mouse" height="260" scrolling="no" frameborder="0"></iframe>
</div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/LwjglBook/" title="LwjglBook">LwjglBook<sup>18</sup></a></li>
		  
		
		  
			<li><a href="/categories/Mixin/" title="Mixin">Mixin<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/LWJGL/" title="LWJGL">LWJGL<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/Mixin/" title="Mixin">Mixin<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Bytecode/" title="Bytecode">Bytecode<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C/C++">C/C++<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Tool/" title="Tool">Tool<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Script/" title="Script">Script<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Windows/" title="Windows">Windows<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Forge/" title="Forge">Forge<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Nukkit/" title="Nukkit">Nukkit<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Nashorn/" title="Nashorn">Nashorn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/VSCode/" title="VSCode">VSCode<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JNI/" title="JNI">JNI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Kotlin/" title="Kotlin">Kotlin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Graphics/" title="Graphics">Graphics<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Math/" title="Math">Math<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.mcbbs.net/group-1181-1.html" target="_blank" title="一个综合性开发团队">未知之域</a>
            
          </li>
        
          <li>
            
            	<a href="https://mouse0w0.github.io/lwjglbook-CN-Translation/" target="_blank" title="《用LWJGL3开发3D游戏》中文翻译">《用LWJGL3开发3D游戏》中文翻译</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/Mouse0w0/BungeeCordChineseTutorial" target="_blank" title="BungeeCord插件开发中文教程">BungeeCord插件开发中文教程</a>
            
          </li>
        
          <li>
            
            	<a href="https://github.com/Mouse0w0/MinecraftDeveloperGuide" target="_blank" title="Minecraft开发者中文指南">Minecraft开发者中文指南</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="./atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 这是耗子的博客。 <br>
			想要变强。</p>
	</section>
	 
	<div class="social-font">
		
		
		<a href="https://github.com/Mouse0w0" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc-sa.svg" alt="Creative Commons">
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="Mouse0w0">Mouse0w0</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
    </script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] } });
    </script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Queue(function() { var all = MathJax.Hub.getAllJax(), i; for(i=0; i
        < all.length; i +=1 ) { all[i].SourceElement().parentNode.className +=' has-jax' ; } }); </script>

            <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
            </script>
            
<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
