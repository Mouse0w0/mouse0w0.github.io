<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耗子的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mouse0w0.github.io/"/>
  <updated>2019-02-28T11:47:16.785Z</updated>
  <id>https://mouse0w0.github.io/</id>
  
  <author>
    <name>Mouse0w0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十八章 阴影</title>
    <link href="https://mouse0w0.github.io/2019/02/28/Lwjglbook-18-shadows/"/>
    <id>https://mouse0w0.github.io/2019/02/28/Lwjglbook-18-shadows/</id>
    <published>2019-02-28T11:46:21.000Z</published>
    <updated>2019-02-28T11:47:16.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter18" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter18</a></p><p>英文标题：Shadows</p></blockquote><h2 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h2><p>目前，我们能够表现光线如何影响三维场景中的对象。接收到更多光的物体比没有接收光的物体更亮。然而，我们仍无法投射阴影。阴影能增加3D场景的真实度，因此我们将在本章中添加对它的支持。</p><p>我们将使用一种被称为阴影映射（Shadow Mapping）的技术，这种技术被广泛使用于游戏中，且不会严重影响引擎性能。阴影映射看起来很容易理解，但是很难正确地实现它。或者更准确地说，很难用一种通用的，涵盖了一切可能并产生一致的效果的方法去实现它。</p><p>我们将在此说明一种方法，它可以为你在大多数情况下添加阴影，但更重要的是，它将帮助你了解其局限性。这里介绍的代码远不是完美的，但我认为它很容易理解。它还被设计用于支持有向光（这我认为是更复杂的情况），但你将了解如何将其扩展以支持其他类型的光照（例如点光源）。如果你想获得更高级的效果，你应该使用更高级的技术，例如层叠阴影图（Cascaded Shadow Maps）。在任何情况下，这里解释的概念都仅仅作为基础。</p><p>所以，让我们从思考如何检查特定区域（实际上是片元）是否在阴影中开始。在绘制这个区域的时候，我们可以发出射线投射到光源上，如果我们可以在不发生任何碰撞的情况下到达光源，那么像素就在光照中，反之，像素处于阴影中。</p><p>下图展示了点光源的情况，点PA可以到达光源，但点PB和PC不行，因此它们位于阴影中。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/shadow_concepts_I.png" alt="阴影概述I"></p><p>那么，我们如何才能检查是否能以一种有效的方式发射出不发生碰撞的射线呢？理论上，光源可以投射出无限的光线，Name我们如何检查光线是否被遮挡？</p><p>我们能做的不是投射光线，而是从光线透视图中观察3D场景，并从该位置渲染场景。我们可以将相机设置在光源位置并渲染场景，以便储存每个片元的深度。这相当于计算每个片元到光源的距离。最后，我们要做的是将光照所及的最小距离储存为阴影图。</p><p>下图展示了一个悬浮在平面上并垂直于光线的立方体。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/shadow_concepts_II.png" alt="阴影概述II"></p><p>从光源的角度看，情况是这样的（颜色越深，越接近光源）。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/render_light_perspective.png" alt="从光源的角度渲染"></p><p>利用这些信息。我们可以像往常一样渲染3D场景，并以最小储存距离检查每个每个片元到光源的距离。如果距离小于阴影贴图中储存的值，则对象位于光照中，否则位于阴影中。我们可以让几个物体被同一光照照射，但我们储存最小距离。</p><p>因此，阴影映射分为两步：</p><ul><li>首先，我们将场景从光照空间渲染为阴影图，以获得最小距离。</li><li>其次，我们从摄像机的视角渲染场景。并使用深度图计算对象是否位于阴影中。</li></ul><p>为了渲染深度图，我们需要说说深度缓冲区（Depth-buffer）。当我们渲染一个场景时，所有深度信息都储存在一个名为“深度缓冲区”（又称“Z缓冲区（Z-buffer）”）的缓冲区中。深度信息是渲染的每个片元的$z$值。如果你从第一章回忆我们在渲染场景时，将正在渲染的场景从世界坐标转换为屏幕坐标。我们所绘制的坐标空间，对于$x$和$y$轴来说，坐标的范围为$0$到$1$。如果一个物体比其他对象原，我们必须通过透视投影矩阵计算它如何影响其$x$和$y$坐标。这不是根据$z$值自动计算的，它必须由我们来做。实际储存在$z$坐标中的是它在片元的深度，仅此而已。</p><p>此外，在源代码中，我们启用了深度测试。在<code>Window</code>类中，我们添加如下行：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>通过添加这行，我们可以防止无法看到的片元被绘制出来，因为他们位于其他对象之后。在绘制片元之前，它的$z$值将与Z缓冲区中的$z$值进行比较。如果它的$z$值（它的距离）大于缓冲区的$z$值，则会被丢弃。请记住，这是在屏幕空间中完成的，因此，给定一对屏幕空间中范围为$[0, 1]$的$x$和$y$坐标，我们比较其片元的$z$值。同样，$z$值也在此范围内。</p><p>深度缓冲区的存在是我们在执行任何渲染操作之前需要清除屏幕的原因。我们不仅需要清除颜色，还要清除深度信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了开始构建深度图，我们希望从光源的角度获得深度信息。我们需要在光源位置设置一个摄像头，渲染场景并将深度信息储存到纹理中，以便稍后访问它。</p><p>因此，我们首先需要做的是添加对创建这些纹理的支持。我们将修改<code>Texture</code>类，通过添加新的构造函数来支持创建空纹理。此构造函数需要纹理的尺寸以及它储存的像素的格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Texture</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> pixelFormat)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = glGenTextures();</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="keyword">this</span>.id);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height, <span class="number">0</span>, pixelFormat, GL_FLOAT, (ByteBuffer) <span class="keyword">null</span>);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将纹理环绕方式设置为<code>GL_CLAMP_TO_EDGE</code>，因为我们不希望在超出$[0, 1]$范围时重复纹理。</p><p>所以，现在我们可以创建空的纹理，我们需要能够在其中渲染一个场景。为了做到它，我们需要使用帧缓冲区对象（Frame Buffers Objects，或称FBOs）。帧缓冲区是可以作为渲染终点的缓冲区集合。当我们渲染到屏幕上时，我们使用的是OpenGL的默认缓冲区。OpenGL允许我们使用FBO渲染到用户定义的缓冲区。我们将通过创建一个名为<code>ShadowMap</code>的新类，来隔离为阴影映射创建FBO过程的其余代码。如下就是那个类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL11.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL30.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHADOW_MAP_WIDTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHADOW_MAP_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> depthMapFBO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Texture depthMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建FBO以渲染深度图</span></span><br><span class="line">        depthMapFBO = glGenFramebuffers();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建深度图纹理</span></span><br><span class="line">        depthMap = <span class="keyword">new</span> Texture(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT, GL_DEPTH_COMPONENT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定深度图纹理到FBO</span></span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line">        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap.getId(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 仅设置深度</span></span><br><span class="line">        glDrawBuffer(GL_NONE);</span><br><span class="line">        glReadBuffer(GL_NONE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Could not create FrameBuffer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解绑</span></span><br><span class="line">        glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Texture <span class="title">getDepthMapTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depthMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepthMapFBO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depthMapFBO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        glDeleteFramebuffers(depthMapFBO);</span><br><span class="line">        depthMap.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShadowMap</code>类定义了两个常量，用于确定储存深度图的纹理的大小。它还定义了两个属性，一个用于FBO，一个用于纹理。在构造函数中，创建一个新的FBO和一个新的<code>Texture</code>。对于FBO，将使用常量<code>GL_DEPTH_COMPONENT</code>作为像素格式，因为我们只对储存深度值感兴趣，然后将FBO绑定到纹理实例。</p><p>以下几行代码显式地将FBO设置为不渲染任何颜色。FBO需要颜色缓冲区，但我们不需要，这就是为什么我们将颜色缓冲区设置为<code>GL_NONE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawBuffer(GL_NONE);</span><br><span class="line">glReadBuffer(GL_NONE);</span><br></pre></td></tr></table></figure><p>现在，我们准备在<code>Renderer</code>类中将场景从灯光透视渲染为FBO。为了做到它，我们将创建一组特殊的顶点和片元着色器。</p><p>名为<code>depth_vertex.vs</code>的顶点着色器的定义如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelLightViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> orthoProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = orthoProjectionMatrix * modelLightViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望接收与场景着色器相同的输入数据。但实际上，我们只需要坐标，但是为了尽可能多地重用代码，我们还是要传送其他数据。我们还需要一对矩阵。记住，我们必须以光源的角度渲染场景，所以我们需要将模型转换到光源的坐标空间。这是通过<code>modelLightViewMatrix</code>矩阵完成的，该矩阵类似于用于摄像机的模型观察矩阵。现在光源是我们的摄像机。</p><p>然后我们需要将这些坐标转换到屏幕空间，也就是说，需要投影它们。这是计算平行光与点光源的阴影图时的区别之一。对于地昂扬，我们将使用透视投影（Perspective Projection）矩阵，就像我们正常渲染场景一样。相反，平行光以相同方式影响所有对象，而与距离无关。平行光源位于无穷远的点上，没有位置，只有方向。正交投影（Orthographic Projection）不会使远处的物体变小，因此，正交投影最适合平行光。</p><p>片元着色器更简单。它只输出$z$坐标作为深度值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragDepth</span> = <span class="built_in">gl_FragCoord</span>.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，你可以删掉该行，因为我们只生成深度值，深度值将自动返回。</p><p>一旦我们为深度渲染定义了新的着色器，就可以在<code>Renderer</code>类中使用它们。我们为初始化这些着色器定义了一个新方法，名为<code>setupDepthShader</code>，它将在其他着色器被初始化时调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupDepthShader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    depthShaderProgram = <span class="keyword">new</span> ShaderProgram();</span><br><span class="line">    depthShaderProgram.createVertexShader(Utils.loadResource(<span class="string">"/shaders/depth_vertex.vs"</span>));</span><br><span class="line">    depthShaderProgram.createFragmentShader(Utils.loadResource(<span class="string">"/shaders/depth_fragment.fs"</span>));</span><br><span class="line">    depthShaderProgram.link();</span><br><span class="line"></span><br><span class="line">    depthShaderProgram.createUniform(<span class="string">"orthoProjectionMatrix"</span>);</span><br><span class="line">    depthShaderProgram.createUniform(<span class="string">"modelLightViewMatrix"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们需要创建一个新的方法，使用那些名为<code>renderDepthMap</code>的着色器。该方法将在主渲染方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window, Camera camera, Scene scene, IHud hud)</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在设置视口之前渲染深度图</span></span><br><span class="line">    renderDepthMap(window, camera, scene);</span><br><span class="line"></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其余的代码在这...</span></span><br></pre></td></tr></table></figure><p>如果你浏览上述代码，将看到在设置视口之前，新方法就已经被调用。这是因为这个新方法将更高视口以匹配保存深度图的纹理的尺寸。因此，在完成<code>renderDepthMap</code>之后，我们将始终需要设置屏幕尺寸的视口（不检查窗口是否已调整大小）。</p><p>现在让我们定义一下<code>renderDepthMap</code>方法。第一件事是绑定在<code>ShadowMap</code>类中创建的FBO，并设置视口以匹配纹理尺寸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, shadowMap.getDepthMapFBO());</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, ShadowMap.SHADOW_MAP_WIDTH, ShadowMap.SHADOW_MAP_HEIGHT);</span><br></pre></td></tr></table></figure><p>然后，清除深度缓冲区内容并绑定深度着色器。因为我们只处理深度值，所以不需要清除颜色信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">depthShaderProgram.bind();</span><br></pre></td></tr></table></figure><p>现在我们需要设置矩阵，接下来是棘手的部分。我们使用光源作为摄像机，所以需要创建一个需要一个坐标和三个角的观察矩阵。正如本章开头所说，我们只实现平行光，这种类型的光不定义位置，而是定义方向。如果我们使用点光源，这很容易，光源的位置就是观察矩阵的位置，但我们没有位置。</p><p>我们将采用一种简单的方法来计算光的位置。平行光是由一个向量定义的，通常是归一化的，它指向光源所在的方向。我们把这个方向向量乘以一个可配置的因子，在这样它就为要绘制的场景定义了一个合理距离的点。我们将使用该方向来计算该观察矩阵的旋转角度。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/light_position.png" alt="光源位置"></p><p>这是计算灯光位置与旋转角度的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> lightAngleX = (<span class="keyword">float</span>)Math.toDegrees(Math.acos(lightDirection.z));</span><br><span class="line"><span class="keyword">float</span> lightAngleY = (<span class="keyword">float</span>)Math.toDegrees(Math.asin(lightDirection.x));</span><br><span class="line"><span class="keyword">float</span> lightAngleZ = <span class="number">0</span>;</span><br><span class="line">Matrix4f lightViewMatrix = transformation.updateLightViewMatrix(<span class="keyword">new</span> Vector3f(lightDirection).mul(light.getShadowPosMult()), <span class="keyword">new</span> Vector3f(lightAngleX, lightAngleY, lightAngleZ));</span><br></pre></td></tr></table></figure><p>接下我们需要计算正交投影矩阵：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matrix4f orthoProjMatrix = transformation.updateOrthoProjectionMatrix(orthCoords.left, orthCoords.right, orthCoords.bottom, orthCoords.top, orthCoords.near, orthCoords.far);</span><br></pre></td></tr></table></figure><p>我们已经修改了<code>Transformation</code>类，以囊括光照观察矩阵和正交投影矩阵。此们有一个正交的二维投影矩阵，所以我们重命名了此前的方法和属性，你可以直接查看源代码中的定义。</p><p>然后，我们按照<code>renderScene</code>方法渲染场景对象，但在光照空间坐标系中使用上述矩阵工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">depthShaderProgram.setUniform(<span class="string">"orthoProjectionMatrix"</span>, orthoProjMatrix);</span><br><span class="line">Map&lt;Mesh, List&lt;GameItem&gt;&gt; mapMeshes = scene.getGameMeshes();</span><br><span class="line"><span class="keyword">for</span> (Mesh mesh : mapMeshes.keySet()) &#123;</span><br><span class="line">    mesh.renderList(mapMeshes.get(mesh), (GameItem gameItem) -&gt; &#123;</span><br><span class="line">        Matrix4f modelLightViewMatrix = transformation.buildModelViewMatrix(gameItem, lightViewMatrix);</span><br><span class="line">        depthShaderProgram.setUniform(<span class="string">"modelLightViewMatrix"</span>, modelLightViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑</span></span><br><span class="line">depthShaderProgram.unbind();</span><br><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>正交投影矩阵的参数是在平行光中定义的。将正交投影矩阵想象为一个边界框，其中包含我们要渲染的所有对象。当只投影适合该边界框的对象时，对象将可视。该边界框由6个参数定义：左、右、上、下、近、远。由于光源位置现在是原点，因此这些参数定义为原点到左或右（x轴）或上或下（y轴）或远或近（z轴）的距离。</p><p>要使阴影图正常工作，最棘手的一点是确定灯光位置和正交投影矩阵的参数。这就是所有这些参数现在在<code>DirectionalLight</code>类中定义的方式，因此可以根据每个场景正确设置这些参数。</p><p>你可以实现一个更自动的方法，通过计算摄像机截锥（Frustum）的中心，回到光的方向，建立一个包含场景中所有对象的正交投影。下图展示了如上所述的三维场景、相机位置、截锥（蓝色）、最佳光源位置以及红色的边界框。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/generic_light_pos_calculation.png" alt="通用光源位置计算"></p><p>上述方法的问题是很难计算，如果你有很小的物体，并且边界框很大，你可以会得到奇怪的结果。这里介绍的方法对于小场景更简单，你可以调整它以匹配你的模型（即使你可以选择显式设置灯光的位置，以避免相机远离原点移动时产生奇怪的效果）。如果你想要一个更通用的模板，可以应用到任何场景，你应该扩展它，以支持层叠阴影图。</p><p>让我们继续。在使用深度图实际计算阴影之前，可以使用生成的纹理渲染一个正方形，以观察深度图的实际外观。在有一个旋转立方体漂浮在一个有垂直平行光的平面上的场景中，你可以得到如下结果。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/depth_map.png" alt="深度图"></p><p>如上所述，颜色越深，离光源的位置越近。深度图中光源位置的影响是什么？你可以修改平行光照的倍增因子，将看到在纹理中渲染的对象的大小不会变小。记住，我们使用的是正交投影矩阵，物体不会随着距离增大而变小。你将看到的是，所有的颜色都会变得更亮，如下所示：</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/depth_map_higher_distance.png" alt="更远的距离的深度图">  </p><p>这是否意味着我们可以为光源选择一个较远的位置而不造成任何后果呢？答案是不行。如果光源离我们要渲染的对象太远，这些对象会超出正交投影矩阵定义的边界框。在此情况下，你会得到一个不错的白色纹理，但这是没用的阴影图。好的，那么我们只需增加边界框的大小，一切都会好的，对吗？答案也是不行。如果你为正交投影矩阵选用了巨大的尺寸，你的物体在纹理中会被绘制得很小，深度值甚至会重叠，造成奇怪的结果。好吧，所以你可以考虑增加纹理大小，但在此情况下，你是有限制的，纹理不能因使用巨大的编辑框而无限增大。</p><p>因此，可以看到，选择光源的位置和正交投影的参数是一个复杂的平衡，这使得使用阴影图很难得到正确的效果。</p><p>让我们回到渲染过程，一旦计算了深度图，我们就可以在渲染场景时使用它。首先，我们需要修改场景的顶点着色器。到目前为止，顶点着色器使用透视矩阵将顶点坐标从模型观察空间投影到屏幕空间。现在还需要使用投影矩阵从光照空间坐标投影顶点坐标，以用于片元着色器中计算阴影。</p><p>顶点着色器是这样修改的：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> mlightviewVertexPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">mat4</span> outModelViewMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelLightViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> orthoProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> mvPos = modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * mvPos;</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">    mvVertexNormal = <span class="built_in">normalize</span>(modelViewMatrix * <span class="type">vec4</span>(vertexNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">    mvVertexPos = mvPos.xyz;</span><br><span class="line">    mlightviewVertexPos = orthoProjectionMatrix * modelLightViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    outModelViewMatrix = modelViewMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为光照观察矩阵和正交投影矩阵使用了新的Uniform。</p><p>在片元着色器中，我们将创建一个新的函数来计算阴影，代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> calcShadow(<span class="type">vec4</span> position)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> shadowFactor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">vec3</span> projCoords = position.xyz;</span><br><span class="line">    <span class="comment">// 从屏幕坐标变换到纹理坐标</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">if</span> ( projCoords.z &lt; <span class="built_in">texture</span>(shadowMap, projCoords.xy).r ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前片元不在阴影中</span></span><br><span class="line">        shadowFactor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - shadowFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收使用正交投影矩阵投影的光照观察空间的坐标。如果坐标在阴影中，则返回$0$，如果不在阴影中，则返回$1$。首先，将坐标转换为纹理坐标。屏幕坐标在$[-1, 1]$范围内，但纹理坐标在$[0, 1]$范围内。我们通过坐标从纹理中获取深度值，并将其与片元坐标的$z$值比较。如果$z$值低于储存在纹理中的值，则表示片元不再阴影中。</p><p>在片元着色器中，<code>calcShadow</code>函数的返回值，用于调节点光源、聚光源和平行光对光照颜色的共享。环境光不受阴影的影响。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = calcShadow(mlightviewVertexPos);</span><br><span class="line">fragColor = <span class="built_in">clamp</span>(ambientC * <span class="type">vec4</span>(ambientLight, <span class="number">1</span>) + diffuseSpecularComp * shadow, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在<code>Renderer</code>类的<code>renderScene</code>方法中，我们只需要传递正交投影和光照观察矩阵到Uniform（我们还需要修改着色器的初始化方法以创建新的Uniform）。你可以在本书的源代码中了解。</p><p>如果运行<code>DummyGame</code>类，该类已被修改为在带有平行光的平面上设置有悬浮的立方体，并可使用上下键修改角度，则应该看到如下情况。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/shadow_map_result.png" alt="阴影图结果"></p><p>虽然阴影已经工作了（你可以通过移动光照方向来检查），但是实际会出现一些问题。首先，被照亮的物体中有奇怪的线条。这种情况被称为阴影失真（Shadow Acne），它是由储存深度图的纹理的分辨率有限造成的。第二个问题是，阴影的边界不平滑，看起来很粗糙。原因同样，纹理分辨率。我们将解决这些问题，以提高阴影质量。</p><h2 id="改进阴影映射"><a href="#改进阴影映射" class="headerlink" title="改进阴影映射"></a>改进阴影映射</h2><p>既然我们已经有了阴影映射机制，那么让我们来解决现有的问题。我们先从失真问题开始。深度图纹理大小有限，因此，可以将多个片元映射到该纹理深度中的同一像素。纹理深度储存最小深度，因此到最后，我们有几个片元共享相同的深度，尽管它们的距离不同。</p><p>我们可以通过增加片元着色器中的深度比较来解决这个问题，我们添加了一个偏移。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>;</span><br><span class="line"><span class="keyword">if</span> ( projCoords.z - bias &lt; <span class="built_in">texture</span>(shadowMap, projCoords.xy).r ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前片元不在阴影中</span></span><br><span class="line">    shadowFactor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，阴影失真消失了。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/shadow_no_acne.png" alt="无阴影失真"></p><blockquote><p>译者注：使用偏移来消除阴影失真又会造成悬浮（Peter Panning）问题，另请参阅<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/" target="_blank" rel="noopener">LearnOpenGL阴影映射</a>一文。</p></blockquote><p>现在我们要解决的是去阴影边缘问题，这也是由纹理分辨率引起的。对于每个片元，我们将使用片元的坐标值和周围的值对深度图进行采样。然后我们将计算平均值并将该值指定为阴影值。在此情况下，它的值不会是$0$和$1$但可以在两者间取值，以获得更平滑的边缘。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/depth_average_value.png" alt="深度平均值"></p><p>在纹理坐标中，周围值必须与当前片元位置保持一个像素距离。所以我们需要计算纹理坐标中一个像素的增量，它等于$1 / 纹理大小$。</p><p>在片元着色器中，我们只需要修改阴影银子的计算来得到一个平均值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadowFactor = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">vec2</span> inc = <span class="number">1.0</span> / <span class="built_in">textureSize</span>(shadowMap, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row = <span class="number">-1</span>; row &lt;= <span class="number">1</span>; ++row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> col = <span class="number">-1</span>; col &lt;= <span class="number">1</span>; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> textDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy + <span class="type">vec2</span>(row, col) * inc).r; </span><br><span class="line">        shadowFactor += projCoords.z - bias &gt; textDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">shadowFactor /= <span class="number">9.0</span>;</span><br></pre></td></tr></table></figure><p>现在结果看起来更平滑了。</p><p><img src="/2019/02/28/Lwjglbook-18-shadows/final_result.png" alt="最终结果"></p><p>现在我们的示例看起来好多了。尽管如此，这里介绍的阴影映射技术仍有很大的改进空间。你可以查看如何解决悬浮（Peter Panning）效果（因偏移引起）和其他改进阴影边缘的计算。无论如何，有了这里所讲解的概念，你就有了开始修改示例的良好基础。</p><p>为了渲染多个光源，你只需要为每个光源渲染一个深度图。在渲染场景时，你需要采样所有的深度图来计算合适的阴影系数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter18&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十七章 法线贴图</title>
    <link href="https://mouse0w0.github.io/2019/02/28/Lwjglbook-17-normal-mapping/"/>
    <id>https://mouse0w0.github.io/2019/02/28/Lwjglbook-17-normal-mapping/</id>
    <published>2019-02-28T11:44:35.000Z</published>
    <updated>2019-02-28T11:45:48.322Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter17" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter17</a></p><p>英文标题：Normal Mapping</p></blockquote><p>本章中将讲解一项技术，它将极大地改善我们的3D模型的外观。到目前为止，我们已经能够将纹理使用到复杂的3D模型上，但这还离真实物体的样子很远。现实世界中的物体表面不是完全光滑的，它们有我们的3D模型目前所不具有的瑕疵。</p><p>为了渲染更真实的场景，我们将渲染<strong>法线贴图(Normal Mapping)</strong>。如果你在现实世界中看到一个平面，你会发现那些瑕疵甚至可以在很远的距离看到。在3D场景中，平面没有瑕疵，我们可以将纹理应用在它之上，但这不会改变光反射的方式。这就是为什么与现实有区别的原因。</p><p>我们可以考虑通过增加三角形数量来增加模型的细节并反映出这些瑕疵，但性能会下降。我们需要的是改变表面光反射的方式来增加真实感。这就是用法线贴图技术实现的。</p><p>让我们看看光滑平面的例子，一个平面由两个三角形组成为一个四边形。回忆之前的光照章节，模型的光反射的要素是平面法线。在此情况下，我们整个平面仅有单一的法线，当计算光如何影响片元时，每个片元都使用相同的法线。看起来就像下图那样。</p><p><img src="/2019/02/28/Lwjglbook-17-normal-mapping/surface_normals.png" alt="平面法线"></p><p>如果可以改变平面的每个片元的法线，我们就可以模拟平面的瑕疵，使它们更逼真。看起来就像下图那样。</p><p><img src="/2019/02/28/Lwjglbook-17-normal-mapping/fragment_normals.png" alt="片元法线"></p><p>要做到这一点，我们要加载另一个纹理，它储存面的法线。法线纹理的每个像素将以RGB值储存法线的<strong>x</strong>、<strong>y</strong>和<strong>z</strong>坐标值。</p><p>让我们用下面的纹理绘制一个四边形。</p><p><img src="/2019/02/28/Lwjglbook-17-normal-mapping/rock.png" alt="纹理"></p><p>上图的法线纹理如下所示。</p><p><img src="/2019/02/28/Lwjglbook-17-normal-mapping/rock_normals.png" alt="法线纹理"></p><p>如你所见，如果我们把颜色变换应用到原始纹理，每个像素使用颜色分量储存法线信息。在看到法线贴图时，你常常会看到主色调倾向于蓝色，这是由于大多数法线指向转换正<strong>z</strong>轴所致。在一个平面表面的矢量中，<strong>z</strong>分量通常比<strong>x</strong>和<strong>y</strong>分量的值高得多。由于<strong>x</strong>、<strong>y</strong>、<strong>z</strong>坐标被映射到RGB，导致蓝色分量也有着更高的值。</p><p>因此，使用法线贴图渲染对象只需要一个额外的纹理，并同时使用它渲染片元以获得适当的法线值。</p><p>让我们开始修改代码，以支持法线贴图。我们将添加一个新的<code>Texture</code>实例到<code>Material</code>类，这样就可以把一个法线贴图纹理添加到游戏项目上。此实例将有自己的<code>get</code>和<code>set</code>方法，并有方法可以检查<code>Material</code>是否有法线贴图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Material</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Vector4f DEFAULT_COLOUR = <span class="keyword">new</span> Vector3f(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">10</span>.f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f ambientColour;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f diffuseColour;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f specularColour;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> reflectance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture texture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Texture normalMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// … Previous code here</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNormalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.normalMap != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Texture <span class="title">getNormalMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> normalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNormalMap</span><span class="params">(Texture normalMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.normalMap = normalMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在场景的片元着色器中使用法线贴图纹理。但是，由于我们在观察坐标空间操作，所以需要通过模型观察矩阵来进行适当的变换。因此，我们需要修改场景的顶点着色器。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">mat4</span> outModelViewMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> mvPos = modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * mvPos;</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">    mvVertexNormal = <span class="built_in">normalize</span>(modelViewMatrix * <span class="type">vec4</span>(vertexNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">    mvVertexPos = mvPos.xyz;</span><br><span class="line">    outModelViewMatrix = modelViewMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在场景的片元着色器中，我们需要添加另一个输入参数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">mat4</span> outModelViewMatrix;</span><br></pre></td></tr></table></figure><p>在片元着色器中，我们需要为法线贴图纹理采样器传递一个新的Uniform：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br></pre></td></tr></table></figure><p>此外，在片元着色器中，我们将创建一个新函数，该函数计算当前片元的法线。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> calcNormal(Material material, <span class="type">vec3</span> normal, <span class="type">vec2</span> text_coord, <span class="type">mat4</span> modelViewMatrix)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> newNormal = normal;</span><br><span class="line">    <span class="keyword">if</span> ( material.hasNormalMap == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        newNormal = <span class="built_in">texture</span>(normalMap, text_coord).rgb;</span><br><span class="line">        newNormal = <span class="built_in">normalize</span>(newNormal * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        newNormal = <span class="built_in">normalize</span>(modelViewMatrix * <span class="type">vec4</span>(newNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数有以下参数：</p><ul><li><code>Material</code>实例。</li><li>顶点法线。</li><li>纹理坐标。</li><li>模型视图矩阵。</li></ul><p>我们在此函数中做的第一件事是检查这个<code>Material</code>实例是否有法线贴图。如果没有，我们就像平常一样简单地使用顶点法线。如果它有法线贴图，我们使用储存着法线数据的法线纹理关联到当前纹理坐标。</p><p>记住我们取得的颜色是法线坐标，但因为它们被储存为RGB值，所以它们的值在范围[0, 1]中。我们需要将其范围转换为[-1, 1]，所以我们将其乘以2然后减去1。然后，我们将它归一化，并将其转换到模型观察坐标系（就像顶点法线那样）。</p><p>就这样，我们可以使用返回值作为片元所有光照计算中的法线。</p><p>在<code>Renderer</code>类中，我们需要创建法线贴图，在<code>renderScene</code>方法中，我们做如下设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">sceneShaderProgram.setUniform(<span class="string">"fog"</span>, scene.getFog());</span><br><span class="line">sceneShaderProgram.setUniform(<span class="string">"texture_sampler"</span>, <span class="number">0</span>);</span><br><span class="line">sceneShaderProgram.setUniform(<span class="string">"normalMap"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>上述代码中你可能注意到一些有趣的事情。我们将材质纹理Uniform（<code>texture_sampler</code>）设置为<strong>0</strong>，然后将法线贴图纹理（<code>normalMap</code>）设置为<strong>1</strong>。如果你回想纹理章节，我们不止使用一个纹理，所以我们必须为每个单独的纹理设置纹理单元。</p><p>当我们渲染<code>Mesh</code>时，也需要考虑这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Texture texture = material.getTexture();</span><br><span class="line">    <span class="keyword">if</span> (texture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 激活第一纹理库</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    Texture normalMap = material.getNormalMap();</span><br><span class="line">    <span class="keyword">if</span> ( normalMap != <span class="keyword">null</span> ) &#123;</span><br><span class="line">        <span class="comment">// 激活第二纹理库</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, normalMap.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    glBindVertexArray(getVaoId());</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，我们需要绑定每个可用的纹理，并激活相关的纹理单元，以便多个纹理能够同时工作。在<code>Renderer</code>类的<code>renderScene</code>方法中，我们不需要显式设置纹理的Uniform，因为它已经包含在<code>Material</code>中。</p><p>为了展示法线贴图带来的提升，我已经创建了两个并排显示的四边形示例。右边的有一张法线贴图，而左边没有。我们还删除了地形、天空盒和HUD，并设置了平行光照，可以用鼠标左右键改变方向，这样你就可以看到效果了。我已经修改了基本源代码，以支持关闭天空盒和地形。我们还在片元着色器中设置了光效果的范围为[0, 1]，以避免图像过度曝光。</p><p>结果如下图所示。</p><p><img src="/2019/02/28/Lwjglbook-17-normal-mapping/normal_mapping_result.png" alt="法线贴图结果"></p><p>如你所见，具有法线贴图的四边形感觉更大。虽然它本质上是一个像其他四边形一样的平面，但你可以看到光线是如何反射的。</p><p>尽管我们已经编写的代码完全符合这个示例，但你需要知道它的局限性。该代码仅适用与使用模型坐标空间创建的法线贴图纹理。如果是这种情况，我们可以使用模型视图矩阵来将法线坐标转换到观察空间。</p><p>但通常法线贴图不是这样定义的。它们通常被定义在所谓的<strong>切线空间（<code>Tangent Space</code>）</strong>中。切线空间是一个坐标系，它定位在模型的每个三角形，其坐标系的<strong>z</strong>轴总是垂直于表面。这就是为什么当你看一个法线贴图时，它通常是蓝色的，甚至对于面相对复杂的模型也是如此。</p><p>我们现在仍使用这个简单的实现，但请记住，你必须总是使用在模型空间中定义的法线贴图。如果使用切线空间中定义的贴图，就会变得很奇怪。为了能够让它们一同工作，我们需要使用特定的矩阵来将坐标变换到切线空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter17&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十六章 雾</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-16-fog/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-16-fog/</id>
    <published>2019-02-07T09:21:05.000Z</published>
    <updated>2019-02-27T14:42:51.590Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter16" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter16</a></p><p>英文标题：Fog</p></blockquote><p>在处理更复杂的问题之前，我们将学习如何在游戏引擎中创建雾特效。有了这个特效，就可以模拟遥远的物体变暗，似乎消失在浓雾中。</p><p>让我们来确定定义雾的属性是什么。第一个是雾的颜色。在现实世界中，雾是灰色的，但我们可以利用这个特效来模拟不同颜色的雾覆盖的区域。还有一个属性是雾的浓度。</p><p>因此，为了使用雾特效，我们需要找到一种方法，当3D场景的物体远离摄像机时，使它们褪色到雾的颜色。靠近摄像机的物体不会受到雾的影响，但远处的物体将无法分辨。因此，我们需要计算一个参数，可以用来混合雾的颜色与每个片元的颜色，以模拟雾特效。这个参数取决于与摄像机相距的距离。</p><p>让我们把这个参数命名为<code>fogFactor</code>，并设定它的范围为0到1。当<code>fogFactor</code>为1时，意味着物体完全不会受到雾的影响，也就是说，它是较近的物体。当<code>fogFactor</code>为0时，意味着物体完全隐藏在雾中。</p><p>然后，计算雾色的方程如下：</p><script type="math/tex; mode=display">finalColour = (1 - fogFactor) \cdot fogColour + fogFactor \cdot framentColour</script><ul><li><strong>finalColour</strong> 是使用雾特效的最终颜色。</li><li><strong>fogFactor</strong> 是控制雾的颜色与片元的颜色如何混合的参数，它基本上控制物体的可见性。</li><li><strong>fogColour</strong> 是雾的颜色。</li><li><strong>fragmentColour</strong> 没有使用雾特效的片元颜色。</li></ul><p>现在我们需要找到一种方法来基于距离计算<strong>fogFactor</strong>。我们可以选择不同的模型，首先使用线性模型。这是一个给定距离以线性方式改变<strong>fogFactor</strong>的模型。</p><p>线性模型由以下参数定义：</p><ul><li><strong>fogStart</strong>: 开始使用雾特效的距离。</li><li><strong>fogFinish</strong>: 雾特效达到最大值的距离。</li><li><strong>distance</strong>: 到摄像机的距离。</li></ul><p>有了这些参数，方程就会是这样的：</p><script type="math/tex; mode=display">\displaystyle fogFactor = \frac{(fogFinish - distance)}{(fogFinish - fogStart)}</script><p>对于距离低于<strong>fogStart</strong>的物体我们简单地设置<strong>fogFactor</strong>为<strong>1</strong>。下图表明了<strong>fogFactor</strong>是如何随着距离变化而变化的。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/linear_model.png" alt="线性模型"></p><p>线性模型易于计算，但不太真实，因为它不考虑雾气浓度。实际上雾往往以更平滑的方式增加。所以下一个合适的模型是指数模型。该模型的方程如下：</p><script type="math/tex; mode=display">\displaystyle focFactor = e^{-(distance \cdot fogDensity)^{exponent}} = \frac{1}{e^{(distance \cdot fogDensity)^{exponent}}}</script><p>其中的新变量如下所述：</p><ul><li><strong>fogDensity</strong> 是雾的厚度或浓度。</li><li><strong>exponent</strong> 用来控制雾随着距离的增加增长的速度。</li></ul><p>下图显示了两个图形，分别设置了不同的<strong>exponent</strong>值（蓝线为<strong>2</strong>，红线为<strong>4</strong>）。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/exponential_model.png" alt="指数模型"></p><p>在代码中，我们将使用一个公式，让它可以为<strong>exponent</strong>设置不同的值（你可以很容易地修改示例以使用不同的值）。</p><p>既然已经解释过这个原理了，我们就可以实现它。我们将在场景的片元着色器中实现雾特效，因为这有我们需要的所有变量。我们将首先定义一个储存雾属性的结构体。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Fog</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> active;</span><br><span class="line">    <span class="type">vec3</span> colour;</span><br><span class="line">    <span class="type">float</span> density;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>active</code>属性用于激活或关闭雾特效。雾属性将通过另一个被称作<code>fog</code>的Uniform传递给着色器。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> Fog fog;</span><br></pre></td></tr></table></figure><p>我们还将创建一个包含着雾属性的名为<code>Fog</code>的新类，它是另一个POJO（Plain Ordinary Java Object，简单的Java对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph.weather;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector3f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> active;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f colour;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> density;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fog NOFOG = <span class="keyword">new</span> Fog();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.colour = <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.density = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fog</span><span class="params">(<span class="keyword">boolean</span> active, Vector3f colour, <span class="keyword">float</span> density)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colour = colour;</span><br><span class="line">        <span class="keyword">this</span>.density = density;</span><br><span class="line">        <span class="keyword">this</span>.active = active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Getters and setters here….</span></span><br></pre></td></tr></table></figure><p>我们将在<code>Scene</code>类中添加一个<code>Fog</code>示例。默认情况下，<code>Scene</code>类将初始化一个<code>Fog</code>示例到常量<code>NOFOG</code>，用于模拟关闭雾特效的情况。</p><p>因为添加了一个新的Uniform类型，所以我们需要修改<code>ShaderProgram</code>类来创建和初始化雾的Uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFogUniform</span><span class="params">(String uniformName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    createUniform(uniformName + <span class="string">".active"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".colour"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".density"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, Fog fog)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">".activeFog"</span>, fog.isActive() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    setUniform(uniformName + <span class="string">".colour"</span>, fog.getColour() );</span><br><span class="line">    setUniform(uniformName + <span class="string">".density"</span>, fog.getDensity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Renderer</code>类中，我们只需要在<code>setupSceneShader</code>方法中创建Uniform：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneShaderProgram.createFogUniform(<span class="string">"fog"</span>);</span><br></pre></td></tr></table></figure><p>然后在<code>renderScene</code>方法中使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneShaderProgram.setUniform(<span class="string">"fog"</span>, scene.getFog());</span><br></pre></td></tr></table></figure><p>我们现在可以在游戏中定义雾特效，但是需要回到片元着色器中应用雾特效。我们将创建一个名为<code>calcFog</code>的函数，函数定义如下。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcFog(<span class="type">vec3</span> pos, <span class="type">vec4</span> colour, Fog fog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(pos);</span><br><span class="line">    <span class="type">float</span> fogFactor = <span class="number">1.0</span> / <span class="built_in">exp</span>( (<span class="built_in">distance</span> * fog.density)* (<span class="built_in">distance</span> * fog.density));</span><br><span class="line">    fogFactor = <span class="built_in">clamp</span>( fogFactor, <span class="number">0.0</span>, <span class="number">1.0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> resultColour = <span class="built_in">mix</span>(fog.colour, colour.xyz, fogFactor);</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(resultColour.xyz, colour.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，我们首先计算到顶点的距离。顶点坐标定义在<code>pos</code>变量中，我们只需要计算长度。然后利用<strong>exponent</strong>为2的指数模型（相当于乘以两次）计算雾参数。我们得到的<code>fogFactor</code>的范围在<strong>0</strong>到<strong>1</strong>之间，并使用<code>mix</code>函数。在GLSL中，<code>min</code>函数被用于混合雾色和图元颜色（由颜色变量定义）。相当于使用如下方程：</p><script type="math/tex; mode=display">resultColour = (1 - fogFactor) \cdot fog.colour + fogFactor \cdot colour</script><p>我们还为颜色保留了<strong>w</strong>元素，即透明度。我们不希望这个元素受到影响，片元应该保持它的透明程度不变。</p><p>在应用了所有的光效之后，在片元着色器的最后，如果雾特效启用的话，我们将简单地把返回值设置为片元颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( fog.activeFog == <span class="number">1</span> ) </span><br><span class="line">&#123;</span><br><span class="line">    fragColor = calcFog(mvVertexPos, fragColor, fog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这些代码完成后，我们可以用下面的数据设置一个雾特效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.setFog(<span class="keyword">new</span> Fog(<span class="keyword">true</span>, <span class="keyword">new</span> Vector3f(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>), <span class="number">0.15f</span>));</span><br></pre></td></tr></table></figure><p>然后我们将获得像这样的效果：</p><p><img src="/2019/02/07/Lwjglbook-16-fog/fog_effect.png" alt="雾特效"></p><p>你会看到远处的物体褪色，当你靠近它们时，雾开始消失。但有一个问题，天空盒看起来有点奇怪，地平线不受雾的影响。有几种方法可以解决这个问题：</p><ul><li>使用只能看到天空的另一个不同的天空盒。</li><li>删除天空盒，因为有浓雾，你不应该能够看到一个背景。</li></ul><p>也可能这两个解决方案没有适合你的，你可以试着将雾色与天空盒的背景相匹配，但这样你会做复杂的计算，结果也许不会更好。</p><p>如果你运行这个示例，你会感到平行光变得暗淡，场景变暗，但雾看起来有问题，因为它不受光的影响，会看到如下图所示的结果。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/glowing_fog.png" alt="发光的雾"></p><p>远处的物体变为雾色，这是一个不受光影响的常数。这造成了一个在黑暗中发光的效果（这可能并不好）。我们需要修改计算雾的函数，让其考虑光照。该函数将接收环境光和平行光来调整雾色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcFog(<span class="type">vec3</span> pos, <span class="type">vec4</span> colour, Fog fog, <span class="type">vec3</span> ambientLight, DirectionalLight dirLight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> fogColor = fog.colour * (ambientLight + dirLight.colour * dirLight.intensity);</span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(pos);</span><br><span class="line">    <span class="type">float</span> fogFactor = <span class="number">1.0</span> / <span class="built_in">exp</span>( (<span class="built_in">distance</span> * fog.density)* (<span class="built_in">distance</span> * fog.density));</span><br><span class="line">    fogFactor = <span class="built_in">clamp</span>( fogFactor, <span class="number">0.0</span>, <span class="number">1.0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> resultColour = <span class="built_in">mix</span>(fogColor, colour.xyz, fogFactor);</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(resultColour.xyz, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，平行光我们仅使用了颜色和强度，我们不需要关注它的方向。这样，我们只需要稍微修改函数的调用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( fog.active == <span class="number">1</span> ) </span><br><span class="line">&#123;</span><br><span class="line">    fragColor = calcFog(mvVertexPos, fragColor, fog, ambientLight, directionalLight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在夜晚时，我们会看到这样的效果。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/fog_at_night.png" alt="夜晚的雾"></p><p>一个要强调的重要的事情是，我们必须聪明地选择雾色。这是很重要的，当我们没有天空盒，但有固定的颜色背景，应该把雾色设置为背景色。如果你删除了天空盒的代码并重新运行示例代码，你会得到这样的结果。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/fog_clear_colour_black.png" alt="黑色背景"></p><p>但如果我们把背景色修改为（0.5, 0.5, 0.5），最终结果看起来就是如下所示。</p><p><img src="/2019/02/07/Lwjglbook-16-fog/fog_clear_colour_grey.png" alt="雾灰色背景"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter16&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十五章 地形碰撞</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-15-terrain-collisions/</id>
    <published>2019-02-07T09:20:57.000Z</published>
    <updated>2019-02-27T14:42:51.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter15" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter15</a></p><p>英文标题：Terrain Collisions</p></blockquote><p>此前我们创建了一个地形，接下来就是检测碰撞以避免穿过它。回忆一下之前的内容，一个地形是由地形块组成的，每个地形块都是由高度图生成的，高度图用于设置构成地形的三角形的顶点高度。</p><p>为了检测碰撞，我们必须将当前所在位置的<strong>Y</strong>值与当前地形点的<strong>Y</strong>值进行比较。如果有碰撞，我们需要回到地形上方。很简单的想法，是吗？确实是这样，但在比较之前，我们需要进行几次计算。</p><p>我们首先要定义的是我们对“当前位置”这个词的理解。由于我们还没有一个球员的概念，答案很简单，当前的位置将是相机的位置。因此，我们已经有了比较的组成部分之一，因此，接下来要计算的是当前位置的地形高度。<br>首先要定义的是“当前位置”这个词的概念。由于我们还没有一个“玩家”的概念，因此当前位置将是摄像机的位置。这样我们就有了比较的一方，因此接下来要计算当前位置的地形高度。</p><p>如上所是，地形由地形块组成，如下图所示。</p><p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_grid.png" alt="地形网格"></p><p>每个地形块都是由相同的高度图网格构成，但被精确地缩放和位移，以形成看起来像是连续的景观的地形网格。</p><p>所以首先要做的是确定当前位置(摄像机位置)在哪个地形块。为了得到它，我们将基于位移和缩放来计算每个地形块的包围盒(<strong>BoundingBox</strong>)。因为地形在运行时不会移动或缩放，所以我们可以在<code>Terrain</code>类的构造方法中计算。这样就可以在任何时候访问它们，而不需要在每个游戏循环周期中重复这些计算。</p><p>我们将创建一个新的方法来计算一个地形块的包围盒，名为<code>getBoundingBox</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Box2D <span class="title">getBoundingBox</span><span class="params">(GameItem terrainBlock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> scale = terrainBlock.getScale();</span><br><span class="line">    Vector3f position = terrainBlock.getPosition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topLeftX = HeightMapMesh.STARTX * scale + position.x;</span><br><span class="line">    <span class="keyword">float</span> topLeftZ = HeightMapMesh.STARTZ * scale + position.z;</span><br><span class="line">    <span class="keyword">float</span> width = Math.abs(HeightMapMesh.STARTX * <span class="number">2</span>) * scale;</span><br><span class="line">    <span class="keyword">float</span> height = Math.abs(HeightMapMesh.STARTZ * <span class="number">2</span>) * scale;</span><br><span class="line">    Box2D boundingBox = <span class="keyword">new</span> Box2D(topLeftX, topLeftZ, width, height);</span><br><span class="line">    <span class="keyword">return</span> boundingBox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Box2D</code>是<code>java.awt.Rectangle2D.Float</code>类的简化版本，为了避免使用AWT而创建。</p><p>限制我们需要计算地形块的世界坐标。在上一章中，你看到所有的地形网格都是在一个正方形中创建的，它的原点设置为<code>[STARTX, STARTZ]</code>。因此，我们需要把这些坐标转换为世界坐标，这要考虑下图所示的位移与缩放。</p><p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/model_to_world_coordinates.png" alt="模型坐标系到世界坐标系"></p><p>如上所述，这可以在<code>Terrain</code>类构造方法中计算，因为它不会在运行时发生变化，所以我们要添加一个新的属性来保存包围盒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Box2D[][] boundingBoxes;</span><br></pre></td></tr></table></figure><p>在<code>Terrain</code>类的构造方法中，当我们创建地形块时，只需调用计算包围盒的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Terrain</span><span class="params">(<span class="keyword">int</span> terrainSize, <span class="keyword">float</span> scale, <span class="keyword">float</span> minY, <span class="keyword">float</span> maxY, String heightMapFile, String textureFile, <span class="keyword">int</span> textInc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.terrainSize = terrainSize;</span><br><span class="line">    gameItems = <span class="keyword">new</span> GameItem[terrainSize * terrainSize];</span><br><span class="line"></span><br><span class="line">    PNGDecoder decoder = <span class="keyword">new</span> PNGDecoder(getClass().getResourceAsStream(heightMapFile));</span><br><span class="line">    <span class="keyword">int</span> height = decoder.getHeight();</span><br><span class="line">    <span class="keyword">int</span> width = decoder.getWidth();</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocateDirect(</span><br><span class="line">            <span class="number">4</span> * decoder.getWidth() * decoder.getHeight());</span><br><span class="line">    decoder.decode(buf, decoder.getWidth() * <span class="number">4</span>, PNGDecoder.Format.RGBA);</span><br><span class="line">    buf.flip();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每行与每列的顶点数</span></span><br><span class="line">    verticesPerCol = heightMapImage.getWidth();</span><br><span class="line">    verticesPerRow = heightMapImage.getHeight();</span><br><span class="line"></span><br><span class="line">    heightMapMesh = <span class="keyword">new</span> HeightMapMesh(minY, maxY, buf, width, textureFile, textInc);</span><br><span class="line">    boundingBoxes = <span class="keyword">new</span> Box2D[terrainSize][terrainSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; terrainSize; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; terrainSize; col++) &#123;</span><br><span class="line">            <span class="keyword">float</span> xDisplacement = (col - ((<span class="keyword">float</span>) terrainSize - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getXLength();</span><br><span class="line">            <span class="keyword">float</span> zDisplacement = (row - ((<span class="keyword">float</span>) terrainSize - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getZLength();</span><br><span class="line"></span><br><span class="line">            GameItem terrainBlock = <span class="keyword">new</span> GameItem(heightMapMesh.getMesh());</span><br><span class="line">            terrainBlock.setScale(scale);</span><br><span class="line">            terrainBlock.setPosition(xDisplacement, <span class="number">0</span>, zDisplacement);</span><br><span class="line">            gameItems[row * terrainSize + col] = terrainBlock;</span><br><span class="line"></span><br><span class="line">            boundingBoxes[row][col] = getBoundingBox(terrainBlock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，有了所有预先计算的包围盒，我们将创建一个新的方法，这个方法将以当前位置为参数，返回对应地形高度。该方法名为<code>getHeight</code>，其定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHeight</span><span class="params">(Vector3f position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> result = Float.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 对于每个地形块，我们获取包围盒，将其转换到观察坐标系</span></span><br><span class="line">    <span class="comment">// 检查坐标是否包含在包围盒中</span></span><br><span class="line">    Box2D boundingBox = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    GameItem terrainBlock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; terrainSize &amp;&amp; !found; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; terrainSize &amp;&amp; !found; col++) &#123;</span><br><span class="line">            terrainBlock = gameItems[row * terrainSize + col];</span><br><span class="line">            boundingBox = boundingBoxes[row][col];</span><br><span class="line">            found = boundingBox.contains(position.x, position.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们找到了一个包含我们位置的地形块</span></span><br><span class="line">    <span class="comment">// 计算该位置的地形高度</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        Vector3f[] triangle = getTriangle(position, boundingBox, terrainBlock);</span><br><span class="line">        result = interpolateHeight(triangle[<span class="number">0</span>], triangle[<span class="number">1</span>], triangle[<span class="number">2</span>], position.x, position.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此方法中第一件事是确定我们所在的地形块。由于我们已经有了每个地形块的包围盒，所以算法很简单。我们只需要迭代包围盒数组，并检查当前位置是否位于其中(<code>Box2D</code>提供了该方法)。</p><p>一旦找到了地形块，我们需要计算所处的三角形，这是由之后的<code>getTriangle</code>方法计算的。之后，我们得到了所在三角形的坐标，包括它的高度。但是，我们需要的是一个点的高度，这个点不位于这些顶点中的任何一点，而位于它们之间的位置。这将在<code>interpolateHeight</code>方法中计算，我们也将解释这是如何计算的。</p><p>让我们先从确定所处的三角形开始。构成地形块的正方形可以看作一个网格，其中每个单元由两个三角形组成。首先我们定义一些变量：</p><ul><li><strong>boundingBox.x</strong>是与包围盒相关联的地形块的原<strong>x</strong>坐标。</li><li><strong>boundingBox.y</strong>是与包围盒相关联的地形块的原<strong>z</strong>坐标(即使你看到一个<strong>y</strong>，但它是在<strong>z</strong>轴的)。</li><li><strong>boundingBox.width</strong>是地形块正方形的宽度。</li><li><strong>boundingBox.height</strong>是地形块正方形的高度。</li><li><strong>cellWidth</strong>是一个单元的宽度。</li><li><strong>cellHeight</strong>是一个单元的高度。</li></ul><p>上面定义的所有变量都用世界坐标来表示。为了计算单元的宽度，我们只需要将包围盒宽度除以每列的顶点数：</p><script type="math/tex; mode=display">cellWidth = \frac{boundingBox.width}{verticesPerCol}</script><p><code>cellHeight</code>的计算也相似：</p><script type="math/tex; mode=display">cellHeight = \frac{boundingBox.height}{verticesPerRow}</script><p>一旦有了这些变量，我们就可以计算所在的单元格的行和列了：</p><script type="math/tex; mode=display">col = \frac{position.x - boundingBox.x}{boundingBox.width}</script><script type="math/tex; mode=display">row = \frac{position.z - boundingBox.y}{boundingBox.height}</script><p>下图在示例地形块展示了此前描述的所有变量。</p><p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/terrain_block_variables_n.png" alt="地形块变量"></p><p>有了这些信息，就可以计算单元格中包含的三角形顶点的位置。我们怎么才能做到呢？让我们来看看组成一个单元格的三角形。</p><p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/cell.png" alt="单元格"></p><p>你可以看到，单元格是被一个对角线分开为两个三角形的。确定与当前位置相关的三角形的方法，是检查<strong>z</strong>坐标在对角线的上方还是下方。在本例中，将对角线的<strong>x</strong>值设置为当前位置的<strong>x</strong>值，求出对应的对角线<strong>z</strong>值，如果当前位置的<strong>z</strong>值小于对角线的<strong>z</strong>值，那么我们在<strong>T1</strong>中。反之如果当前位置的<strong>z</strong>值大于对角线的<strong>z</strong>值，我们就在<strong>T2</strong>中。</p><p>我们可以通过计算与对角线相匹配的直线方程来确定。</p><p>如果你还记得学校的数学课，从两点通过的直线(在二维中)的方程为:</p><script type="math/tex; mode=display">y-y1=m\cdot(x-x1)</script><p>其中m是直线的斜率，也就是说，当沿<strong>x</strong>轴移动时，其高度会发生变化。请注意，在本例中，<strong>y</strong>坐标其实是一个<strong>z</strong>。还要注意的是，我们使用的是二维坐标，因为在这里不计算高度，只要<strong>x</strong>坐标和<strong>z</strong>坐标就足够了。因此，在本例中，直线方程应该是这样。</p><script type="math/tex; mode=display">z-z1=m\cdot(x-x1)</script><p>斜率可以按如下方式计算：</p><script type="math/tex; mode=display">m=\frac{z1-z2}{x1-x2}</script><p>所以给定一个<strong>x</strong>坐标得到一个<strong>z</strong>值的对角线方程就像这样：</p><script type="math/tex; mode=display">z=m\cdot(xpos-x1)+z1=\frac{z1-z2}{x1-x2}\cdot(zpos-x1)+z1</script><p>其中<strong>x1</strong>、<strong>x2</strong>、<strong>z1</strong>和<strong>z2</strong>分别是顶点<strong>V1</strong>和<strong>V2</strong>的<strong>x</strong>和<strong>z</strong>坐标。</p><p>因此，通过上述方式来获得当前位置所在的三角形的方法，名为<code>getTriangle</code>，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Vector3f[] getTriangle(Vector3f position, Box2D boundingBox, GameItem terrainBlock) &#123;</span><br><span class="line">    <span class="comment">// 获得与当前位置相关的高度图的行列</span></span><br><span class="line">    <span class="keyword">float</span> cellWidth = boundingBox.width / (<span class="keyword">float</span>) verticesPerCol;</span><br><span class="line">    <span class="keyword">float</span> cellHeight = boundingBox.height / (<span class="keyword">float</span>) verticesPerRow;</span><br><span class="line">    <span class="keyword">int</span> col = (<span class="keyword">int</span>) ((position.x - boundingBox.x) / cellWidth);</span><br><span class="line">    <span class="keyword">int</span> row = (<span class="keyword">int</span>) ((position.z - boundingBox.y) / cellHeight);</span><br><span class="line"></span><br><span class="line">    Vector3f[] triangle = <span class="keyword">new</span> Vector3f[<span class="number">3</span>];</span><br><span class="line">    triangle[<span class="number">1</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">        boundingBox.x + col * cellWidth,</span><br><span class="line">        getWorldHeight(row + <span class="number">1</span>, col, terrainBlock),</span><br><span class="line">        boundingBox.y + (row + <span class="number">1</span>) * cellHeight);</span><br><span class="line">    triangle[<span class="number">2</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">        boundingBox.x + (col + <span class="number">1</span>) * cellWidth,</span><br><span class="line">        getWorldHeight(row, col + <span class="number">1</span>, terrainBlock),</span><br><span class="line">        boundingBox.y + row * cellHeight);</span><br><span class="line">    <span class="keyword">if</span> (position.z &lt; getDiagonalZCoord(triangle[<span class="number">1</span>].x, triangle[<span class="number">1</span>].z, triangle[<span class="number">2</span>].x, triangle[<span class="number">2</span>].z, position.x)) &#123;</span><br><span class="line">        triangle[<span class="number">0</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">            boundingBox.x + col * cellWidth,</span><br><span class="line">            getWorldHeight(row, col, terrainBlock),</span><br><span class="line">            boundingBox.y + row * cellHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        triangle[<span class="number">0</span>] = <span class="keyword">new</span> Vector3f(</span><br><span class="line">            boundingBox.x + (col + <span class="number">1</span>) * cellWidth,</span><br><span class="line">            getWorldHeight(row + <span class="number">2</span>, col + <span class="number">1</span>, terrainBlock),</span><br><span class="line">            boundingBox.y + (row + <span class="number">1</span>) * cellHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> triangle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getDiagonalZCoord</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> z1, <span class="keyword">float</span> x2, <span class="keyword">float</span> z2, <span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> z = ((z1 - z2) / (x1 - x2)) * (x - x1) + z1;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getWorldHeight</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, GameItem gameItem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> y = heightMapMesh.getHeight(row, col);</span><br><span class="line">    <span class="keyword">return</span> y * gameItem.getScale() + gameItem.getPosition().y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到我们有另外两个反复。第一个名为<code>getDiagonalZCoord</code>，给定<strong>x</strong>位置和两个顶点计算对角线的<strong>z</strong>坐标。另一个名为<code>getWorldHeight</code>，用来获得三角形顶点的高度(即<strong>y</strong>坐标)。当地形网格被创建时，每个顶点的高度都被预先计算和储存，我们只需将其转换为世界坐标。</p><p>好，我们有当前位置的三角形坐标。最后，我们准备在当前位置计算地形高度。怎么做呢？我们的三角形在一个平面上，一个平面可以由三个点定义，在本例中，三个顶点定义了一个三角形。</p><p>平面方程如下：</p><script type="math/tex; mode=display">a\cdot x+b\cdot y+c\cdot z+d=0</script><p>上述方程的常数值是：</p><script type="math/tex; mode=display">a=(B_{y}-A_{y}) \cdot (C_{z} - A_{z}) - (C_{y} - A_{y}) \cdot (B_{z}-A_{z})</script><script type="math/tex; mode=display">b=(B_{z}-A_{z}) \cdot (C_{x} - A_{x}) - (C_{z} - A_{z}) \cdot (B_{z}-A_{z})</script><script type="math/tex; mode=display">c=(B_{x}-A_{x}) \cdot (C_{y} - A_{y}) - (C_{x} - A_{x}) \cdot (B_{y}-A_{y})</script><p>其中<strong>A</strong>、<strong>B</strong>和<strong>C</strong>是定义平面所需的三个顶点。</p><p>然后，利用之前的方程以及当前位置的<strong>x</strong>和<strong>z</strong>坐标值，我们能够计算<strong>y</strong>值，即当前位置的地形高度：</p><script type="math/tex; mode=display">y = (-d - a \cdot x - c \cdot z) / b</script><p>实现了如上运算的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">interpolateHeight</span><span class="params">(Vector3f pA, Vector3f pB, Vector3f pC, <span class="keyword">float</span> x, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平面方程 ax+by+cz+d=0</span></span><br><span class="line">    <span class="keyword">float</span> a = (pB.y - pA.y) * (pC.z - pA.z) - (pC.y - pA.y) * (pB.z - pA.z);</span><br><span class="line">    <span class="keyword">float</span> b = (pB.z - pA.z) * (pC.x - pA.x) - (pC.z - pA.z) * (pB.x - pA.x);</span><br><span class="line">    <span class="keyword">float</span> c = (pB.x - pA.x) * (pC.y - pA.y) - (pC.x - pA.x) * (pB.y - pA.y);</span><br><span class="line">    <span class="keyword">float</span> d = -(a * pA.x + b * pA.y + c * pA.z);</span><br><span class="line">    <span class="comment">// y = (-d -ax -cz) / b</span></span><br><span class="line">    <span class="keyword">float</span> y = (-d - a * x - c * z) / b;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完了！现在我们能够检测碰撞，所以在<code>DummyGame</code>类中，在更新摄像机位置时，修改如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新摄像机位置</span></span><br><span class="line">Vector3f prevPos = <span class="keyword">new</span> Vector3f(camera.getPosition());</span><br><span class="line">camera.movePosition(cameraInc.x * CAMERA_POS_STEP, cameraInc.y * CAMERA_POS_STEP, cameraInc.z * CAMERA_POS_STEP);        </span><br><span class="line"><span class="comment">// 检查是否发生碰撞。如果为true，将y坐标设置为</span></span><br><span class="line"><span class="comment">// 最大高度</span></span><br><span class="line"><span class="keyword">float</span> height = terrain.getHeight(camera.getPosition());</span><br><span class="line"><span class="keyword">if</span> ( camera.getPosition().y &lt;= height )  &#123;</span><br><span class="line">    camera.setPosition(prevPos.x, prevPos.y, prevPos.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，检测地形碰撞的概念很容易理解，但是我们需要仔细地进行计算并了解正处理的不同坐标系。</p><p>此外，虽然这里给出的算法在大多数情况下都是可用的，但仍存在需要仔细处理的情况。你可以发现的一个问题是隧道效应(<code>Tunnelling</code>)。设想一个情况，我们正以高速穿过地形，正因如此，位置增量值较高。这个值变得如此之高，以至于因为我们检测的是最终位置的碰撞，所以可能已经穿过了位于两点之间的障碍。</p><p><img src="/2019/02/07/Lwjglbook-15-terrain-collisions/tunnelling.png" alt="隧道效应"></p><p>有许多可行的解决方案可以避免这个效应，最简单的解决方法是将要进行的计算分成增量较小的多份。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十四章 高度图</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-14-height-maps/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-14-height-maps/</id>
    <published>2019-02-07T09:20:51.000Z</published>
    <updated>2019-02-27T14:42:51.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter14" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter14</a></p><p>英文标题：Height Maps</p></blockquote><p>本章中我们将学习如何使用高度图创建复杂的地形。在开始前，你会注意到我们做了一些重构。我们创建了一些新的包和移动了一些类以更好地组织它们。你可以在源代码中了解这些改变。</p><p>所以什么是高度图？高度图是用于生成三维地形的图像，它使用像素颜色来获取表面高度。高度图图像通常是灰度图，它可以由<a href="http://planetside.co.uk/" target="_blank" rel="noopener">Terragen</a>等软件生成。一张高度图图像看起来就像这样。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap.png" alt="高度图"> </p><p>上图就像你俯视一片陆地一样。利用上图，我们将构建由顶点组成的三角形所组成的网格。每个顶点的高度将根据图像的每个像素的颜色来计算。黑色是最低，白色是最高。</p><p>我们将为图像的每个像素创建一组顶点，这些顶点将组成三角形，这些三角形将组成下图所示的网格。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap_grid.png" alt="高度图网格"> </p><p>网格将组成一个巨大的四边形，它将会在X和Z轴上渲染，并根据像素颜色来改变它的Y轴高度。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap_coordinates.png" alt="高度图坐标系"> </p><p>由高度图创建三维地形的过程可概括为以下步骤：</p><ul><li>加载储存高度图的图像(我们将使用一个<code>BufferedImage</code>实例以获取每个像素)。</li><li>为每个图像像素创建一个顶点，其高度基于像素颜色。</li><li>将正确的纹理坐标分配给顶点。</li><li>设置索引以绘制与顶点相关的三角形。</li></ul><p>我们将创建一个名为<code>HeightMapMesh</code>的类，该类将基于高度图按以上步骤创建一个<code>Mesh</code>。让我们先看看该类定义的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COLOUR = <span class="number">255</span> * <span class="number">255</span> * <span class="number">255</span>;</span><br></pre></td></tr></table></figure><p>如上所述，我们将基于高度图图像的每个像素的颜色来计算每个顶点的高度。图像通常是灰度图，对于PNG图像来说，这意味着每个像素的每个RGB值可以在0到255之间变化，因此我们有256个值来表示不同的高度。这可能足够了，但如果精度不够，我们可以使用三个RGB值以有更多的值，在此情况下，高度计算范围为0到255^3。我们将使用第二种方法，因此我们不局限于灰度图。</p><p>接下来的常量是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> STARTX = -<span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> STARTZ = -<span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure><p>网格将由一组顶点（一个顶点对应一个像素）构成，其X和Z坐标的范围如下</p><ul><li>X轴的范围为[-0.5, 0.5]，即[<code>STARTX</code>, <code>-STARTX</code>]。</li><li>Z轴的范围为[-0.5, 0.5]，即[<code>STARTZ</code>, <code>-STARTZ</code>]。</li></ul><p>不用太过担心这些值，稍后得到的网格可以被缩放以适应世界的大小。关于Y轴，我们将设置<code>minY</code>和<code>maxY</code>两个参数，用于设置Y坐标的最低和最高值。这些参数并不是常数，因为我们可能希望在运行时更改它们，而不使用缩放。最后，地形将包含在范围为<code>[STARTX, -STARTX]</code>，<code>[minY, maxY]</code>，<code>[STARTZ, -STARTZ]</code>的立方体内。</p><p>网格将会在<code>HeightMapMesh</code>类的构造函数中创建，该类的定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeightMapMesh</span><span class="params">(<span class="keyword">float</span> minY, <span class="keyword">float</span> maxY, String heightMapFile, String textureFile, <span class="keyword">int</span> textInc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br></pre></td></tr></table></figure><p>它接收Y轴的最小值和最大值，被用作高度图的图像文件名和要使用的纹理文件名。它还接受一个名为<code>textInc</code>的整数，这稍后再说明。</p><p>我们在构造函数中做的第一件事就是将高度图图像加载到<code>BufferedImage</code>实例中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.minY = minY;</span><br><span class="line"><span class="keyword">this</span>.maxY = maxY;</span><br><span class="line"></span><br><span class="line">PNGDecoder decoder = <span class="keyword">new</span> PNGDecoder(getClass().getResourceAsStream(heightMapFile));</span><br><span class="line"><span class="keyword">int</span> height = decoder.getHeight();</span><br><span class="line"><span class="keyword">int</span> width = decoder.getWidth();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(</span><br><span class="line">        <span class="number">4</span> * decoder.getWidth() * decoder.getHeight());</span><br><span class="line">decoder.decode(buf, decoder.getWidth() * <span class="number">4</span>, PNGDecoder.Format.RGBA);</span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure><p>然后，我们将纹理文件载入到一个<code>ByteBuffer</code>中，并设置构造<code>Mesh</code>所需的变量。<code>incx</code>和<code>incz</code>变量将储存每个顶点的X或Z坐标之间的最小间隔，因此<code>Mesh</code>包含在上述区域中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Texture texture = <span class="keyword">new</span> Texture(textureFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> incx = getWidth() / (width - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">float</span> incz = Math.abs(STARTZ * <span class="number">2</span>) / (height - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Float&gt; positions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List&lt;Float&gt; textCoords = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List&lt;Integer&gt; indices = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>之后，我们将遍历图像，为每个像素创建一个顶点，设置其纹理坐标与索引，以正确地定义组成<code>Mesh</code>的三角形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">        <span class="comment">// 为当前位置创建顶点</span></span><br><span class="line">        positions.add(STARTX + col * incx); <span class="comment">// x</span></span><br><span class="line">        positions.add(getHeight(col, row, width, buf)); <span class="comment">// y</span></span><br><span class="line">        positions.add(STARTZ + row * incz); <span class="comment">// z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置纹理坐标</span></span><br><span class="line">        textCoords.add((<span class="keyword">float</span>) textInc * (<span class="keyword">float</span>) col / (<span class="keyword">float</span>) width);</span><br><span class="line">        textCoords.add((<span class="keyword">float</span>) textInc * (<span class="keyword">float</span>) row / (<span class="keyword">float</span>) height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建索引</span></span><br><span class="line">        <span class="keyword">if</span> (col &lt; width - <span class="number">1</span> &amp;&amp; row &lt; height - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftTop = row * width + col;</span><br><span class="line">            <span class="keyword">int</span> leftBottom = (row + <span class="number">1</span>) * width + col;</span><br><span class="line">            <span class="keyword">int</span> rightBottom = (row + <span class="number">1</span>) * width + col + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightTop = row * width + col + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            indices.add(rightTop);</span><br><span class="line">            indices.add(leftBottom);</span><br><span class="line">            indices.add(leftTop);</span><br><span class="line"></span><br><span class="line">            indices.add(rightBottom);</span><br><span class="line">            indices.add(leftBottom);</span><br><span class="line">            indices.add(rightTop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建顶点坐标的过程是不需要解释的。现在先别管为什么我们用一个数字乘以纹理坐标以及如何计算高度。你可以看到，对于每个顶点，我们定义两个三角形的索引(除非现在是最后一行或最后一列)。让我们用一个<strong>3×3</strong>的图像来想象它们是如何构造的。一个<strong>3×3</strong>的图像包含9个顶点，每因此有<strong>2×4</strong>个三角形组成4个正方形。下图展示了网格，每个顶点被命名为<code>Vrc</code>(r：行，c：列)。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap_vertices.png" alt="高度图顶点"></p><p>当处理第一个顶点(V00)时，我们在红色阴影处定义了两个三角形的索引。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap_indices_i.png" alt="高度图索引I"> </p><p>当处理第二个顶点(V01)时，我们在红色阴影处又定义了两个三角形的索引。但当处理第三个顶点(V02)时，我们不需要定义更多的索引，该行的所有三角形都已被定义。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/heightmap_indices_ii.png" alt="高度图索引II"> </p><p>你可以很容易地想到其他顶点的处理过程是如何进行的。现在，一旦创建了所有的顶点位置、纹理坐标和索引，我们就只需要用所有这些数据创建<code>Mesh</code>和相关的<code>Material</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] posArr = Utils.listToArray(positions);</span><br><span class="line"><span class="keyword">int</span>[] indicesArr = indices.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line"><span class="keyword">float</span>[] textCoordsArr = Utils.listToArray(textCoords);</span><br><span class="line"><span class="keyword">float</span>[] normalsArr = calcNormals(posArr, width, height);</span><br><span class="line"><span class="keyword">this</span>.mesh = <span class="keyword">new</span> Mesh(posArr, textCoordsArr, normalsArr, indicesArr);</span><br><span class="line">Material material = <span class="keyword">new</span> Material(texture, <span class="number">0.0f</span>);</span><br><span class="line">mesh.setMaterial(material);</span><br></pre></td></tr></table></figure><p>你可以看到，我们根据顶点位置计算法线。在看如何计算法线之前，来看看如何获取高度吧。我们已经创建了一个名为<code>getHeight</code>的方法，它负责计算顶点的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getHeight</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> width, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> r = buffer.get(x * <span class="number">4</span> + <span class="number">0</span> + z * <span class="number">4</span> * width);</span><br><span class="line">    <span class="keyword">byte</span> g = buffer.get(x * <span class="number">4</span> + <span class="number">1</span> + z * <span class="number">4</span> * width);</span><br><span class="line">    <span class="keyword">byte</span> b = buffer.get(x * <span class="number">4</span> + <span class="number">2</span> + z * <span class="number">4</span> * width);</span><br><span class="line">    <span class="keyword">byte</span> a = buffer.get(x * <span class="number">4</span> + <span class="number">3</span> + z * <span class="number">4</span> * width);</span><br><span class="line">    <span class="keyword">int</span> argb = ((<span class="number">0xFF</span> &amp; a) &lt;&lt; <span class="number">24</span>) | ((<span class="number">0xFF</span> &amp; r) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            | ((<span class="number">0xFF</span> &amp; g) &lt;&lt; <span class="number">8</span>) | (<span class="number">0xFF</span> &amp; b);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minY + Math.abs(<span class="keyword">this</span>.maxY - <span class="keyword">this</span>.minY) * ((<span class="keyword">float</span>) argb / (<span class="keyword">float</span>) MAX_COLOUR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法接受像素的X和Y坐标，图像的宽度以及与之相关的<code>ByteBuffer</code>，返回RGB颜色(R、G、B分量之和)并计算包含在<code>minY</code>和<code>maxY</code>之间的值(<code>minY</code>为黑色，<code>maxY</code>为白色)。</p><p>你可以使用<code>BufferedImage</code>来编写一个更简单的方法，它有更方便的方法来获得RGB值，但这将使用AWT。记住AWT不能很好的兼容OSX，所以尽量避免使用它的类。</p><p>现在来看看如何计算纹理坐标。第一个方法是将纹理覆盖整个网格，左上角的顶点纹理坐标为(0, 0)，右下角的顶点纹理坐标为(1, 1)。这种方法的问题是，纹理必须是巨大的，以便获得良好的渲染效果，否则纹理将会被过度拉伸。</p><p>但我们仍然可以使用非常小的纹理，通过使用高效的技术来获得很好的效果。如果我们设置超出[1, 1]范围的纹理坐标，我们将回到原点并重新开始计算。下图表示在几个正方形中平铺相同的纹理，并超出了[1, 1]范围。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/texture_coordinates_i.png" alt="纹理坐标I"> </p><p>这是我们在设置纹理坐标时所要做的。我们将一个参数乘以纹理坐标(计算好像整个网格被纹理包裹的情况)，即<code>textInc</code>参数，以增加在相邻顶点之间使用的纹理像素数。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/texture_coordinates_ii.png" alt="纹理坐标II"> </p><p>目前唯一没有解决的是法线计算。记住我们需要法线，光照才能正确地应用于地形。没有法线，无论光照如何，地形将以相同的颜色渲染。我们在这里使用的方法不一定是最高效的，但它将帮助你理解如何自动计算法线。如果你搜索其他解决方案，可能会发现更有效的方法，只使用相邻点的高度而不需要做交叉相乘操作。尽管如此，这仅需要在启动时完成，这里的方法不会对性能造成太大的损害。</p><p>让我们用图解的方式解释如何计算一个法线值。假设我们有一个名为<strong>P0</strong>的顶点。我们首先计算其周围每个顶点(<strong>P1</strong>, <strong>P2</strong>, <strong>P3</strong>, <strong>P4</strong>)和与连接这些点的面相切的向量。这些向量(<strong>V1</strong>, <strong>V2</strong>, <strong>V3</strong>, <strong>V4</strong>)是通过将每个相邻点与<strong>P0</strong>相减(例如<strong>V1 = P1 - P0</strong>)得到的。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/normals_calc_i.png" alt="法线计算I"> </p><p>然后，我们计算连接每一个相邻点的平面的法线。这是与之前计算得到的向量交叉相乘计算的。例如，向量<strong>V1</strong>与<strong>V2</strong>所在的平面(蓝色阴影部分)的法线是由<strong>V1</strong>和<strong>V2</strong>交叉相乘得到的，即<strong>V12 = V1 × V2</strong>。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/normals_calc_ii.png" alt="法线计算II"> </p><p>如果我们计算完毕其他平面的法线(<strong>V23 = V2 × V3</strong>，<strong>V34 = V3 × V4</strong>，<strong>V41 = V4 × V1</strong>)，则法线<strong>P0</strong>就是周围所有平面法线(归一化后)之和：<strong>N0 = V12 + V23 + V34 + V41</strong>。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/normals_calc_iii.png" alt="法线计算III"></p><p>法线计算的方法实现如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] calcNormals(<span class="keyword">float</span>[] posArr, <span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">    Vector3f v0 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v1 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v2 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v3 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v4 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v12 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v23 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v34 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    Vector3f v41 = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    List&lt;Float&gt; normals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Vector3f normal = <span class="keyword">new</span> Vector3f();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row &gt; <span class="number">0</span> &amp;&amp; row &lt; height -<span class="number">1</span> &amp;&amp; col &gt; <span class="number">0</span> &amp;&amp; col &lt; width -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i0 = row*width*<span class="number">3</span> + col*<span class="number">3</span>;</span><br><span class="line">                v0.x = posArr[i0];</span><br><span class="line">                v0.y = posArr[i0 + <span class="number">1</span>];</span><br><span class="line">                v0.z = posArr[i0 + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> i1 = row*width*<span class="number">3</span> + (col-<span class="number">1</span>)*<span class="number">3</span>;</span><br><span class="line">                v1.x = posArr[i1];</span><br><span class="line">                v1.y = posArr[i1 + <span class="number">1</span>];</span><br><span class="line">                v1.z = posArr[i1 + <span class="number">2</span>];                    </span><br><span class="line">                v1 = v1.sub(v0);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> i2 = (row+<span class="number">1</span>)*width*<span class="number">3</span> + col*<span class="number">3</span>;</span><br><span class="line">                v2.x = posArr[i2];</span><br><span class="line">                v2.y = posArr[i2 + <span class="number">1</span>];</span><br><span class="line">                v2.z = posArr[i2 + <span class="number">2</span>];</span><br><span class="line">                v2 = v2.sub(v0);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> i3 = (row)*width*<span class="number">3</span> + (col+<span class="number">1</span>)*<span class="number">3</span>;</span><br><span class="line">                v3.x = posArr[i3];</span><br><span class="line">                v3.y = posArr[i3 + <span class="number">1</span>];</span><br><span class="line">                v3.z = posArr[i3 + <span class="number">2</span>];</span><br><span class="line">                v3 = v3.sub(v0);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> i4 = (row-<span class="number">1</span>)*width*<span class="number">3</span> + col*<span class="number">3</span>;</span><br><span class="line">                v4.x = posArr[i4];</span><br><span class="line">                v4.y = posArr[i4 + <span class="number">1</span>];</span><br><span class="line">                v4.z = posArr[i4 + <span class="number">2</span>];</span><br><span class="line">                v4 = v4.sub(v0);</span><br><span class="line">                    </span><br><span class="line">                v1.cross(v2, v12);</span><br><span class="line">                v12.normalize();</span><br><span class="line"></span><br><span class="line">                v2.cross(v3, v23);</span><br><span class="line">                v23.normalize();</span><br><span class="line">                    </span><br><span class="line">                v3.cross(v4, v34);</span><br><span class="line">                v34.normalize();</span><br><span class="line">                    </span><br><span class="line">                v4.cross(v1, v41);</span><br><span class="line">                v41.normalize();</span><br><span class="line">                    </span><br><span class="line">                normal = v12.add(v23).add(v34).add(v41);</span><br><span class="line">                normal.normalize();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                normal.x = <span class="number">0</span>;</span><br><span class="line">                normal.y = <span class="number">1</span>;</span><br><span class="line">                normal.z = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            normal.normalize();</span><br><span class="line">            normals.add(normal.x);</span><br><span class="line">            normals.add(normal.y);</span><br><span class="line">            normals.add(normal.z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Utils.listToArray(normals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，为了创建更大的地形，我们有两个选择：</p><ul><li>创建更大的高度图</li><li>重用高度图并将其平铺在三维空间中。高度图将像一个地形块，在世界上像瓷砖一样平移。为了做到这一点，高度图边缘的像素必须是相同的(左侧边缘必须与右侧相同，上侧边缘必须与下侧相同)，以避免块之间的间隙。</li></ul><p>我们将使用第二种方法(并选择适当的高度图)。为了做到它，我们将创建一个名为<code>Terrain</code>的类，该类将创建一个正方形的高度图块，定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.HeightMapMesh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GameItem[] gameItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Terrain</span><span class="params">(<span class="keyword">int</span> blocksPerRow, <span class="keyword">float</span> scale, <span class="keyword">float</span> minY, <span class="keyword">float</span> maxY, String heightMap, String textureFile, <span class="keyword">int</span> textInc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        gameItems = <span class="keyword">new</span> GameItem[blocksPerRow * blocksPerRow];</span><br><span class="line">        HeightMapMesh heightMapMesh = <span class="keyword">new</span> HeightMapMesh(minY, maxY, heightMap, textureFile, textInc);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; blocksPerRow; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; blocksPerRow; col++) &#123;</span><br><span class="line">                <span class="keyword">float</span> xDisplacement = (col - ((<span class="keyword">float</span>) blocksPerRow - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getXLength();</span><br><span class="line">                <span class="keyword">float</span> zDisplacement = (row - ((<span class="keyword">float</span>) blocksPerRow - <span class="number">1</span>) / (<span class="keyword">float</span>) <span class="number">2</span>) * scale * HeightMapMesh.getZLength();</span><br><span class="line"></span><br><span class="line">                GameItem terrainBlock = <span class="keyword">new</span> GameItem(heightMapMesh.getMesh());</span><br><span class="line">                terrainBlock.setScale(scale);</span><br><span class="line">                terrainBlock.setPosition(xDisplacement, <span class="number">0</span>, zDisplacement);</span><br><span class="line">                gameItems[row * blocksPerRow + col] = terrainBlock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameItem[] getGameItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> gameItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们详解整个过程，我们拥有由以下坐标定义的块(X和Z使用之前定义的常量)。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/terrain_construction_1.png" alt="地形构建I"></p><p>假设我们创建了一个由3×3块网格构成的地形。我们假设我们不会缩放地形块(也就是说，变量<code>blocksPerRow</code>是<strong>3</strong>而变量<code>scale</code>将会是<strong>1</strong>)。我们希望网格的中央在坐标系的(0, 0)。</p><p>我们需要移动块，这样顶点就变成如下坐标。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/terrain_construction_2.png" alt="地形构建II"></p><p>移动是通过调用<code>setPosition</code>方法实现的，但记住，我们所设置的是一个位移而不是一个位置。如果你看到上图，你会发现中央块不需要任何移动，它已经定位在适当的坐标上。绘制绿色顶点需要在X轴上位移<strong>-1</strong>，而绘制蓝色顶点需要在X轴上位移<strong>+1</strong>。计算X位移的公式，要考虑到缩放和块的宽度，公式如下：</p><script type="math/tex; mode=display">xDisplacement=(col - (blocksPerRow -1 ) / 2) \times scale \times width</script><p>Z位移的公式为：</p><script type="math/tex; mode=display">zDisplacement=(row - (blocksPerRow -1 ) / 2) \times scale \times height</script><p>如果在<code>DummyGame</code>类中创建一个<code>Terrain</code>实例，我们可以得到如图所示的效果。</p><p><img src="/2019/02/07/Lwjglbook-14-height-maps/terrain_result.png" alt="地形结果"> </p><p>你可以在地形周围移动相机，看看它是如何渲染的。由于还没有实现碰撞检测，你可以穿过它并从上面看它。由于我们已经启用了面剔除，当从下面观察时，地形的某些部分不会渲染。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十三章 天空盒与一些优化</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/</id>
    <published>2019-02-07T09:20:45.000Z</published>
    <updated>2019-02-27T14:42:51.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter13" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter13</a></p><p>英文标题：Sky Box and some optimizations</p></blockquote><h2 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h2><p>天空盒(Sky Box)允许我们设置背景，让玩家产生三维世界看起来更大的错觉。这个背景将摄像机所在的位置包裹起来，并覆盖整个空间。我们要做的是构造一个大立方体，它将显示在三维场景周围，也就是说，摄像机的位置将是立方体的中心。这个立方体的侧面将包裹着一个纹理，纹理上有一座小山，蓝天和云彩，这些图像将被显示为一幅连续的风景。</p><p>下图展示了天空盒的概念。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox.png" alt="天空盒"></p><p>创建天空盒的过程可概括为以下几步：</p><ul><li>创建一个大立方体。</li><li>给它加上纹理，让我们看到一个没有边缘的巨大景观的错觉。</li><li>渲染立方体，它的边缘在很远的地方，它的原点在摄像机的位置。</li></ul><p>然后，我们从纹理开始。你会发现互联网上有很多预先生成的纹理，本章示例中使用的一个纹理从这里下载：<a href="http://www.custommapmakers.org/skyboxes.php" target="_blank" rel="noopener">http://www.custommapmakers.org/skyboxes.php</a>。我们使用的纹理是：<a href="http://www.custommapmakers.org/skyboxes/zips/ely_hills.zip" target="_blank" rel="noopener">http://www.custommapmakers.org/skyboxes/zips/ely_hills.zip</a>，作者是Colin Lowndes。</p><p>该网站的纹理都是由TGA文件组成，每个文件都是立方体的一面。我们的纹理加载器希望文件格式为PNG，所以需要将所有TGA图像组合成一个PNG图像。我们可以使用其他方法，比如立方体映射(Cube Mapping)，让其自动使用纹理。但为了使本章简洁易懂，你必须手动把它们排列成一个图片。最终图像是这样的：</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_texture.png" alt="天空盒纹理"></p><p>之后我们需要创建一个OBJ文件，其中有一个立方体，立方体的每一面的纹理坐标都正确地设置了。下面的图片展示了材质与面关联的区域(你可以在本书源代码中找到本章使用的OBJ文件)。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_cube_faces.png" alt="天空盒立方体的面"></p><p>一旦资源准备完毕，我们就可以开始编写代码了。首先创建一个名为<code>SkyBox</code>的新类，它的构造函数接收OBJ模型路径和天空盒纹理文件路径。就像之前一章的HUD一样，这个类也继承<code>GameItem</code>类。为什么它要继承<code>GameItem</code>类？首先，为了方便我们重用大部分处理网格和纹理的代码。第二，因为天空盒不会移动，我们只想使用旋转和缩放。这样想想<code>SkyBox</code>确实是一个<code>GameItem</code>。<code>SkyBox</code>类的实现如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Material;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Mesh;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.OBJLoader;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkyBox</span> <span class="keyword">extends</span> <span class="title">GameItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkyBox</span><span class="params">(String objModel, String textureFile)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        Mesh skyBoxMesh = OBJLoader.loadMesh(objModel);</span><br><span class="line">        Texture skyBoxtexture = <span class="keyword">new</span> Texture(textureFile);</span><br><span class="line">        skyBoxMesh.setMaterial(<span class="keyword">new</span> Material(skyBoxtexture, <span class="number">0.0f</span>));</span><br><span class="line">        setMesh(skyBoxMesh);</span><br><span class="line">        setPosition(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你查看了本章的源代码，你将看到我们重构了一些代码。我们创建了一个名为<code>Scene</code>的类，它与三维世界相关的内容有关。<code>Scene</code>类的实现和属性如下，其中有<code>SkyBox</code>类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameItem[] gameItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SkyBox skyBox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SceneLight sceneLight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameItem[] getGameItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> gameItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更多代码...</span></span><br></pre></td></tr></table></figure><p>接下来是为天空盒创建一组顶点和片元着色器。但为什么不使用我们已有的场景着色器呢？实际上，我们需要的着色器是原有着色器的简化版，不让光照影响天空盒(更准确的说，我们不需要点光源，聚光源和平行光源)。下面是天空盒的顶点着色器。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们仍使用模型观察矩阵。此前已说明过，我们将缩放天空盒，所以需要变换矩阵。你可能会看到一些其他实现，在初始化时就放大了立方体模型的大小，并且不需要将模型和观察矩阵相乘。但我们选择了之前的方法，因为它更灵活，它允许我们在运行时改变天空盒的大小，但如果你愿意，可以轻松切换到另一种方法。</p><p>片元着色器也非常简单。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> mvPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> ambientLight;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(ambientLight, <span class="number">1</span>) * <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，我们为着色器添加了一个环境光，这个Uniform的目的是修改天空盒的颜色来模拟白天和黑夜(如果不这样，在世界的其他地方都是黑暗的时候，天空盒看起来就像是在中午)。</p><p>在<code>Renderer</code>类中，我们刚刚添加了新的方法来使用这些着色器并设置Uniform(这没有什么新的概念)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupSkyBoxShader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    skyBoxShaderProgram = <span class="keyword">new</span> ShaderProgram();</span><br><span class="line">    skyBoxShaderProgram.createVertexShader(Utils.loadResource(<span class="string">"/shaders/sb_vertex.vs"</span>));</span><br><span class="line">    skyBoxShaderProgram.createFragmentShader(Utils.loadResource(<span class="string">"/shaders/sb_fragment.fs"</span>));</span><br><span class="line">    skyBoxShaderProgram.link();</span><br><span class="line"></span><br><span class="line">    skyBoxShaderProgram.createUniform(<span class="string">"projectionMatrix"</span>);</span><br><span class="line">    skyBoxShaderProgram.createUniform(<span class="string">"modelViewMatrix"</span>);</span><br><span class="line">    skyBoxShaderProgram.createUniform(<span class="string">"texture_sampler"</span>);</span><br><span class="line">    skyBoxShaderProgram.createUniform(<span class="string">"ambientLight"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们需要为渲染天空盒在全局渲染中创建一个新的渲染方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renderSkyBox</span><span class="params">(Window window, Camera camera, Scene scene)</span> </span>&#123;</span><br><span class="line">    skyBoxShaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    skyBoxShaderProgram.setUniform(<span class="string">"texture_sampler"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新投影矩阵</span></span><br><span class="line">    Matrix4f projectionMatrix = transformation.getProjectionMatrix(FOV, window.getWidth(), window.getHeight(), Z_NEAR, Z_FAR);</span><br><span class="line">    skyBoxShaderProgram.setUniform(<span class="string">"projectionMatrix"</span>, projectionMatrix);</span><br><span class="line">    SkyBox skyBox = scene.getSkyBox();</span><br><span class="line">    Matrix4f viewMatrix = transformation.getViewMatrix(camera);</span><br><span class="line">    viewMatrix.m30(<span class="number">0</span>);</span><br><span class="line">    viewMatrix.m31(<span class="number">0</span>);</span><br><span class="line">    viewMatrix.m32(<span class="number">0</span>);</span><br><span class="line">    Matrix4f modelViewMatrix = transformation.getModelViewMatrix(skyBox, viewMatrix);</span><br><span class="line">    skyBoxShaderProgram.setUniform(<span class="string">"modelViewMatrix"</span>, modelViewMatrix);</span><br><span class="line">    skyBoxShaderProgram.setUniform(<span class="string">"ambientLight"</span>, scene.getSceneLight().getAmbientLight());</span><br><span class="line"></span><br><span class="line">    scene.getSkyBox().getMesh().render();</span><br><span class="line"></span><br><span class="line">    skyBoxShaderProgram.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法与其他渲染方法非常相似，但有一个需要详解的不同。如你所见，我们像平常一样传递投影矩阵和模型观察矩阵。但当我们得到观察矩阵是，我们将一些数值设置为0。为什么要这么做？这背后的原因是，我们不希望天空盒被移动。</p><p>请记住，当我们在移动摄像机时，实际上是在移动整个世界。因此，如果我们直接将观察矩阵与模型矩阵相乘，当摄像机移动时，天空盒也将移动。但是我们不想这样，我们想把它固定在坐标原点(0, 0, 0)。这是通过设置观察矩阵的移动量部分实现的(<code>m30</code>, <code>m31</code>和<code>m32</code>)。</p><p>你可能会认为可以避免使用观察矩阵，因为天空盒必须固定在原点。但在这种情况下，你会看到天空盒不会随着相机旋转，这不是我们想要的。因此我们需要旋转它但不要移动它。</p><p>这就是全部，你可以查看本章源代码，在<code>DummyGame</code>类中我们创建了更多的方块实例来模拟一个地面和一个天空盒。你也可以改变环境光来模拟光照和昼夜交替。你会看到下面的情况。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_result.png" alt="天空盒结果"></p><p>天空盒是一个很小的立方体，所以你很容易地看到移动的效果(在实际的游戏中，它应该大得多)。你也可以看到，组成地面的方块比天空盒子大，所以当你移动时，你会看到在山中出现的方块。这是比较明显的，因为我们设置的天空盒相对大小较小。但无论如何，我们需要通过隐藏和模糊远处的物体(例如使用雾效果)来减轻这种影响。</p><p>不创建更大的天空盒的另一个原因是我们需要进行几个优化来提高效率(稍后对此进行解释)。</p><p>可以注释渲染方法中防止天空盒移动的代码，然后你就可以在天空盒外看到类似景象。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_displaced.png" alt="天空盒移动"></p><p>虽然这不是一个天空盒该做的，但它可以帮助你理解天空盒的概念。请记住，这是一个简单的例子，你可以通过增加其他效果来改善它，比如太阳在天空中移动或云层移动。此外，为了创建更大的世界，你需要将世界分割成区域，只加载那些与玩家所处的区域相连的区域。</p><p>另外要提的是，我们应该在什么时候渲染天空盒，在场景渲染之前还是之后？场景渲染后渲染天空盒更好，因为大部分片元将由于深度测试而被丢弃。也就是说，那些被场景元素遮挡的不可见的天空盒片元将被丢弃。当OpenGL尝试渲染它们，并启用深度测试时，它将丢弃那些渲染在先前已渲染的片元之后的片元，这是因为这些片元的深度值较低。所以答案很明显，对吧？在渲染场景后，只需渲染天空盒即可。但这个方法的问题是如何处理透明纹理。如果我们在场景中有透明纹理的物体，它们将使用“背景”色绘制，但现在的颜色是黑色。如果我们先渲染天空盒，透明效果将正确地渲染。那么，我们应该在场景之前渲染天空盒吗？正确但又不正确。如果你在场景渲染前渲染天空盒，可以解决透明纹理问题，但是会影响性能。不过你现在可能没有面临天空盒的透明纹理问题。但假设你有一个透明的物品，它与远处的物体重叠，如果首先渲染透明对象，那么也会出现其他问题。因此，另一种方法是在所有其他元素被渲染后，透明地绘制透明的物体。这是一些商业游戏使用的方法。不过现在我们在渲染场景之后渲染天空盒，以期获得更好的性能。</p><h2 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h2><p>从之前的例子来看，天空盒相对较小使得它看起来有点奇怪(你可以看到物体从山后神奇地出现)。所以让我们增加天空盒的大小和世界的大小，将天空盒的大小放大50倍，这样世界由40,000个游戏元素实例(方块)组成</p><p>如果你改变缩放并重新运行这个例子，你会发现开始出现性能问题，并且在三维世界中移动不流畅。现在是时候关注一下性能了(你可能听过一句老话，“过早的优化是万恶之源”，但是从第13章开始，我希望没有人会说这是过早的)。</p><p>让我们开始介绍一个概念，它能减少正在渲染的数据数量，它叫做面剔除(Face Culling)。在示例中，我们渲染了成千上万个立方体，立方体是由六个面组成的。我们正在渲染每个立方体的六个面，即使它们有些是看不到的。通过放大一个立方体，你会看到它的内部就像这样。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/cube_interior.png" alt="立方体内部"></p><p>不能被看到的面应该立即被丢弃，这就是面剔除的方式。事实上，对于一个立方体，你最多同时看到三个面，所以我们只能通过使用面剔除来舍弃一半的面(40,000×3×2个三角形)(如果你的游戏不要求你进入模型的内侧，这是高效的，稍后你就可以看到)。</p><p>面剔除检查是为了让每个三角形都面向我们，丢弃那些不面向我们的三角形。但是，如何知道三角形是否面向我们呢？线索就是OpenGL是将顶点以卷绕顺序构成三角形的。</p><p>记得从第一张开始，我们可以定义一个三角形的顶点以顺时针或逆时针顺序排列。在OpenGL中，默认情况下以逆时针顺序排列顶点的三角形面向观察者，而以顺时针顺序排列顶点的三角形面向相反的方向。关键是在考虑观察点的情况下，检查顶点排列顺序。因此，按照逆时针顺序定义的三角形可以渲染。</p><p>让我们来实现它，在<code>Window</code>类的<code>init</code>方法中添加下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure><p>第一行代码将启用面剔除，第二行代码设置背向面为需要剔除的面。如果向上看，你会看到这样的东西。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_face_culling.png" alt="使用面剔除的天空盒"></p><p>发生了什么？如果你查看顶面的顶点顺序，将看到它是按逆时针定义的。但请记住，它包裹的是摄像机。事实上，如果你让位移影响天空盒，这样就能从上面看到它，你会发现当在上面时，它会再次出现。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/skybox_face_culling_exterior.png" alt="从外部看使用面剔除的天空盒"></p><p>让我们描述一下发生了什么。下图展示了天空盒立方体的顶面三角形中的一个三角形，它由逆时针顺序排列的三个顶点定义。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/cube_counter_clockwise.png" alt="以逆时针顺序定义的顶点"></p><p>但要记住，我们是在天空盒里，如果从内部观察立方体，会看到顶点是按顺时针顺序排列的。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/cube_clockwise.png" alt="从内部看立方体"></p><p>这是因为天空盒被定义为从外部观察。因此，我们需要改变一些面的朝向，以便在启用面剔除时能被正确地渲染。</p><p>但仍有更多的优化空间。让我们回顾一下渲染过程。在<code>Renderer</code>类<code>render</code>方法中，我们做的是遍历<code>GameItem</code>数组和渲染相关的<code>Mesh</code>。对每个<code>GameItem</code>，我们做了以下事情：</p><ol><li>设置模型观察矩阵(每个<code>GameItem</code>的唯一值)。</li><li>获取<code>GameItem</code>储存的<code>Mesh</code>并绑定纹理，绑定VAO并启用其属性。</li><li>执行调用，渲染三角形。</li><li>禁用纹理和VAO。</li></ol><p>但在现在的游戏中，40,000个<code>GameItem</code>都使用相同的<code>Mesh</code>，而我们重复第二项到第四项的操作。这不是很高效的，请记住，对OpenGL函数的每次调用都是有性能开销的本地调用。除此之外，我们还应该尽量限制OpenGL中的状态变化(绑定和解绑纹理、VAO都是状态变化)。</p><p>我们需要改变开发的方式，围绕网格组织代码结构，因为经常有许多游戏项目使用相同的网格。现在我们有一个游戏项目，每个都指向同一个网格。就像下图那样。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/game_item_list.png" alt="游戏项数组"></p><p>我们将创建一个网格映射图取代之前的方法，其中包括储存共享该网格的所有游戏项目。</p><p><img src="/2019/02/07/Lwjglbook-13-sky-box-and-some-optimizations/mesh_map.png" alt="网格图"></p><p>对于每一个<code>Mesh</code>，渲染步骤将是：</p><ol><li>设置模型观察矩阵(每个<code>GameItem</code>唯一的)。</li><li>获取与<code>GameItem</code>相关联的<code>Mesh</code>并绑定<code>Mesh</code>纹理，绑定VAO并启用其属性。</li><li>对于每个相关的<code>GameItem</code>：<br>a. 设置模型观察矩阵(每个<code>GameItem</code>唯一的)。<br>b. 调用绘制三角形。</li><li>解绑纹理和VAO。</li></ol><p>在<code>Scene</code>类中，我们将储存下面的<code>Map</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Mesh, List&lt;GameItem&gt;&gt; meshMap;</span><br></pre></td></tr></table></figure><p>我们仍有<code>setGameItems</code>方法，但我们不只是储存数组，而是构造网格映射图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGameItems</span><span class="params">(GameItem[] gameItems)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numGameItems = gameItems != <span class="keyword">null</span> ? gameItems.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numGameItems; i++) &#123;</span><br><span class="line">        GameItem gameItem = gameItems[i];</span><br><span class="line">        Mesh mesh = gameItem.getMesh();</span><br><span class="line">        List&lt;GameItem&gt; list = meshMap.get(mesh);</span><br><span class="line">        <span class="keyword">if</span> ( list == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            meshMap.put(mesh, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(gameItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mesh</code>类现在有一个方法来渲染与其相关的<code>GameItem</code>列表，然后将绑定和解绑代码分成了不同的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Texture texture = material.getTexture();</span><br><span class="line">    <span class="keyword">if</span> (texture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 激活第一个纹理库</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        <span class="comment">// 绑定纹理</span></span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制网格</span></span><br><span class="line">    glBindVertexArray(getVaoId());</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endRender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 恢复状态</span></span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glDisableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glDisableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initRender();</span><br><span class="line"></span><br><span class="line">    glDrawElements(GL_TRIANGLES, getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    endRender();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renderList</span><span class="params">(List&lt;GameItem&gt; gameItems, Consumer&lt;GameItem&gt; consumer)</span> </span>&#123;</span><br><span class="line">    initRender();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (GameItem gameItem : gameItems) &#123;</span><br><span class="line">        <span class="comment">// 设置游戏项目所需的渲染数据</span></span><br><span class="line">        consumer.accept(gameItem);</span><br><span class="line">        <span class="comment">// 渲染游戏项目</span></span><br><span class="line">        glDrawElements(GL_TRIANGLES, getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    endRender();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，我们仍然保留了旧方法，它返回一个<code>Mesh</code>，这是考虑到如果只有一个<code>GameItem</code>的情况(这可能在其他情况下使用，这就是为什么不移除它)。新的方法渲染一个<code>List&lt;GameItem&gt;</code>，并接受一个<code>Counsumer</code>类型的参数(一个函数，使用了Java8引入的函数式编程)，它将用于在绘制三角形之前为每个<code>GameItem</code>设置特定的内容。我们将使用它来设置模型观察矩阵，因为不希望<code>Mesh</code>类与Uniform的名称和设置这些参数时所涉及的参数相耦合。</p><p>在<code>Renderer</code>类中的<code>renderScene</code>方法你可以看到，我们只需遍历网格映射图，并通过Lambda设置模型观察矩阵Uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Mesh mesh : mapMeshes.keySet()) &#123;</span><br><span class="line">    sceneShaderProgram.setUniform(<span class="string">"material"</span>, mesh.getMaterial());</span><br><span class="line">    mesh.renderList(mapMeshes.get(mesh), (GameItem gameItem) -&gt; &#123;</span><br><span class="line">        Matrix4f modelViewMatrix = transformation.buildModelViewMatrix(gameItem, viewMatrix);</span><br><span class="line">        sceneShaderProgram.setUniform(<span class="string">"modelViewMatrix"</span>, modelViewMatrix);</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以做的另一组优化是，我们在渲染周期中创建了大量对象。特别是，我们创建了太多的<code>Matrix4f</code>实例，它们为每个<code>GameItem</code>实例都保存了一个模型视图矩阵。我们应在<code>Transformation</code>类中创建特定的矩阵，并重用相同的实例。如果你查看源码，会看到我们已经更改了方法的名称，<code>getXX</code>方法只返回储存的矩阵实例，并且改变矩阵值得任何方法都被称为<code>buildXX</code>，以阐明其作用。</p><p>我们也避免了每次为矩阵设置Uniform时构造新的<code>FloatBuffer</code>实例，并移除了其他一些无用的实例化操作。有了这些，你就可以看到更流畅更灵活的渲染了。</p><p>你可以在源代码中查看所有细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十二章 游戏HUD</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-12-game-hud/</id>
    <published>2019-02-07T09:20:38.000Z</published>
    <updated>2019-02-27T14:42:51.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter12" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter12</a></p><p>英文标题：Game HUD</p></blockquote><p>本章中我们将为游戏实现一个HUD(平视显示器)。换句话说，就是在三维场景上用一组二维图形和文本显示相关信息。我们将创建一个简单的HUD，接下来将说明一些如何显示这些信息的基本方法。</p><p>当你查看本章的源代码时，还将看到我们重构了一些代码，特别是<code>Renderer</code>类，以便为HUD渲染做好准备。</p><h2 id="文本渲染"><a href="#文本渲染" class="headerlink" title="文本渲染"></a>文本渲染</h2><p>创建HUD所要做的第一件事是渲染文本。为了实现它，我们将把包含字母字符的纹理的纹理映射到一个矩形中，该矩形将被分割为一组表示各个字符的片段。之后，我们将使用该纹理绘制文本。所以第一步是创建含有所有字符的纹理，你可以使用很多程序来做，例如<a href="http://www.codehead.co.uk/cbfg/" target="_blank" rel="noopener">CBFG</a>、<a href="http://sourceforge.net/projects/f2ibuilder/" target="_blank" rel="noopener">F2IBuilder</a>等等。现在我们使用Codehead’s Bitmap Font Generator(CBFG)。</p><p>CBFG有很多设置，例如纹理大小、字体类型、要使用的反走样等等。下图是我们将用来生成纹理文件的配置。在本章中，我们将假设文本编码为ISO-8859-1格式，如果需要处理不同的编码格式，则需要稍微修改代码。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/CBG.png" alt="CBFG配置"></p><p>当你设置CBFG的所有配置后，可以导出为多种图片格式。现在我们将它导出为BMP文件，然后再转换为PNG文件，以便将它作为纹理加载。当转换为PNG格式时，我们也可以将黑色背景设置为透明，也就是说，我们将黑色的Alpha值设置为0(可以使用GIMP这样的工具)。最后，你会得到与下图类似的东西。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/font_texture.png" alt="字体纹理"></p><p>如上所试，所有的字符都排列在图像中。现在图像有15列和17行。通过<br>As you can see, the image has all the characters displayed in rows and columns. In this case the image is composed by 15 columns  and 17 rows. By using the character code of a specific letter we can calculate the row and the column that is enclosed in the image. The column can be calculated as follows:  <script type="math/tex">column = code \space mod \space numberOfColumns</script>. Where <script type="math/tex">mod</script> is the module operator. The row can be calculated as follows: <script type="math/tex">row = code / numberOfCols</script>, in this case we will do a integer by integer operation so we can ignore the decimal part.</p><p>我们将创建一个名为<code>TextItem</code>的类，它将储存渲染文本所需的内容。这是一个简化的实现，不考虑多行文本等特性，但它能在HUD中显示文本信息。下面是这个类的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Material;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Mesh;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Texture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextItem</span> <span class="keyword">extends</span> <span class="title">GameItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> ZPOS = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICES_PER_QUAD = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numCols;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numRows;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextItem</span><span class="params">(String text, String fontFileName, <span class="keyword">int</span> numCols, <span class="keyword">int</span> numRows)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.numCols = numCols;</span><br><span class="line">        <span class="keyword">this</span>.numRows = numRows;</span><br><span class="line">        Texture texture = <span class="keyword">new</span> Texture(fontFileName);</span><br><span class="line">        <span class="keyword">this</span>.setMesh(buildMesh(texture, numCols, numRows));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类继承了<code>GameItem</code>，这是因为我们希望改变文本在屏幕上的位置，也可能需要缩放和旋转它。构造函数接收腰显示的文本和用于渲染的纹理数据(包括图像数据和行列数目)。</p><p>在构造函数中，我们加载纹理图像文件，并调用一个方法来创建一个<code>Mesh</code>实例用于模拟文本。让我们看看<code>buildMesh</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mesh <span class="title">buildMesh</span><span class="params">(Texture texture, <span class="keyword">int</span> numCols, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] chars = text.getBytes(Charset.forName(<span class="string">"ISO-8859-1"</span>));</span><br><span class="line">    <span class="keyword">int</span> numChars = chars.length;</span><br><span class="line"></span><br><span class="line">    List&lt;Float&gt; positions = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List&lt;Float&gt; textCoords = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">float</span>[] normals   = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">0</span>];</span><br><span class="line">    List&lt;Integer&gt; indices   = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> tileWidth = (<span class="keyword">float</span>)texture.getWidth() / (<span class="keyword">float</span>)numCols;</span><br><span class="line">    <span class="keyword">float</span> tileHeight = (<span class="keyword">float</span>)texture.getHeight() / (<span class="keyword">float</span>)numRows;</span><br></pre></td></tr></table></figure><p>代码创建了用于储存Mesh的位置、纹理坐标、法线和索引的数据结构。现在我们不使用照明，因此法线数列是空的。我们要做的是构造一组字符片段，每个字符片段代表一个字符。我们还需要根据每个字符片段对应的字符来分配适当的纹理坐标。下图表示了文本矩形和字符片段的关系。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_quad.png" alt="文本矩形"></p><p>因此，对于每个字符，我们需要创建由两个三角形构成的字符片段，这两个三角形可以用四个顶点(V1、V2、V3和V4)定义。第一个三角形(左下角的那个)的索引为(0, 1, 2)，而第二个三角形(右上角的那个)的索引为(3, 0, 2)。纹理坐标是基于与纹理图像中每个字符相关连的行和列计算的，纹理坐标的范围为[0,1]，所以我们只需要将当前行或当前列除以总行数和总列数就可以获得V1的坐标。对于其他顶点，我们只需要适当加上行宽或列宽就可以。</p><p>下面的循环语句块就创建了与显示文本的矩形相关的所有顶点、纹理坐标和索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numChars; i++) &#123;</span><br><span class="line">    <span class="keyword">byte</span> currChar = chars[i];</span><br><span class="line">    <span class="keyword">int</span> col = currChar % numCols;</span><br><span class="line">    <span class="keyword">int</span> row = currChar / numCols;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造由两个三角形组成的字符片段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)col / (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)row / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左下角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(tileHeight); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)col / (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(row + <span class="number">1</span>) / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右下角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth + tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(tileHeight); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(col + <span class="number">1</span>)/ (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(row + <span class="number">1</span>) / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右上角的顶点</span></span><br><span class="line">    positions.add((<span class="keyword">float</span>)i*tileWidth + tileWidth); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">//y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">//z</span></span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)(col + <span class="number">1</span>)/ (<span class="keyword">float</span>)numCols );</span><br><span class="line">    textCoords.add((<span class="keyword">float</span>)row / (<span class="keyword">float</span>)numRows );</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加左上角和右下角顶点的索引</span></span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中需要注意的一些事情是：</p><ul><li>我们将使用屏幕坐标来表示顶点(记住屏幕坐标系的原点位于屏幕左上角)。三角形上顶点的Y坐标小于三角形底部顶点的Y坐标。</li><li>我们不缩放图形，因此每个字符片段的X宽度等于字符宽度。三角形的高度将是每个字符的高度。这是因为我们希望尽可能地使文本渲染得像原始纹理(不管怎样，我们可以稍后对它进行缩放，因为<code>TextItem</code>类继承了<code>GameItem</code>类。</li><li>Z坐标为固定值，因为它与绘制这个图像无关。</li></ul><p>下图显示了一些顶点的坐标。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_quad_coords.png" alt="文本矩形坐标"></p><p>为什么我们使用屏幕坐标？首先，我们将在HUD中渲染2D对象，这样通常更容易使用它们。其次，我们将使用正投影(<code>Orthographic Projection</code>)绘制它们，稍后再解释什么是正投影。</p><p><code>TextItem</code>类最后还需添加一些方法，以获取文本并在运行时更改文本。每当文本被更改时，我们需要清理之前的VAO(储存在<code>Mesh</code>实例中)并创建一个新的VAO。我们不需要清理纹理，所以在<code>Mesh</code>类中添加了一个新方法来删除这些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    Texture texture = <span class="keyword">this</span>.getMesh().getMaterial().getTexture();</span><br><span class="line">    <span class="keyword">this</span>.getMesh().deleteBuffers();</span><br><span class="line">    <span class="keyword">this</span>.setMesh(buildMesh(texture, numCols, numRows));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我们已经建立了渲染文本所需要的基础结构，接下来该怎么做呢？首先是渲染三维场景，在之前的章节已经说明了，然后再在上面渲染二维HUD。为了渲染HUD，我们将使用正投影(也称为正交投影(<code>Orthogonal Projection</code>))。正投影是三维物体的二维表示，你可能已经在三维模型的蓝图中看到了一些例子，它们用来表示某些物体的顶部或某些侧面的样子。下图展示了圆柱体从顶部和前面的正投影。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_projections.png" alt="正投影"></p><p>为了绘制二维物体，这个投影是非常方便的，因为它“忽略”了Z坐标的值，也就是说，忽略了到屏幕的距离。有了这种矩阵，物体的体积不会随着距离的增大而减小(如投影矩阵)。为了使用正投影投影物体，我们需要使用另一个矩阵。正投影矩阵的公式如下所示。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_matrix.png" alt="正投影矩阵"></p><p>这个矩阵还矫正了失真，因为我们的窗口并不总是完美的正方形，而是一个矩形。<code>right</code>和<code>bottom</code>是屏幕大小，而<code>left</code>和<code>top</code>是原点坐标。正投影矩阵用于将屏幕坐标转换为三维空间坐标。下图展示了这个投影是如何完成的。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/orthographic_projection_sample.png" alt="正投影示例"></p><p>这个矩阵允许我们使用屏幕坐标。</p><p>我们现在可以继续实现HUD了。接下来我们要做的是创建另一组着色器，一个顶点着色器和一个片元着色器，来绘制HUD。顶点着色器很简单：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projModelMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projModelMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它仅接收顶点坐标、纹理坐标、索引和法线，并将使用矩阵将它们转换为三维空间坐标。该矩阵即是正投影矩阵与模型矩阵相乘，即<script type="math/tex">projModelMatrix  =  ortographicMatrix \cdot modelMatrix</script>。由于我们没有在模型坐标系中使用任何坐标，所以在Java代码中将两个矩阵相乘比在着色器中相乘更高效。这样，我们只需为每个顶点做一次乘法运算。还要记住顶点应该用屏幕坐标表示。</p><p>片元着色器也很简单：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> mvPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> colour;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = colour * <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只是将基本颜色与纹理颜色相乘，这样可以改变渲染文本的颜色，而不需要创建多个纹理文件。现在既然我们已经创建了一组新的着色器，就可以在<code>Renderer</code>类中使用它们。但在此之前，我们要创建一个名为<code>IHud</code>的接口，该接口储存要在HUD上显示的所有元素，还提供一个默认的<code>cleanup</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHud</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GameItem[] getGameItems();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GameItem[] gameItems = getGameItems();</span><br><span class="line">        <span class="keyword">for</span> (GameItem gameItem : gameItems) &#123;</span><br><span class="line">            gameItem.getMesh().cleanUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用该接口，不同的游戏可以定义自定义的HUD，而不需要改变渲染机制。现在回到<code>Renderer</code>类，顺便说一下，它已经被移动到<code>engine.graph</code>包下，因为现在它的通用性足以不依赖任何游戏的具体实现了。在<code>Renderer</code>类中，我们添加了一个新的方法来创建、连接和初始化一个新的<code>ShaderProgram</code>，以便使用之前所述的着色器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupHudShader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    hudShaderProgram = <span class="keyword">new</span> ShaderProgram();</span><br><span class="line">    hudShaderProgram.createVertexShader(Utils.loadResource(<span class="string">"/shaders/hud_vertex.vs"</span>));</span><br><span class="line">    hudShaderProgram.createFragmentShader(Utils.loadResource(<span class="string">"/shaders/hud_fragment.fs"</span>));</span><br><span class="line">    hudShaderProgram.link();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为正投影模型矩阵和颜色创建Uniform</span></span><br><span class="line">    hudShaderProgram.createUniform(<span class="string">"projModelMatrix"</span>);</span><br><span class="line">    hudShaderProgram.createUniform(<span class="string">"colour"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>render</code>方法首先会调用<code>renderScene</code>方法，里面包含了之前章节所述的渲染三维场景的代码，然后调用一个名为<code>renderHud</code>的新方法，用于渲染HUD。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window, Camera camera, GameItem[] gameItems,</span></span></span><br><span class="line"><span class="function"><span class="params">    SceneLight sceneLight, IHud hud)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">        window.setResized(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderScene(window, camera, gameItems, sceneLight);</span><br><span class="line"></span><br><span class="line">    renderHud(window, hud);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>renderHud</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renderHud</span><span class="params">(Window window, IHud hud)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    hudShaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    Matrix4f ortho = transformation.getOrthoProjectionMatrix(<span class="number">0</span>, window.getWidth(), window.getHeight(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (GameItem gameItem : hud.getGameItems()) &#123;</span><br><span class="line">        Mesh mesh = gameItem.getMesh();</span><br><span class="line">        <span class="comment">// HUD元素的正投影矩阵与模型矩阵相乘</span></span><br><span class="line">        Matrix4f projModelMatrix = transformation.getOrtoProjModelMatrix(gameItem, ortho);</span><br><span class="line">        hudShaderProgram.setUniform(<span class="string">"projModelMatrix"</span>, projModelMatrix);</span><br><span class="line">        hudShaderProgram.setUniform(<span class="string">"colour"</span>, gameItem.getMesh().getMaterial().getAmbientColour());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染HUD元素</span></span><br><span class="line">        mesh.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hudShaderProgram.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们遍历了HUD的所有元素，并将与每个元素关联的模型矩阵和正投影矩阵相乘。正投影矩阵在每次<code>render</code>调用时被刷新（因为屏幕大小可以改变），并且通过如下方式计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Matrix4f <span class="title">getOrthoProjectionMatrix</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> top)</span> </span>&#123;</span><br><span class="line">    orthoMatrix.identity();</span><br><span class="line">    orthoMatrix.setOrtho2D(left, right, bottom, top);</span><br><span class="line">    <span class="keyword">return</span> orthoMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>game</code>包中，我们将创建一个<code>Hud</code>类，它实现了<code>IHud</code>接口，并在构造函数接收一个文本用于在内部创建<code>TextItem</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.game;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector4f;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.GameItem;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.IHud;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.TextItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hud</span> <span class="keyword">implements</span> <span class="title">IHud</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FONT_COLS = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FONT_ROWS = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FONT_TEXTURE = <span class="string">"/textures/font_texture.png"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GameItem[] gameItems;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TextItem statusTextItem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hud</span><span class="params">(String statusText)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem = <span class="keyword">new</span> TextItem(statusText, FONT_TEXTURE, FONT_COLS, FONT_ROWS);</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.getMesh().getMaterial().setColour(<span class="keyword">new</span> Vector4f(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        gameItems = <span class="keyword">new</span> GameItem[]&#123;statusTextItem&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusText</span><span class="params">(String statusText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.setText(statusText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GameItem[] getGameItems() &#123;</span><br><span class="line">        <span class="keyword">return</span> gameItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSize</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.statusTextItem.setPosition(<span class="number">10f</span>, window.getHeight() - <span class="number">50f</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>DummyGame</code>类中我们创建该类的实例，用默认文本初始化它，最后得到如下所示的东西。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_result.png" alt="文本渲染结果"></p><p>在<code>Texture</code>类中，我们可以通过修改纹理的过滤来提高文本的可读性(如果你想要缩放文本的话，你需要注意)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure><p>但是例子还没有完成。如果你要缩放，使文本与立方体重叠时，就会看到这样的效果。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_opaque.png" alt="背景不透明的文本"></p><p>绘制的文本背景不透明。为了实现背景透明，我们必须明确启用混合(<code>Blend</code>)，这样就可以使用Alpha量。我们将在<code>Window</code>类中用下面的代码设置其他初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持透明背景</span></span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure><p>现在你可以看到文本以透明背景绘制了。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_transparent.png" alt="透明背景的文本"></p><h2 id="完成HUD"><a href="#完成HUD" class="headerlink" title="完成HUD"></a>完成HUD</h2><p>现在我们已经渲染了文本，但还可以向HUD添加更多的元素。我们将添加一个根据摄像机朝向旋转的指针。现在，我们将向<code>Hud</code>类添加一个新的<code>GameItem</code>，它将有一个指针的模型。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/compass.png" alt="指针"></p><p>指针的模型是.obj文件，但它不会关联任何纹理，相反，它只有背景颜色。所以我们需要修改HUD的片段着色器，来检测是否使用纹理。我们将通过设置一个名为<code>hasTexture</code>的新Uniform来实现它。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> mvPos;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> colour;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> hasTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( hasTexture == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = colour * <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = colour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要添加指针到HUD上，我们只需要在<code>Hud</code>类中创建一个新的<code>GameItem</code>实例。它加载指针模型，并将其添加到数组中。现在，我们需要放大指针。因为它在屏幕坐标中渲染，所以通常你需要放大它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建指针</span></span><br><span class="line">Mesh mesh = OBJLoader.loadMesh(<span class="string">"/models/compass.obj"</span>);</span><br><span class="line">Material material = <span class="keyword">new</span> Material();</span><br><span class="line">material.setAmbientColour(<span class="keyword">new</span> Vector4f(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">mesh.setMaterial(material);</span><br><span class="line">compassItem = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">compassItem.setScale(<span class="number">40.0f</span>);</span><br><span class="line"><span class="comment">// 进行旋转变换，使它转换到屏幕坐标系</span></span><br><span class="line">compassItem.setRotation(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">180f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个数组，用于储存HUD组件</span></span><br><span class="line">gameItems = <span class="keyword">new</span> GameItem[]&#123;statusTextItem, compassItem&#125;;</span><br></pre></td></tr></table></figure><p>还要注意的是，为了使罗盘向上指，我们需要旋转180°，因为模型通常倾向于使用OpenGL空间坐标系。如果我们要求使用屏幕坐标，它会指向下方。<code>Hud</code>类还提供一个方法来更新指针的指向，这也必须要考虑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateCompass</span><span class="params">(<span class="keyword">float</span> angle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.compassItem.setRotation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">180</span> + angle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>DummyGame</code>类中，每当摄像机移动时，我们需要更新角度。我们需要使用Y角旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据鼠标更新摄像机            </span></span><br><span class="line"><span class="keyword">if</span> (mouseInput.isRightButtonPressed()) &#123;</span><br><span class="line">    Vector2f rotVec = mouseInput.getDisplVec();</span><br><span class="line">    camera.moveRotation(rotVec.x * MOUSE_SENSITIVITY, rotVec.y * MOUSE_SENSITIVITY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新HUD指针</span></span><br><span class="line">    hud.rotateCompass(camera.getRotation().y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会看到这样的东西(记住它只是个例子，在实际的游戏中，你可能想使用一些纹理来更改指针的外观)。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/hud_compass.png" alt="有指针的HUD"></p><h2 id="再谈文本渲染"><a href="#再谈文本渲染" class="headerlink" title="再谈文本渲染"></a>再谈文本渲染</h2><p>在回顾其他主题之前，让我们再谈谈之前介绍的文本渲染方法。该方案非常简单和方便地介绍了渲染HUD所涉及的概念，但它有一些问题：</p><ul><li>它不支持非拉丁字符。</li><li>如果你想使用多种字体，则需要为每种字体创建单独的纹理文件。此外，改变文本大小的唯一方法是缩放，这会导致渲染文本的质量较差，或者需要创建额外的纹理文件。</li><li>最重要的是，大多数字体中的字符之间的大小并不同，而我们将字体纹理分割成同样大小的元素。我们使用了<a href="https://en.wikipedia.org/wiki/Monospaced_font" target="_blank" rel="noopener">Monospaced</a>风格(即所有字符具有相同的宽度)的“Consolas”字体，但如果使用非Monospaced的字体，就会看到字符之间恼人的空白。</li></ul><p>我们需要更改方法，提供一种更灵活的渲染文本方式。如果你思考一下，整个想法是可行的，也就是通过单独渲染每个字符的矩形来渲染文本。这里的问题就是该如何生成纹理。我们需要通过系统中可用的字体动态地生成这些纹理。</p><p>这就需要<code>java.awt.Font</code>出马了，我们将通过指定字体系列和大小动态地绘制每一个字符来生成纹理。该纹理的使用方式与之前描述的相同，但它将完美地解决上述所有问题。我们将创建一个名为<code>FontTexture</code>的新类，该类将接受<code>Font</code>实例和字符集名称，并将动态地创建包含所有可用字符的纹理。下面是构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FontTexture</span><span class="params">(Font font, String charSetName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.font = font;</span><br><span class="line">    <span class="keyword">this</span>.charSetName = charSetName;</span><br><span class="line">    charMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    buildTexture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要处理非拉丁字符问题，指定字符集和字体，我们将创建一个包含所有可渲染字符的<code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getAllAvailableChars</span><span class="params">(String charsetName)</span> </span>&#123;</span><br><span class="line">    CharsetEncoder ce = Charset.forName(charsetName).newEncoder();</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; Character.MAX_VALUE; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ce.canEncode(c)) &#123;</span><br><span class="line">            result.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看看实际创建纹理的<code>buildTexture</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildTexture</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用FontMetrics获取每个字符信息</span></span><br><span class="line">    BufferedImage img = <span class="keyword">new</span> BufferedImage(<span class="number">1</span>, <span class="number">1</span>, BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">    Graphics2D g2D = img.createGraphics();</span><br><span class="line">    g2D.setFont(font);</span><br><span class="line">    FontMetrics fontMetrics = g2D.getFontMetrics();</span><br><span class="line"></span><br><span class="line">    String allChars = getAllAvailableChars(charSetName);</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : allChars.toCharArray()) &#123;</span><br><span class="line">        <span class="comment">// 获取每个字符的大小，并更新图像大小</span></span><br><span class="line">        CharInfo charInfo = <span class="keyword">new</span> CharInfo(width, fontMetrics.charWidth(c));</span><br><span class="line">        charMap.put(c, charInfo);</span><br><span class="line">        width += charInfo.getWidth();</span><br><span class="line">        height = Math.max(height, fontMetrics.getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    g2D.dispose();</span><br></pre></td></tr></table></figure><p>我们首先通过创建创建临时图像来获得<code>FontMetrics</code>，然后遍历包含所有可用字符的<code>String</code>，并在<code>FontMetrics</code>的帮助下获取字体的宽度。我们把这些信息储存在一个<code>charMap</code>上，以字符作为<code>Map</code>的键。这样，我们就确定了纹理图像的大小(图像的高度等于所有字符的最大高度，而宽度等于所有字符的宽度总和)。<br><code>ChatSet</code>是一个内部类，它储存关于字符的信息(它的宽度和它在纹理图像中的起点)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharInfo</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startX = startX;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStartX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们将创建一个包含所有可用字符的图像，只需要在<code>BufferedImage</code>上绘制字符串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建与字符集相关的图像</span></span><br><span class="line">img = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">g2D = img.createGraphics();</span><br><span class="line">g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">g2D.setFont(font);</span><br><span class="line">fontMetrics = g2D.getFontMetrics();</span><br><span class="line">g2D.setColor(Color.WHITE);</span><br><span class="line">g2D.drawString(allChars, <span class="number">0</span>, fontMetrics.getAscent());</span><br><span class="line">g2D.dispose();</span><br></pre></td></tr></table></figure><p>我们正在生成一个包含所有字符的单行图像(可能不满足纹理大小应该为二的幂的前提，但是它仍适用于大多数现代显卡。在任何情况下，你都可以通过增加额外的空白来解决这个问题)。你甚至可以看到生成的图像，在代码之后，添加这样的一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageIO.write(img, IMAGE_FORMAT, <span class="keyword">new</span> java.io.File(<span class="string">"Temp.png"</span>));</span><br></pre></td></tr></table></figure><p>图像将被写入一个临时文件。该文件将包含一长条可用的所有字符，在白色背景下启用反走样绘制。</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/texture_font.png" alt="字体纹理"></p><p>最后只需要从那个图像创建一个<code>Texture</code>实例，我们只需使用PNG格式转储图像字节(这就是<code>Texture</code>类所需要的)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 将图像转储到字节缓冲区</span></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">        ImageIO.write(img, IMAGE_FORMAT, out);</span><br><span class="line">        out.flush();</span><br><span class="line">        is = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    texture = <span class="keyword">new</span> Texture(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能注意到，我们已经稍微修改了<code>Texture</code>类，以便可以使用一个接收<code>InputStream</code>的构造函数。现在我们只需要修改<code>TextItem</code>类，就可以在构造函数中接收<code>FontTexture</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TextItem</span><span class="params">(String text, FontTexture fontTexture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.fontTexture = fontTexture;</span><br><span class="line">    setMesh(buildMesh());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buildMesh</code>方法只需要稍稍改变矩形坐标和纹理坐标的设置，这是其中一个顶点的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> startx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numChars; i++) &#123;</span><br><span class="line">    FontTexture.CharInfo charInfo = fontTexture.getCharInfo(characters[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造由两个三角形组成的字符片段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上角顶点</span></span><br><span class="line">    positions.add(startx); <span class="comment">// x</span></span><br><span class="line">    positions.add(<span class="number">0.0f</span>); <span class="comment">// y</span></span><br><span class="line">    positions.add(ZPOS); <span class="comment">// z</span></span><br><span class="line">    textCoords.add( (<span class="keyword">float</span>)charInfo.getStartX() / (<span class="keyword">float</span>)fontTexture.getWidth());</span><br><span class="line">    textCoords.add(<span class="number">0.0f</span>);</span><br><span class="line">    indices.add(i*VERTICES_PER_QUAD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更多代码...</span></span><br><span class="line">  startx += charInfo.getWidth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在源代码中查看其他修改。下面的图片是一个大小为20的Arial字体的渲染结果：</p><p><img src="/2019/02/07/Lwjglbook-12-game-hud/text_rendered_improved.png" alt="改进后的文本"></p><p>你可以看到文本渲染的质量已经有了很大的提升，你可以用不同的字体和大小来渲染。这仍然有很大的改进空间(比如支持多行文本、特效等)，但这留给各位读者作为练习。</p><p>你可能还注意到，我们仍然能够缩放文本(通过着色器中的模型观察矩阵)。文本可能不需要，但对其他的HUD元素可能有用。</p><p>我们已经建立了所有的基础结构来为游戏创建一个HUD。现在，只剩一个问题，那就是创建所有的元素，传递相关信息给用户，并给他们一个专业的外观。</p><h2 id="OSX"><a href="#OSX" class="headerlink" title="OSX"></a>OSX</h2><p>如果你试图运行本章中的示例，以及下一个渲染文本的示例，则可能会发现应用程序和屏幕上没有显示任何内容。这是由于AWT和GLFW在OSX下相处得“很好”。但这和AWT有什么关系呢？我们使用的是<code>Font</code>类，它属于AWT，如果要实例化它，AWT也需要初始化。在OSX中，AWT试图在主线程运行，但GLFW也需要这样。这就是造成这种混乱的原因。</p><p>为了能够使用<code>Font</code>类，GLFW必须在AWT之前初始化，并且示例需要以Headless模式运行。你需要在任何东西被初始化之前设置这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.awt.headless"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>你也许会得到一个警告，但示例成功运行了。</p><p>一个更简洁的方法是使用<a href="https://github.com/nothings/stb/" target="_blank" rel="noopener">stb</a>库来渲染文本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十一章 要有更多的光</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/</id>
    <published>2019-02-07T09:20:29.000Z</published>
    <updated>2019-02-27T14:42:51.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter11" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter11</a></p><p>英文标题：Let there be even more light</p></blockquote><p>在本章中，我们将实现在前面章节中介绍的其他类型的光。我们先从平行光源开始。</p><h2 id="平行光源"><a href="#平行光源" class="headerlink" title="平行光源"></a>平行光源</h2><p>平行光照击中所有物体的平行射线都来自同一方向，因此它用来模拟遥远但具有高光强的光源，比如太阳。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/directional_light.png" alt="平行光源"></p><p>平行光源的另一个特点是它不受衰减的影响。再想一想太阳光，所有被光线照射的地球上的物体都以相同强度被照射，地球上的物体离太阳的距离之大，以至于它们之间的相对位置是影响的。事实上，平行光源被定义为放在无限远处的光源，如果它受到衰减的影响，它将对任何物体都没有光照(它对颜色的影响将等于0)。 </p><p>此外，平行光源也由漫反射和镜面光分量组成，与点光源的唯一区别在于它没有位置，而有方向，并且它不受衰减的影响。让我们回到平行光属性的讨论，想象我们正在模拟太阳在三维世界中运动，下图显示了黎明、正午和黄昏时的光照方向。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/sun_directional_light.png" alt="太阳是一种平行光源"></p><p>上述位置的照明方向为：</p><ul><li>黎明: (-1, 0, 0)</li><li>正午: (0, 1, 0)</li><li>黄昏: (1, 0, 0)</li></ul><p>注意：你可能认为上面的坐标是位置坐标，但是它们是向量，方向，而不是位置。从数学的角度来看，向量和位置是不可区分的，它们有着完全不同的含义。</p><p>但是，我们如何定义这个光位于无穷远处呢？答案是使用W坐标，也就是说，使用其次坐标然后将W坐标设置为0。</p><ul><li>黎明: (-1, 0, 0, 0)</li><li>正午: (0, 1, 0, 0)</li><li>黄昏: (1, 0, 0, 0)</li></ul><p>这就像我们在使用法线时一样。对于法线，我们将W分量设置为0，表示我们对位移不感兴趣，只对方向感兴趣。此外，当我们处理平行光照时，也需要这样做，摄像机的平移不应该影响平行光照的方向。</p><p>让我们开始编写和模拟我们的方向光。我们要做的第一件事是创建一个模型来储存它的属性。它只是另一个具有复制构造函数的普通的Java对象，并储存方向、颜色和强度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector3f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectionalLight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3f direction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> intensity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectionalLight</span><span class="params">(Vector3f color, Vector3f direction, <span class="keyword">float</span> intensity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.direction = direction;</span><br><span class="line">        <span class="keyword">this</span>.intensity = intensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectionalLight</span><span class="params">(DirectionalLight light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> Vector3f(light.getColor()), <span class="keyword">new</span> Vector3f(light.getDirection()), light.getIntensity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and settes beyond this point...</span></span><br></pre></td></tr></table></figure><p>正如你所看到的，我们使用<code>Vector3f</code>来储存方向。保持冷静，当将平行光照传递到着色器时，我们将处理W分量。顺便说一个，我们接下来要做的就是更新<code>ShaderProgram</code>来创建和更新储存平行光照的Uniform。</p><p>在片元着色器中，我们将定义一个结构体来模拟平行光源。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct DirectionalLight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> colour;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> intensity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个定义中，<code>ShaderProgram</code>类中的新方法也是直接了当的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDirectionalLightUniform</span><span class="params">(String uniformName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    createUniform(uniformName + <span class="string">".colour"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".direction"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".intensity"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, DirectionalLight dirLight)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">".colour"</span>, dirLight.getColor() );</span><br><span class="line">    setUniform(uniformName + <span class="string">".direction"</span>, dirLight.getDirection());</span><br><span class="line">    setUniform(uniformName + <span class="string">".intensity"</span>, dirLight.getIntensity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在需要使用Uniform。我们将通过<code>DummyGame</code>类控制太阳的角度来模拟它跨越天空。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/sun_movement.png" alt="太阳的移动"></p><p>我们需要更新光的方向，所以当黎明时(-90°)太阳在(-1, 0, 0)方向上，它的X坐标从-1逐渐增加到0，Y坐标逐渐从0增加到1。然后，X坐标增加到1，Y坐标又下降到0。这可以通过将X坐标设置为正弦角和Y坐标设置为余弦角来完成。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/sine_cosine.png" alt="正弦和余弦"></p><p>我们也会调整光照强度，当它离黎明越远，强度将越强，并且随着黄昏的临近而减弱。我们将通过设置强度为0来模拟夜晚。此外，我们还将调节颜色，使光线在黎明和黄昏时变得更红。这将在<code>DummyGame</code>类的<code>update</code>方法中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update directional light direction, intensity and colour</span></span><br><span class="line">lightAngle += <span class="number">1.1f</span>;</span><br><span class="line"><span class="keyword">if</span> (lightAngle &gt; <span class="number">90</span>) &#123;</span><br><span class="line">    directionalLight.setIntensity(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lightAngle &gt;= <span class="number">360</span>) &#123;</span><br><span class="line">        lightAngle = -<span class="number">90</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lightAngle &lt;= -<span class="number">80</span> || lightAngle &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> factor = <span class="number">1</span> - (<span class="keyword">float</span>)(Math.abs(lightAngle) - <span class="number">80</span>)/ <span class="number">10.0f</span>;</span><br><span class="line">    directionalLight.setIntensity(factor);</span><br><span class="line">    directionalLight.getColor().y = Math.max(factor, <span class="number">0.9f</span>);</span><br><span class="line">    directionalLight.getColor().z = Math.max(factor, <span class="number">0.5f</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    directionalLight.setIntensity(<span class="number">1</span>);</span><br><span class="line">    directionalLight.getColor().x = <span class="number">1</span>;</span><br><span class="line">    directionalLight.getColor().y = <span class="number">1</span>;</span><br><span class="line">    directionalLight.getColor().z = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> angRad = Math.toRadians(lightAngle);</span><br><span class="line">directionalLight.getDirection().x = (<span class="keyword">float</span>) Math.sin(angRad);</span><br><span class="line">directionalLight.getDirection().y = (<span class="keyword">float</span>) Math.cos(angRad);</span><br></pre></td></tr></table></figure><p>然后，我们需要将平行光源传递给<code>Renderer</code>类中的<code>render</code>方法中的着色器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get a copy of the directional light object and transform its position to view coordinates</span></span><br><span class="line">DirectionalLight currDirLight = <span class="keyword">new</span> DirectionalLight(directionalLight);</span><br><span class="line">Vector4f dir = <span class="keyword">new</span> Vector4f(currDirLight.getDirection(), <span class="number">0</span>);</span><br><span class="line">dir.mul(viewMatrix);</span><br><span class="line">currDirLight.setDirection(<span class="keyword">new</span> Vector3f(dir.x, dir.y, dir.z));</span><br><span class="line">shaderProgram.setUniform(<span class="string">"directionalLight"</span>, currDirLight);</span><br></pre></td></tr></table></figure><p>正如你所看到的，我们需要变换光照向量到观察空间，但是我们将W分量设置为0，因为我们对变换不感兴趣。</p><p>现在，我们已经准备好在片元着色器上完成剩下的工作，因为顶点着色器不需要修改。之前已经说过，我们需要定义一个名为<code>DirectionalLight</code>的新结构体，来储存平行光源数据，所以需要一个新的Uniform类型。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> DirectionalLight directionalLight;</span><br></pre></td></tr></table></figure><p>我们需要重构代码，在前一章中，我们有一个叫做<code>calcPointLight</code>的函数，它负责计算漫反射和镜面反射分类，也使用衰减。但正如我们所说的，平行光照使用漫反射和镜面反射分量，但不受衰减影响，所以我们将创建一个名为<code>calcLightColour</code>新的函数，只计算那些内容。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcLightColour(<span class="type">vec3</span> light_colour, <span class="type">float</span> light_intensity, <span class="type">vec3</span> position, <span class="type">vec3</span> to_light_dir, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> diffuseColour = <span class="type">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">vec4</span> specColour = <span class="type">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Diffuse Light</span></span><br><span class="line">    <span class="type">float</span> diffuseFactor = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, to_light_dir), <span class="number">0.0</span>);</span><br><span class="line">    diffuseColour = diffuseC * <span class="type">vec4</span>(light_colour, <span class="number">1.0</span>) * light_intensity * diffuseFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specular Light</span></span><br><span class="line">    <span class="type">vec3</span> camera_direction = <span class="built_in">normalize</span>(camera_pos - position);</span><br><span class="line">    <span class="type">vec3</span> from_light_dir = -to_light_dir;</span><br><span class="line">    <span class="type">vec3</span> reflected_light = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(from_light_dir , normal));</span><br><span class="line">    <span class="type">float</span> specularFactor = <span class="built_in">max</span>( <span class="built_in">dot</span>(camera_direction, reflected_light), <span class="number">0.0</span>);</span><br><span class="line">    specularFactor = <span class="built_in">pow</span>(specularFactor, specularPower);</span><br><span class="line">    specColour = speculrC * light_intensity  * specularFactor * material.reflectance * <span class="type">vec4</span>(light_colour, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (diffuseColour + specColour);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>calcPointLight</code>方法将衰减应用到先前函数中计算的结果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcPointLight(PointLight light, <span class="type">vec3</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> light_direction = light.position - position;</span><br><span class="line">    <span class="type">vec3</span> to_light_dir  = <span class="built_in">normalize</span>(light_direction);</span><br><span class="line">    <span class="type">vec4</span> light_colour = calcLightColour(light.colour, light.intensity, position, to_light_dir, normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply Attenuation</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light_direction);</span><br><span class="line">    <span class="type">float</span> attenuationInv = light.att.constant + light.att.linear * <span class="built_in">distance</span> +</span><br><span class="line">        light.att.exponent * <span class="built_in">distance</span> * <span class="built_in">distance</span>;</span><br><span class="line">    <span class="keyword">return</span> light_colour / attenuationInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还将创建一个新的函数来计算平行光源的效果，它只调用<code>calcLightColour</code>方法。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcDirectionalLight(DirectionalLight light, <span class="type">vec3</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> calcLightColour(light.colour, light.intensity, position, <span class="built_in">normalize</span>(light.direction), normal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，<code>main</code>方法通过环境光和平行光的颜色分量来计算片元颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    setupColours(material, outTexCoord);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec4</span> diffuseSpecularComp = calcDirectionalLight(directionalLight, mvVertexPos, mvVertexNormal);</span><br><span class="line">    diffuseSpecularComp += calcPointLight(pointLight, mvVertexPos, mvVertexNormal); </span><br><span class="line"></span><br><span class="line">    fragColor = ambientC * <span class="type">vec4</span>(ambientLight, <span class="number">1</span>) + diffuseSpecularComp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样，现在我们可以模拟太阳在天空中的移动，就像这样(运动速度加快，不用等待太久就可以看到)。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/directional_light_result.png" alt="平行光照结果"></p><h2 id="聚光源"><a href="#聚光源" class="headerlink" title="聚光源"></a>聚光源</h2><p>现在我们将实现与点光源非常相似的光源，但是它发出的光被限制在三维锥体中。它模拟从焦点或者其他不向四面八方发射光的光源。聚光源具有和点光源一样的参数，但它还增加了两个新的参数，锥角和锥方向。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/spot_light.png" alt="聚光"></p><p>聚光源与点光源的计算方法相同，但有一些不同。从顶点位置到光源的矢量不在光锥内的点不受光照的影响。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/spot_light_ii.png" alt="聚光2"></p><p>该如何计算它是否在光锥里呢？我们需要在点光源和圆锥方向矢量(它们都归一化)之间再次做数量积。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/spot_light_calc.png" alt="聚光计算"></p><p>L和C向量之间的数量积等于：<script type="math/tex">\vec{L}\cdot\vec{C}=|\vec{L}|\cdot|\vec{C}|\cdot Cos(\alpha)</script>。在聚光源的定义中，我们储存锥角的余弦值，如果数量积高于该值，我们就知道它在光锥内部(想想余弦图，当α角为0°时，余弦将为1。在0°~180°时，角越小，余弦值越大)。</p><p>第二个区别是远离光源的点将接收更少的光，也就是说，衰减将更强。有几种计算方法，我们将选择一种简单的方法，通过将衰减与以下公式相乘：</p><script type="math/tex; mode=display">1 - (1-Cos(\alpha))/(1-Cos(cutOffAngle)</script><p>(在片元着色器中，我们没有传递角度，而是传递角的余弦值。你可以从0~1检查上面的公式，当角度为0时，余弦值为1。)</p><p>实现非常类似于其他的光源，我们需要创建一个名为<code>SpotLight</code>的类，设置适当的Uniform，将其传递给着色器并修改片元着色器。你可以查看本章的源代码。</p><p>当传递Uniform时，另一个重要的事情是变换不应该应用到光锥方向上，因为我们只对方向感兴趣。因此，和平行光源的情况一样，当转换到观察矩阵空间时，必须把w值设置为0。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/spot_light_sample.png" alt="聚光源示例"></p><h2 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h2><p>我们最终实现了所有类型的光源，但是目前每个类型的光源只能有一个。这对于环境光和平行光来说没问题，但是我们确实希望使用多个点光源和聚光源。我们需要修改片元着色器来接收光源列表，所以使用数组来储存这些数据。</p><p>在开始之前要注意的事情，是在GLSL中数组的长度必须在编译时设置，因此它必须足够大，以便在运行时能够容纳所有对象。第一件事情是定义一些常量来设置我们要使用的最大点光源数和聚光源数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">int</span> MAX_POINT_LIGHTS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">int</span> MAX_SPOT_LIGHTS = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>然后我们需要修改之前只储存一个点光源和一个聚光源的Uniform为数组。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> PointLight pointLights[MAX_POINT_LIGHTS];</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLights[MAX_SPOT_LIGHTS];</span><br></pre></td></tr></table></figure><p>在main函数中，我们只需要对这些数组进行迭代，以使用现有函数计算每个对象对颜色的贡献。我们可能不会像Uniform数组长度那样传递很多光，所以需要控制它。有很多可行的方法，但这可能不适用于旧的显卡，最终我们将检查光强度(在数组中的空位的对象，光强为0)。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_POINT_LIGHTS; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( pointLights[i].intensity &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        diffuseSpecularComp += calcPointLight(pointLights[i], mvVertexPos, mvVertexNormal); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAX_SPOT_LIGHTS; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( spotLights[i].pl.intensity &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        diffuseSpecularComp += calcSpotLight(spotLights[i], mvVertexPos, mvVertexNormal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们需要在<code>Render</code>类中创建这些Uniform。当我们使用数组时，我们需要为列表中的每个元素创建一个Uniform。例如，对于<code>pointLights</code>数组，我们需要创建名为<code>pointLights[0]</code>、<code>pointLights[1]</code>之类的Uniform。当然，这也适用于结构体属性，所以我们将创建<code>pointLights[0].colour</code>、<code>pointLights[1].colour</code>等等。创建这些Uniform的方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPointLightListUniform</span><span class="params">(String uniformName, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        createPointLightUniform(uniformName + <span class="string">"["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSpotLightListUniform</span><span class="params">(String uniformName, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        createSpotLightUniform(uniformName + <span class="string">"["</span> + i + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也需要方法来设置这些Uniform的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, PointLight[] pointLights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numLights = pointLights != <span class="keyword">null</span> ? pointLights.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numLights; i++) &#123;</span><br><span class="line">        setUniform(uniformName, pointLights[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, PointLight pointLight, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">"["</span> + pos + <span class="string">"]"</span>, pointLight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, SpotLight[] spotLights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numLights = spotLights != <span class="keyword">null</span> ? spotLights.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numLights; i++) &#123;</span><br><span class="line">        setUniform(uniformName, spotLights[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, SpotLight spotLight, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">"["</span> + pos + <span class="string">"]"</span>, spotLight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要更新<code>Render</code>类来接收点光源和聚光源列表，并相应地修改<code>DummyGame</code>类来创建这些列表。最后看起来就像这样。</p><p><img src="/2019/02/07/Lwjglbook-11-let-there-be-even-more-light/multiple_lights.png" alt="多光源"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第十章 要有光</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-10-let-there-be-light/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-10-let-there-be-light/</id>
    <published>2019-02-07T09:13:29.000Z</published>
    <updated>2019-02-27T14:42:51.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter10" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter10</a></p><p>英文标题：Let there be light</p></blockquote><p>在本章中，我们将学习如何为我们的3D游戏引擎添加光照。我们不会去实现一个完美的物理光照模型，因为抛开复杂性不说，它还需要巨量的计算机资源，相反我们只需要一个近似的、像样的光照效果。我们将使用一种名为 <strong>Phong</strong> 的着色算法（由Bui Tuong Phong开发）。另一个需要注意的是，我们将只模拟灯光，但我们不会模拟这些灯光所产生的阴影（这将在其他章节中完成）。</p><p>在开始之前，首先定义几个光源种类：</p><ul><li><strong>点光源(Point Light)</strong>：这种光源模拟的是一个由点向空间各个方向均匀散射的光源</li><li><strong>聚光源(Spot Light)</strong>：这种光源模拟从空间中的点发射的光源，但不是在所有方向上发射，而是限定在了一个锥形方向上</li><li><strong>平行光源(Directional Light)</strong>：这种光源模拟了太阳光，3D场景中的所有物体都会受到来自特定方向的平行光线的照射。无论物体是近抑或是远，光线总是以一定角度照射在物体上的。</li><li><strong>环境光(Ambient Light)</strong>：这种类型的光源来自空间的任何地方，并以相同的强度照亮所有物体。</li></ul><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/light_types.png" alt="光照类型"></p><p>因此，为了模拟光，我们需要考虑光源类型，以及光的位置和其他一些参数，如颜色。当然，我们还必须考虑物体如何受光照影响以及吸收和反射光。</p><p>Phong着色算法将模拟光线对我们模型中每个点的影响，即对每个顶点的影响。这就是为什么它被称为局部光照模型的原因，这也是该算法不能计算阴影的原因，它只会计算应用到每个顶点的光，而不考虑顶点是否在挡光物体的后面。我们将在后面的章节中解决这个问题。但是，正因为如此，它是一种非常简单快速的算法，并且可以提供非常好的效果。我们将在这里实现一个没有深入考虑材质影响的简化版本。</p><p>Phong算法提供了三种光照分量：</p><ul><li><strong>环境光(Ambient Light)</strong>：模拟来自任何地方的光，这将为我们提供（需要对应强度值）未被任何光线照射的区域，就像背景光。</li><li><strong>漫反射(Diffuse Reflectance)</strong>：考虑到面对光源的表面更亮。</li><li><strong>镜面反射(Specular Reflectance)</strong>：模拟光线如何在抛光表面或金属表面上反射。</li></ul><p>最后，我们还要知道的规律是，乘以分配给片段的颜色，将根据接收的光线将该颜色变得更亮或更暗。我们令$A$为环境光、$D$为漫反射、$S$为镜面高光。根据以上规律对于分量的加法表示如下：</p><script type="math/tex; mode=display">L = A + D + S</script><p>这些分量其实就是颜色，也就是每个光分量所贡献的颜色分量。这是因为光分量不仅会提供一定程度的强度，还会改变模型的颜色。在我们的片段着色器中，我们只需将该光的颜色与原始片段颜色（从纹理或基色获得）相乘即可。</p><p>我们也可以为相同的材质分配不同的颜色，这些颜色将用于环境光，漫反射和镜面反射。因此，这些分量将由材质相关的颜色而受到调整。如果材质具有纹理，我们将简单地为每个分量使用单个纹理。</p><p>所以对于非纹理材质的最终颜色将是：$L = A <em> 环境光色 + D </em> 漫反射的颜色 + S * 镜面反射的颜色$</p><p>对于有纹理材质的最终颜色将是：</p><script type="math/tex; mode=display">L = A * 材质颜色 + D * 材质颜色 + S * 材质颜色</script><h2 id="环境光分量"><a href="#环境光分量" class="headerlink" title="环境光分量"></a>环境光分量</h2><p>让我们来看看第一个分量，即环境光分量，它只是一个常量值，会使我们的所有对象变得更亮或更暗。我们可以使用它来模拟特定时间段内的光线（黎明，黄昏等），也可以用它来添加一些光线，这些光线不直接被光线照射，但可以以简单的方式被间接光线照射（比如反射）。</p><p>环境光是运算最简单的分量，我们只需要传递一种颜色，并乘以基本颜色，以调整该基本颜色。假如我们已经确定片段的颜色是$（1.0，0.0，0.0）$，即红色。如果没有环境光时，它将显示为完全红色的片段。如果我们将环境光设置为$（0.5,0.5,0.5）$，则最终颜色将为$（0.5,0,0）$，其实就是变暗的红色。这种光会以同样的方式使所有片段变暗（说光照暗了物体似乎有点奇怪，实际上这就是我们得到的效果）。除此之外，如果光色的RGB分量不相同，它还可以为片段添加一些颜色，所以我们只需要一个向量来调节环境光强度和颜色。</p><h2 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h2><p>现在我们来谈谈漫反射。它模拟了这样的规律，即与光源垂直的面看起来比以更接近光的角度接收光的面更亮。一个物体接收的光线越多，其光密度（让我这样称呼）就越高。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/diffuse_light.png" alt="漫反射光"></p><p>但是，我们该如何计算它？ 你还记得上一章我们介绍过的法线概念吗？法线是垂直于平面并且长度为1的向量。因此，让我们在上图中绘制三个点的法线，如你所见，每个点的法线将是垂直于每个点的切平面的向量。我们不去绘制来自光源的光线，而是绘制从每个点到光源（即相反的方向）的向量。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/diffuse_light_normals.png" alt="法线与光的方向"></p><p>正如你所看到的，$P1$点的法线$N1$，与指向光源的向量平行，该法线的方向与光线的方向相反（$N1$已经被平移标记，以便你可以看到它，但它在数学上是等价的）。$P1$相对于指向光源的向量，其角度等于$0$。因为它的平面垂直于光源，所以$P1$将是最亮的点。</p><p>$P2$点的法线$N2$，与指向光源的向量的夹角约为30度，所以它应该比$P1$更暗。最后，$P3$的法线$N3$也与指向光源的向量平行，但两个向量的方向相反。$P3$与指向光源的向量的角度为180度，所以根本不应该获得任何光线。</p><p>所以，看起来我们得到了一个计算某个点的光照强度的好方法，光强与该点的法线和该点指向光源的向量之间的夹角大小有关。但我们具体要怎么计算它呢？</p><p>有一个我们可以使用的数学运算————数量积（又称为点积）。该操作需要两个向量并产生一个数字（标量），如果它们之间的角度较小，则生成一个正数；如果它们之间的角度很大，则生成一个负数。如果两个向量都被归一化，即两者的长度都等于1，那么数量积的结果将介于$-1$和$1$之间。如果两个向量的方向相同（即夹角为$0$），则数量积为1；如果两个向量夹角为直角，则它的值为$0$；如果两个向量的方向相反，则为$-1$。</p><p>我们定义两个向量，$v1$和$v2$，并以<script type="math/tex">α</script>作为它们之间的夹角。数量积的定义如下：</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/dot_product.png" alt="数量积"></p><p>如果两个向量都归一化，即它们的长度，它们的模块将等于1，它们的数量积即为夹角的余弦值。我们同样使用该运算来计算漫反射分量。</p><p>所以我们需要计算指向光源的向量。我们如何做到这一点？ 假如我们有每个点的位置（即顶点位置），我们有光源的位置。首先，这两个坐标必须位于相同的坐标系中。为了简化，让我们假设它们都处于世界坐标系中，那么这些位置是指向顶点位置（$VP$）和光源（$VS$）的矢量的坐标，如下图所示：</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/diffuse_calc_i.png" alt="漫反射光照运算"></p><p>如果我们从$VP$中减去$VS$，我们就得到了$L$向量。</p><p>现在，我们可以在指向光源的矢量和法线之间做数量积，因为Johann Lambert是第一个提出这种关系来模拟平面亮度的，所以该乘积被称为兰伯特项。</p><p>让我们总结一下，我们定义以下变量：</p><ul><li>$vPos$ ：我们的顶点在模型视图空间坐标中的位置。</li><li>$lPos$：视图空间坐标中的光线位置。</li><li>$intensity$：光的强度（从0到1）。</li><li>$lCourour$：光的颜色。</li><li>$normal$：顶点法线。</li></ul><p>首先，我们需要计算从当前位置指向光源的向量：$toLightDirection = lPos - vPos$。该操作的结果需要进行归一化。</p><p>然后我们需要计算漫反射因子（标量）：$diffuseFactor = normal \cdot toLightDirection$。计算两个向量之间的数量积，我们希望它在$-1$和$1$之间，所以两个向量都需要进行归一化。颜色需要在$0$到$1$之间，所以如果值低于$0$，我们将它设置为$0$。</p><p>最后，我们只需要通过漫反射因子和光强来调制光色：</p><script type="math/tex; mode=display">color = diffuseColour * lColour * diffuseFactor * intensity</script><h2 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h2><p>现在我们来看看镜面反射，但首先我们需要知道光线是如何反射的。当光照射到一个平面时，它的一部分被吸收，另一部分被反射，如果你还记得你的物理课内容，反射就是光子从物体反弹回来。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/light_reflection.png" alt="反射光"></p><p>当然，平面不是完全抛光的，如果你近距离仔细观察，你会看到很多不平整的地方。除此之外，有许多射线光（实际上是光子），会撞击这个平面，并且会以各种各样的角度进行反射。因此，我们看到的就像是一束光照射一平面并散射出去。也就是说，光线在撞击平面时会发散，这就是我们之前讨论过的漫反射分量。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/surface.png" alt="平面"></p><p>但是，当光线照射抛光平面时，例如金属，光线会受到较低扩散的影响，并且大部分光线会反射到相反的方向。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/polished_surface.png" alt="抛光平面"></p><p>这就是镜面反射模型，它取决于材质特性。关于镜面反射，要注意的一点是，只有当摄像机处于适当的位置时，即反射光的发射区域内，反射光才可见。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/specular_lightining.png" alt="镜面高光"></p><p>解释了反射的机制，我们接下来准备计算这个分量。首先，我们需要一个从光源指向顶点的向量。当我们计算漫反射分量时，我们使用的是方向与之相反的向量，它指向的是光源。$toLightDirection$，所以让我们将其计算为$fromLightDirection = -(toLightDirection)$。</p><p>然后我们需要计算正常情况下由$fromLightDirection$到平面所产生的反射光。有一个名为reflect的GLSL函数。所以，$reflectLight = reflect(fromLightSource, normal)$。</p><p>我们还需要一个指向相机的向量，并将其命名为$cameraDirection$，然后计算出相机位置和顶点位置之间的差值：$cameraDirection = cameraPos - vPos$。相机位置向量和顶点位置需要处于相同的坐标系中，并且生成的向量需要进行归一化。下图概述了我们目前计算的主要分量：</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/specular_lightining_calc.png" alt="镜面高光运算"></p><p>现在我们需要计算光强，即$specularFactor$。如果$cameraDirection$和$reflectLight$向量指向相同的方向，该值就越高，如果它们方向相反其值则越低。为了计算这个值我们将再次使用数量积。$specularFactor = cameraDirection \cdot reflectLight$。我们只希望这个值在$0$和$1$之间，所以如果它低于$0$，就设置它为0。</p><p>我们还需要考虑到，如果相机指向反射光锥，则该光更强烈。这可以通过计算$specularFactor$的$specularPower$幂来实现，其中$specularPower$为给定的参数：</p><p><script type="math/tex">specularFactor = specularFactor ^ {specularPower}</script>。</p><p>最后，我们需要对材质的反射率进行建模，反射率将影响反射光的强度，这将使用一个名为reflectance的参数。所以镜面反射分量的颜色分量为：<script type="math/tex">specularColour * lColour * reflectance * specularFactor * intensity</script>。</p><h2 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h2><p>我们现在知道如何计算这三个分量了，这些分量可以帮助我们用环境光模拟点光源。但是我们的光照模型还不完整，物体反射的光与光的距离无关，我们需要模拟光线衰减。</p><p>衰减是一个有关距离和光的函数。光的强度与距离的平方成反比。这很容易理解，随着光线的传播，其能量沿着球体表面分布，其半径等于光线行进的距离，而球的表面与其半径的平方成正比。我们可以用下式来计算衰减因子：$1.0 /(atConstant + atLineardist + atExponentdist ^ {2})$。</p><p>为了模拟衰减，我们只需要将衰减因子乘以最终的颜色即可。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在我们可以开始编程实现上面描述的所有概念，我们将从着色器开始。大部分工作将在片段着色器中完成，但我们还需要将顶点着色器中的一些数据传递给它。在前一章中，片段着色器只是接收纹理坐标，现在我们还将传递两个参数：</p><ul><li>已转换为模型视图空间坐标系并已归一化的顶点法线。</li><li>已转换为模型视图空间坐标系的顶点位置。</li></ul><p>这是顶点着色器的代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> vertexNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexNormal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> mvVertexPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> mvPos = modelViewMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * mvPos;</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">    mvVertexNormal = <span class="built_in">normalize</span>(modelViewMatrix * <span class="type">vec4</span>(vertexNormal, <span class="number">0.0</span>)).xyz;</span><br><span class="line">    mvVertexPos = mvPos.xyz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们继续讲解片段着色器之前，必须强调一个非常重要的概念。从上面的代码可以看到，<code>mvVertexNormal</code>，该变量包含已转换为模型视图空间坐标的顶点法线。这是通过将<code>vertexNormal</code>乘上<code>modelViewMatrix</code>来实现的，就像顶点位置一样。但有一个细微的差别，该顶点法线的w分量在乘以矩阵之前被设置为0：<code>vec4（vertexNormal，0.0）</code>。我们为什么要这样做呢 ？因为我们希望法线可以旋转和缩放，但我们不希望它被平移，所以我们只对它的方向感兴趣，而不是它的位置。而这是通过将w分量设置为0来实现的，这也是是使用齐次坐标的优点之一，通过设置w分量，我们可以控制应用了哪些变换。你可以用手做矩阵乘法，看看为什么是这样。</p><p>现在我们可以开始在片段着色器中干点事情了，除了将来自顶点着色器的值声明为输入参数之外，我们将定义一些有用的结构体来模拟光照和材质特性。首先，我们将定义用于模拟光的结构。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Attenuation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> exponent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PointLight</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> colour;</span><br><span class="line">    <span class="comment">// 光源位置是在视图坐标系中的</span></span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">float</span> intensity;</span><br><span class="line">    Attenuation att;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>点光源由一个颜色，一个位置，以及一个介于$0$和$1$之间的数字来定义，这个数字模拟光的强度以及一组衰减方程的参数。</p><p>模拟材质特性的结构体是：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Material</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> ambient;</span><br><span class="line">    <span class="type">vec4</span> diffuse;</span><br><span class="line">    <span class="type">vec4</span> specular;</span><br><span class="line">    <span class="type">int</span> hasTexture;</span><br><span class="line">    <span class="type">float</span> reflectance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>材质由一组颜色定义（假如我们不使用纹理为片段着色）：</p><ul><li>用于环境分量的颜色。</li><li>用于漫反射分量的颜色。</li><li>用于镜面反射的颜色。</li></ul><p>材质也由一个标志来定义，该标志控制它是否具有相关的纹理以及反射率指数。我们将在片段着色器中使用以下uniform。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> ambientLight;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> specularPower;</span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLight;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> camera_pos;</span><br></pre></td></tr></table></figure><p>我们用新建的uniform设置下面的几个变量：</p><ul><li>环境光：包含会以同样方式影响每个片段的颜色。</li><li>镜面反射强度（在讨论镜面反射光时提供的公式中使用的指数）。</li><li>一个点光源。</li><li>材质特性。</li><li>相机在视图空间坐标系中的位置。</li></ul><p>我们还将定义一些全局变量，它们将保存要在环境、漫反射和镜面反射中使用的材质颜色分量。我们使用这些变量是因为如果分量具有纹理，我们将对所有分量使用相同的颜色，并且我们不希望进行冗余的纹理查找。这些变量是这样定义的：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> ambientC;</span><br><span class="line"><span class="type">vec4</span> diffuseC;</span><br><span class="line"><span class="type">vec4</span> speculrC;</span><br></pre></td></tr></table></figure><p>我们现在可以定义一个函数，来根据材质特性设置这些变量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setupColours(Material material, <span class="type">vec2</span> textCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (material.hasTexture == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ambientC = <span class="built_in">texture</span>(texture_sampler, textCoord);</span><br><span class="line">        diffuseC = ambientC;</span><br><span class="line">        speculrC = ambientC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ambientC = material.ambient;</span><br><span class="line">        diffuseC = material.diffuse;</span><br><span class="line">        speculrC = material.specular;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要定义一个函数，以点光源、顶点位置及其法线为输入并返回前面描述的漫反射和镜面反射计算的颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> calcPointLight(PointLight light, <span class="type">vec3</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> diffuseColour = <span class="type">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">vec4</span> specColour = <span class="type">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">vec3</span> light_direction = light.position - position;</span><br><span class="line">    <span class="type">vec3</span> to_light_source  = <span class="built_in">normalize</span>(light_direction);</span><br><span class="line">    <span class="type">float</span> diffuseFactor = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, to_light_source ), <span class="number">0.0</span>);</span><br><span class="line">    diffuseColour = diffuseC * <span class="type">vec4</span>(light.colour, <span class="number">1.0</span>) * light.intensity * diffuseFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面反射</span></span><br><span class="line">    <span class="type">vec3</span> camera_direction = <span class="built_in">normalize</span>(-position);</span><br><span class="line">    <span class="type">vec3</span> from_light_source = -to_light_source;</span><br><span class="line">    <span class="type">vec3</span> reflected_light = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(from_light_source, normal));</span><br><span class="line">    <span class="type">float</span> specularFactor = <span class="built_in">max</span>( <span class="built_in">dot</span>(camera_direction, reflected_light), <span class="number">0.0</span>);</span><br><span class="line">    specularFactor = <span class="built_in">pow</span>(specularFactor, specularPower);</span><br><span class="line">    specColour = speculrC * specularFactor * material.reflectance * <span class="type">vec4</span>(light.colour, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 衰减</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light_direction);</span><br><span class="line">    <span class="type">float</span> attenuationInv = light.att.constant + light.att.linear * <span class="built_in">distance</span> +</span><br><span class="line">        light.att.exponent * <span class="built_in">distance</span> * <span class="built_in">distance</span>;</span><br><span class="line">    <span class="keyword">return</span> (diffuseColour + specColour) / attenuationInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的代码相对比较直白简单，它只是计算了漫反射分量的颜色，另一个是计算镜面反射的颜色，并通过光线在行进到我们正在处理的顶点时受到的衰减来调制它们。</p><p>请注意，顶点坐标是位于视图空间中的。在计算镜面反射时，我们必须指出视角，即相机。这可以这样做：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> camera_direction = <span class="built_in">normalize</span>(camera_pos - position);</span><br></pre></td></tr></table></figure><p>但是，由于<code>位置</code>在视图空间中，相机位置始终位于原点，即$（0,0,0）$，所以我们如下计算它：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> camera_direction = <span class="built_in">normalize</span>(<span class="type">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) - position);</span><br></pre></td></tr></table></figure><p>可以如此简化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> camera_direction = <span class="built_in">normalize</span>(-position);</span><br></pre></td></tr></table></figure><p>有了前面的函数，定点着色器的主函数就变得非常简单了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    setupColours(material, outTexCoord);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec4</span> diffuseSpecularComp = calcPointLight(pointLight, mvVertexPos, mvVertexNormal);</span><br><span class="line"></span><br><span class="line">    fragColor = ambientC * <span class="type">vec4</span>(ambientLight, <span class="number">1</span>) + diffuseSpecularComp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用setupColours函数将使用适当的颜色来设置变量ambientC、diffuseC和speculrC。然后，我们计算漫反射和镜面反射，并考虑衰减。为了方便，我们使用单个函数调用来完成此操作，如上所述。最终的颜色是通过添加环境光分量来计算的（将ambientC乘以环境光）。正如你所看到的，环境光不受衰减的影响。</p><p>在着色器中我们引入了一些需要进一步解释的新概念，定义结构体并将它们用作uniform。但我们要怎么传递这些结构体？首先，我们将定义两个新类，它们模拟点点光源和材质的特性，名为<code>PointLight</code>和<code>Material</code>。它们只是普通的POJO(普通的Java对象)，所以你可以在本书附带的源代码中查看它们。然后，我们需要在ShaderProgram类中创建新方法，首先要能够为点光源和材质结构创建uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPointLightUniform</span><span class="params">(String uniformName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    createUniform(uniformName + <span class="string">".colour"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".position"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".intensity"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".att.constant"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".att.linear"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".att.exponent"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMaterialUniform</span><span class="params">(String uniformName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    createUniform(uniformName + <span class="string">".ambient"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".diffuse"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".specular"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".hasTexture"</span>);</span><br><span class="line">    createUniform(uniformName + <span class="string">".reflectance"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，它非常简单，我们只为构成结构体的所有属性创建一个单独的uniform。现在我们需要创建另外两个方法来设置这些uniform的值，并且将使用参数<code>PointLight</code>和材质的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, PointLight pointLight)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">".colour"</span>, pointLight.getColor() );</span><br><span class="line">    setUniform(uniformName + <span class="string">".position"</span>, pointLight.getPosition());</span><br><span class="line">    setUniform(uniformName + <span class="string">".intensity"</span>, pointLight.getIntensity());</span><br><span class="line">    PointLight.Attenuation att = pointLight.getAttenuation();</span><br><span class="line">    setUniform(uniformName + <span class="string">".att.constant"</span>, att.getConstant());</span><br><span class="line">    setUniform(uniformName + <span class="string">".att.linear"</span>, att.getLinear());</span><br><span class="line">    setUniform(uniformName + <span class="string">".att.exponent"</span>, att.getExponent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, Material material)</span> </span>&#123;</span><br><span class="line">    setUniform(uniformName + <span class="string">".ambient"</span>, material.getAmbientColour());</span><br><span class="line">    setUniform(uniformName + <span class="string">".diffuse"</span>, material.getDiffuseColour());</span><br><span class="line">    setUniform(uniformName + <span class="string">".specular"</span>, material.getSpecularColour());</span><br><span class="line">    setUniform(uniformName + <span class="string">".hasTexture"</span>, material.isTextured() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    setUniform(uniformName + <span class="string">".reflectance"</span>, material.getReflectance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本章源代码中，你还将看到我们还修改了<code>Mesh</code>类来存放材质实例，并且我们创建了一个简单的示例，并在其中创建了一个可用“N”和“M”键控制移动的点光源，以显示点光源聚焦在反射率值高于0的网格上时是怎样的。</p><p>让我们回到片段着色器，正如我们所说的，我们需要另一种包含相机位置camera_pos的uniform。这些坐标必须位于视图空间中。通常我们将在世界空间坐标中设置光坐标，因此我们需要将它们乘以视图矩阵以便能够在着色器中使用它们，所以我们需要在<code>Transformation</code>类中创建一个新方法，该方法返回视图矩阵让我们转换光照坐标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得光源对象的副本并将它的坐标转换为视图坐标</span></span><br><span class="line">PointLight currPointLight = <span class="keyword">new</span> PointLight(pointLight);</span><br><span class="line">Vector3f lightPos = currPointLight.getPosition();</span><br><span class="line">Vector4f aux = <span class="keyword">new</span> Vector4f(lightPos, <span class="number">1</span>);</span><br><span class="line">aux.mul(viewMatrix);</span><br><span class="line">lightPos.x = aux.x;</span><br><span class="line">lightPos.y = aux.y;</span><br><span class="line">lightPos.z = aux.z; </span><br><span class="line">shaderProgram.setUniform(<span class="string">"pointLight"</span>, currPointLight);</span><br></pre></td></tr></table></figure><p>我们不会在这里引用整个源代码，因为如果这样这一章就太长了，对于解释概念并没有太多的作用。您可以在本书附带的源代码中查看它。</p><p><img src="/2019/02/07/Lwjglbook-10-let-there-be-light/lightning_result.png" alt="Lightning results"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitbo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第九章 加载更复杂的模型</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-09-loading-more-complex-models/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-09-loading-more-complex-models/</id>
    <published>2019-02-07T09:13:18.000Z</published>
    <updated>2019-02-27T14:42:51.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter9" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter9</a></p><p>英文标题：Loading more complex models</p></blockquote><p>在本章中，我们将学习加载在外部文件中定义的更复杂的模型。这些模型将由3D建模工具(例如<a href="https://www.blender.org/" target="_blank" rel="noopener">Blender</a>)创建。目前，我们是徒手创建模型，直接写代码定义它们的几何数组。在本章中，我们将学习如何以OBJ格式定义的模型。</p><p>OBJ(或者.obj)是Wavefront Technologies开发的一种几何定义开放文件格式，现已被广泛使用。OBJ文件储存构成3D模型的顶点、纹理坐标和多边形。这是一种相对简单的格式，因为它是基于文本格式的，每一行定义了一个元素(顶点、纹理坐标等)。</p><p>在.obj文件中，每行从一个标识符开始，标识元素的类型：</p><ul><li>以”#“开始的行是注释。</li><li>以”v”开始的行用坐标(x, y, z, w)定义一个几何顶点。例如：<code>v 0.155 0.211 0.32 1.0</code>。</li><li>以”vn”开始的行是用坐标(x, y, z)定义顶点法线(<code>Vertex normals</code>)。例如：<code>vn 0.71 0.21 0.82</code>。之后再讨论这个东西。</li><li>以”vt”开始的行定义纹理坐标。例如：<code>vt 0.500 1</code>。</li><li>以”f”开始的行定义了一个面。利用该行中的信息可以创建索引数组。我们将只处理面是三角形的情况。它可以有几种定义方式：<ul><li>它可以定义顶点位置(f v1 v2 v3)。例如：<code>f 6 3 1</code>。在这种情况下，这个三角形是由位置为6、3和1的几何顶点定义的(顶点索引总是从1开始)。</li><li>它可以定义顶点位置、纹理坐标和法线(f v1/t1/n1 v2/t2/n2 v3/t3/n3)。例如：<code>f 6/4/1 3/5/3 7/6/5</code>。第一部分的<code>v1/t1/n1</code>分别定义了坐标、纹理坐标和顶点法线。看到这个部分可以想到：选择几何顶点6、纹理坐标4和顶点法线1。</li></ul></li></ul><p>OBJ格式有更多的元素类型(如一对多多边形、定义材质等)。现在我们仅实现如上所述，我们的OBJ加载器将忽略其他元素类型。</p><p>但是什么是法线呢？让我们先定义它。当你有一个平面时，它的法线是垂直于该平面的向量，其长度等于1。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/normals.png" alt="法线"></p><p>正如你在上图中看到的，一个平面可以有两个法线，我们应该用哪一个呢？三维图形中的法线被用于光照，所以我们应该选择面向光源的法线。换句话说，我们应该选择指向模型外部的法线。</p><p>我们有一个有多边形、三角形组成的3D模型。每个三角形由三个顶点组成，三角形的法线向量是垂直于三角形表面的向量，其长度等于1。</p><p>顶点法线与特定顶点相关联，并且是周围三角形的法线的组合(当然它的长度等于1)。在这里你可以看到一个3D网格的顶点模型(取自<a href="https://en.wikipedia.org/wiki/Vertex_normal#/media/File:Vertex_normals.png" target="_blank" rel="noopener">维基百科</a>)</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/vertex_normals.png" alt="法线向量"></p><p>法线将会被用于光照。</p><p>让我们开始创建OBJ加载器。首先，我们将修改<code>Mesh</code>类，因为现在必须使用纹理。我们可能加载一些没有定义纹理坐标的OBJ文件，我们必须能够使用颜色而不是纹理渲染它们。这种情况下，面的定义就是这样的：<code>f v/n</code>。</p><p><code>Mesh</code>类现在有一个名为<code>colour</code>的新属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3f colour;</span><br></pre></td></tr></table></figure><p>并且构造函数不再需要<code>Texture</code>。取而代之的是，我们将为纹理和颜色属性提供<code>get</code>和<code>set</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mesh</span><span class="params">(<span class="keyword">float</span>[] positions, <span class="keyword">float</span>[] textCoords, <span class="keyword">float</span>[] normals, <span class="keyword">int</span>[] indices)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>当然，在<code>render</code>和<code>clear</code>方法中，在使用纹理之前，必须检查纹理是否为<code>null</code>。正如你在构造函数中看到的，现在需要一个名为<code>normals</code>的浮点数组。如何使用法线渲染？答案很简单，它将只是VAO里的另一个VBO，所以我们需要添加如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex normals VBO</span></span><br><span class="line">vboId = glGenBuffers();</span><br><span class="line">vboIdList.add(vboId);</span><br><span class="line">vecNormalsBuffer = MemoryUtil.memAllocFloat(normals.length);</span><br><span class="line">vecNormalsBuffer.put(normals).flip();</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vboId);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, vecNormalsBuffer, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">3</span>, GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在<code>render</code>方法中，我们必须启用这个VBO并在之后禁用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Draw the mesh</span></span><br><span class="line">glBindVertexArray(getVaoId());</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">glDrawElements(GL_TRIANGLES, getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore state</span></span><br><span class="line">glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glDisableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">glDisableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在已经完成了<code>Mesh</code>类的修改，我们可以修改代码来使用纹理坐标或固定的颜色。因此，我们需要修改片元着色器，像这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>  <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> colour;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> useColour;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( useColour == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(colour, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fragColor = <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，我们已经创建了两个新Uniform：</p><ul><li><code>colour</code>: 将储存基础颜色。</li><li><code>useColour</code>: 这是个标记，当你不想使用纹理时，它将被设置为1。</li></ul><p>在<code>Renderer</code>类中，我们需要创建这两个Uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create uniform for default colour and the flag that controls it</span></span><br><span class="line">shaderProgram.createUniform(<span class="string">"colour"</span>);</span><br><span class="line">shaderProgram.createUniform(<span class="string">"useColour"</span>);</span><br></pre></td></tr></table></figure><p>和其他Uniform一样，在<code>Renderer</code>类的<code>render</code>方法中，我们也需要为每个<code>GameItem</code>设置这些Uniform的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(GameItem gameItem : gameItems) &#123;</span><br><span class="line">    Mesh mesh = gameItem.getMesh();</span><br><span class="line">    <span class="comment">// Set model view matrix for this item</span></span><br><span class="line">    Matrix4f modelViewMatrix = transformation.getModelViewMatrix(gameItem, viewMatrix);</span><br><span class="line">    shaderProgram.setUniform(<span class="string">"modelViewMatrix"</span>, modelViewMatrix);</span><br><span class="line">    <span class="comment">// Render the mes for this game item</span></span><br><span class="line">    shaderProgram.setUniform(<span class="string">"colour"</span>, mesh.getColour());</span><br><span class="line">    shaderProgram.setUniform(<span class="string">"useColour"</span>, mesh.isTextured() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    mesh.render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以创建一个名为<code>OBJLoader</code>的新类，它将解析OBJ文件，并用其中的数据创建一个<code>Mesh</code>实例。你可能会在网上发现一些其他实现可能比这更有效，但我认为这个方案更容易理解。这是一个工具类，他将有一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mesh <span class="title">loadMesh</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br></pre></td></tr></table></figure><p>参数<code>fileName</code>是指定文件的名称，该文件必须包含在OBJ模型的类路径中。</p><p>我们在该方法中做的第一件事是读取文件内容并存储数组中的所有行。然后创建几个列表来保存顶点、纹理坐标、法线和面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = Utils.readAllLines(fileName);</span><br><span class="line"></span><br><span class="line">List&lt;Vector3f&gt; vertices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Vector2f&gt; textures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Vector3f&gt; normals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Face&gt; faces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>然后解析每一行，并根据起始标识符得到顶点位置、纹理坐标、顶点法线或面定义。最后重新整理这些数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">    String[] tokens = line.split(<span class="string">"\\s+"</span>);</span><br><span class="line">    <span class="keyword">switch</span> (tokens[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"v"</span>:</span><br><span class="line">            <span class="comment">// Geometric vertex</span></span><br><span class="line">            Vector3f vec3f = <span class="keyword">new</span> Vector3f(</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">1</span>]),</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">2</span>]),</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">3</span>]));</span><br><span class="line">            vertices.add(vec3f);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"vt"</span>:</span><br><span class="line">            <span class="comment">// Texture coordinate</span></span><br><span class="line">            Vector2f vec2f = <span class="keyword">new</span> Vector2f(</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">1</span>]),</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">2</span>]));</span><br><span class="line">            textures.add(vec2f);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"vn"</span>:</span><br><span class="line">            <span class="comment">// Vertex normal</span></span><br><span class="line">            Vector3f vec3fNorm = <span class="keyword">new</span> Vector3f(</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">1</span>]),</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">2</span>]),</span><br><span class="line">                Float.parseFloat(tokens[<span class="number">3</span>]));</span><br><span class="line">            normals.add(vec3fNorm);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"f"</span>:</span><br><span class="line">            Face face = <span class="keyword">new</span> Face(tokens[<span class="number">1</span>], tokens[<span class="number">2</span>], tokens[<span class="number">3</span>]);</span><br><span class="line">            faces.add(face);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Ignore other lines</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reorderLists(vertices, textures, normals, faces);</span><br></pre></td></tr></table></figure><p>在重新排序之前，让我们看看如何解析面的定义。我们创建了一个名为<code>Face</code>的类，它负责解析一个面的定义。一个<code>Face</code>是由索引组列表组成的，现在，因为我们正在处理三角形，所以我们将有三个索引组。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/face_definition.png" alt="面定义"></p><p>我们将创建另一个名为<code>IndexGroup</code>的内部类，它将为索引组保存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdxGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_VALUE = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> idxPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> idxTextCoord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> idxVecNormal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdxGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idxPos = NO_VALUE;</span><br><span class="line">        idxTextCoord = NO_VALUE;</span><br><span class="line">        idxVecNormal = NO_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Face</code>类看起来像这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Face</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of idxGroup groups for a face triangle (3 vertices per face).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> IdxGroup[] idxGroups = <span class="keyword">new</span> IdxGroup[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Face</span><span class="params">(String v1, String v2, String v3)</span> </span>&#123;</span><br><span class="line">        idxGroups = <span class="keyword">new</span> IdxGroup[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// Parse the lines</span></span><br><span class="line">        idxGroups[<span class="number">0</span>] = parseLine(v1);</span><br><span class="line">        idxGroups[<span class="number">1</span>] = parseLine(v2);</span><br><span class="line">        idxGroups[<span class="number">2</span>] = parseLine(v3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IdxGroup <span class="title">parseLine</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        IdxGroup idxGroup = <span class="keyword">new</span> IdxGroup();</span><br><span class="line"></span><br><span class="line">        String[] lineTokens = line.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">int</span> length = lineTokens.length;</span><br><span class="line">        idxGroup.idxPos = Integer.parseInt(lineTokens[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// It can be empty if the obj does not define text coords</span></span><br><span class="line">            String textCoord = lineTokens[<span class="number">1</span>];</span><br><span class="line">            idxGroup.idxTextCoord = textCoord.length() &gt; <span class="number">0</span> ? Integer.parseInt(textCoord) - <span class="number">1</span> : IdxGroup.NO_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                idxGroup.idxVecNormal = Integer.parseInt(lineTokens[<span class="number">2</span>]) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idxGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IdxGroup[] getFaceVertexIndices() &#123;</span><br><span class="line">        <span class="keyword">return</span> idxGroups;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当解析面时，我们可以看到没有纹理但具有矢量法线的对象，在这种情况下，面定义可能像<code>f 11//1 17//1 13//1</code>这样，所以我们需要检测这些情况。</p><p>最后，我们需要重新整理这些数据。<code>Mesh</code>类需要四个数组，分别用于位置坐标、纹理坐标、法线矢量，一个用于索引。前三个数组应该具有相同数量的元素，因为索引数组是唯一的(注意，相同数量的元素并不意味着相同的长度。顶点坐标是三维的，由三个浮点数组成。纹理坐标是二维的，由两个浮点数组成)。OpenGL不允许我们对每个元素类型定义不同的索引数组(如果可以的话，我们就不需要在应用纹理时重复顶点)。</p><p>当你打开一个OBJ文件时，你首先可能会看到保存顶点坐标的列表比保存纹理坐标的列表和顶点的数量要多。这是我们需要解决的问题。举一个简单的例子，定义了一个具有纹理高度的正方形(只是为了说明例子)，其OBJ文件可能是这样的(不要太关注法线坐标，因为它只是为了说明例子)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">v <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">v <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">v <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">vt <span class="number">0</span> <span class="number">1</span></span><br><span class="line">vt <span class="number">1</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">vn <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f <span class="number">1</span>/<span class="number">2</span>/<span class="number">1</span> <span class="number">2</span>/<span class="number">1</span>/<span class="number">1</span> <span class="number">3</span>/<span class="number">2</span>/<span class="number">1</span></span><br><span class="line">f <span class="number">1</span>/<span class="number">2</span>/<span class="number">1</span> <span class="number">3</span>/<span class="number">2</span>/<span class="number">1</span> <span class="number">4</span>/<span class="number">1</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当我们完成文件解析时，可以看到以下列表(每个元素的数字是它在文件中的位置顺序)：</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_i.png" alt="序列1"></p><p>现在我们将使用面定义来创建包括索引在内的最终数组。要考虑的是，纹理坐标与法线向量的定义顺序与顶点的定义顺序不一样。如果列表的大小是相同的，并且它们是有序的，那么面定义就只需要一个顶点用一个数字。</p><p>因此，我们需要排列数据，并根据我们的需要进行设置。必须要做的第一件事是创建三个数组和一个列表，分别用于顶点、纹理坐标、法线向量和索引列表。正如我们之前所说的，三个数组将拥有相同数量的元素(等于顶点的数量)。顶点数组将有一个顶点列表的副本。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_ii.png" alt="序列2"></p><p>现在我们开始处理面。第一个面的第一个索引组是1/2/1。看到索引组中的第一个索引，即定义几何顶点来构造索引列表的所以，我们把它命名为<code>posIndex</code>。</p><p>面指定我们应该把占据第一个位置的元素的索引添加到索引列表中。因此，我们将<code>posIndex</code>减去1后放到<code>indicesList</code>中(我们必须减去1，因为数组的起始是0，而OBJ文件格式中是1)。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_iii.png" alt="序列3"></p><p>然后，我们使用索引组的其他索引来设置<code>texturesArray</code>和<code>normalsArray</code>。索引组的第二个索引是2，所谓我们必须将第二个纹理坐标放在与顶点指定的<code>posIndex</code>位置(V1)相同的位置上。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_iv.png" alt="序列4"></p><p>然后我们选择第三个索引，它是1，所以我们要做的是将第一个法线向量坐标放在与顶点指定的<code>posIndex</code>位置(V1)相同的位置上。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_v.png" alt="序列5"></p><p>在我们处理了第一个面之后，数组和列表看起来就会像这样。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_vi.png" alt="序列6"></p><p>在我们处理了第二个面之后，数组和列表看起来就会像这样。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/ordering_vii.png" alt="序列7"></p><p>第二个面也定义了已经被赋值的顶点，但是它们有相同的值，所以处理这个问题上很简单。我觉得这个过程已经讲解得很清晰了，不过在你实现它之前可能会有些麻烦。下面是重新排列数据的方法。请记住，我们要得到的是浮点数组，所以必须把顶点、纹理和法线的数组转换成浮点数组。因此，顶点和法线数组的大小将是顶点列表的大小乘以三，而纹理坐标数组的大小应该是顶点列表的大小乘以二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mesh <span class="title">reorderLists</span><span class="params">(List&lt;Vector3f&gt; posList, List&lt;Vector2f&gt; textCoordList,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Vector3f&gt; normList, List&lt;Face&gt; facesList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; indices = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// Create position array in the order it has been declared</span></span><br><span class="line">    <span class="keyword">float</span>[] posArr = <span class="keyword">new</span> <span class="keyword">float</span>[posList.size() * <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vector3f pos : posList) &#123;</span><br><span class="line">        posArr[i * <span class="number">3</span>] = pos.x;</span><br><span class="line">        posArr[i * <span class="number">3</span> + <span class="number">1</span>] = pos.y;</span><br><span class="line">        posArr[i * <span class="number">3</span> + <span class="number">2</span>] = pos.z;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span>[] textCoordArr = <span class="keyword">new</span> <span class="keyword">float</span>[posList.size() * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">float</span>[] normArr = <span class="keyword">new</span> <span class="keyword">float</span>[posList.size() * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Face face : facesList) &#123;</span><br><span class="line">        IdxGroup[] faceVertexIndices = face.getFaceVertexIndices();</span><br><span class="line">        <span class="keyword">for</span> (IdxGroup indValue : faceVertexIndices) &#123;</span><br><span class="line">            processFaceVertex(indValue, textCoordList, normList,</span><br><span class="line">                indices, textCoordArr, normArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] indicesArr = <span class="keyword">new</span> <span class="keyword">int</span>[indices.size()];</span><br><span class="line">    indicesArr = indices.stream().mapToInt((Integer v) -&gt; v).toArray();</span><br><span class="line">    Mesh mesh = <span class="keyword">new</span> Mesh(posArr, textCoordArr, normArr, indicesArr);</span><br><span class="line">    <span class="keyword">return</span> mesh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processFaceVertex</span><span class="params">(IdxGroup indices, List&lt;Vector2f&gt; textCoordList,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Vector3f&gt; normList, List&lt;Integer&gt; indicesList,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span>[] texCoordArr, <span class="keyword">float</span>[] normArr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set index for vertex coordinates</span></span><br><span class="line">    <span class="keyword">int</span> posIndex = indices.idxPos;</span><br><span class="line">    indicesList.add(posIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reorder texture coordinates</span></span><br><span class="line">    <span class="keyword">if</span> (indices.idxTextCoord &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Vector2f textCoord = textCoordList.get(indices.idxTextCoord);</span><br><span class="line">        texCoordArr[posIndex * <span class="number">2</span>] = textCoord.x;</span><br><span class="line">        texCoordArr[posIndex * <span class="number">2</span> + <span class="number">1</span>] = <span class="number">1</span> - textCoord.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (indices.idxVecNormal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Reorder vectornormals</span></span><br><span class="line">        Vector3f vecNorm = normList.get(indices.idxVecNormal);</span><br><span class="line">        normArr[posIndex * <span class="number">3</span>] = vecNorm.x;</span><br><span class="line">        normArr[posIndex * <span class="number">3</span> + <span class="number">1</span>] = vecNorm.y;</span><br><span class="line">        normArr[posIndex * <span class="number">3</span> + <span class="number">2</span>] = vecNorm.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一件值得注意的是纹理坐标是UV格式，所以Y坐标需要将文件中取到的值减去一。</p><p>最后，我们可以渲染OBJ模型。我已经准备了一个OBJ文件，其中是前面章节中使用过的具有纹理的立方体。为了在<code>DummyGame</code>类的<code>init</code>方法中使用它，我们需要创建一个<code>GameItem</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Texture texture = <span class="keyword">new</span> Texture(<span class="string">"/textures/grassblock.png"</span>);</span><br><span class="line">mesh.setTexture(texture);</span><br><span class="line">GameItem gameItem = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem.setScale(<span class="number">0.5f</span>);</span><br><span class="line">gameItem.setPosition(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">2</span>);</span><br><span class="line">gameItems = <span class="keyword">new</span> GameItem[]&#123;gameItem&#125;;</span><br></pre></td></tr></table></figure><p>然后将会得到一个熟悉的有纹理的立方体。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/textured_cube.png" alt="有纹理的立方体"></p><p>我们可以尝试渲染其他模型。例如可以使用著名的Standford Bunny模型(它可以自由地下载)，将它放在resources文件夹。这个模型没有纹理，所以我们可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mesh mesh = OBJLoader.loadMesh(<span class="string">"/models/bunny.obj"</span>);</span><br><span class="line">GameItem gameItem = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem.setScale(<span class="number">1.5f</span>);</span><br><span class="line">gameItem.setPosition(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">2</span>);</span><br><span class="line">gameItems = <span class="keyword">new</span> GameItem[]&#123;gameItem&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/standford_bunny.png" alt="Standford Bunny"></p><p>这个模型看起来有点奇怪，因为没有纹理也没有光，所以我们不能看到它的体积，但是你可以检查模型是否正确地加载。在<code>Window</code>类中，设置OpenGL参数时，添加这一行代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );</span><br></pre></td></tr></table></figure><p>当你放大的时候，你会看到类似的东西。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/standford_bunny_triangles.png" alt="Standford Bunny的三角形"></p><p>现在你可以看到组成模型的所有三角形了。</p><p>使用OBJ载入类，就可以使用Blender创建模型了。Blender是一个强大的工具，但刚开始使用它有点困难，它有很多选项，很多组合，在第一次使用它的时候你需要做很多基本的事情。当你使用Blender导出模型时，请务必将法线和面输出为三角形。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/obj_export_options.png" alt="OBJ导出选项"></p><p>还要记得在导出时切割边，因为我们不能给同一个顶点配方几个纹理坐标。此外，我们需要为每个三角形定义法线，而不是顶点。如果你遇到了光照问题(下一章)，在使用模型时，你应该验证一下法线。你可以在Blender中看到法线。</p><p><img src="/2019/02/07/Lwjglbook-09-loading-more-complex-models/edge_split.png" alt="边切割"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第八章 摄像机</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-08-camera/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-08-camera/</id>
    <published>2019-02-07T09:13:05.000Z</published>
    <updated>2019-02-27T14:42:51.181Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter8" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter8</a></p><p>英文标题：Camera</p></blockquote><p>在本章中，我们将学习如何在三维场景中移动，就像一个可以在三维世界穿梭的摄像机，然而实际上这就是描述它的专用术语。</p><p>但是如果你尝试在OpenGL寻找中的摄像机功能，你会发现这根本不是摄像机，换句话说摄像机一直是固定在以屏幕(0, 0, 0)为中心点的位置。</p><p>因此，我们需要模拟出一个可以在三维空间中移动的摄像机。但是怎么做呢？摄像机是不能移动的，因此我们必须要移动世界中的全部的实体。换句话说，如果移动不了摄像机就移动整个世界。</p><p>因此，假设摄像机从(Cx, Cy, Cz)沿着Z轴移动到(Cx, Cy, Cz+dz)，从而靠近在(Ox, Oy, Oz)放置的物体。</p><p><img src="/2019/02/07/Lwjglbook-08-camera/camera_movement.png" alt="摄像机的运动"></p><p>我们要做的是如何向相反的方向精确地移动物体(在三维空间中的所有物体)。换句话说，其实物体就像在跑步机上跑步一样。</p><p><img src="/2019/02/07/Lwjglbook-08-camera/actual_movement.png" alt="实际的运动"></p><p>摄像机可以沿着三个轴(x, y和z)移动，也可以绕着它们旋转(翻滚(<code>roll</code>)、俯仰(<code>pitch</code>)和偏航(<code>yaw</code>))。</p><p><img src="/2019/02/07/Lwjglbook-08-camera/roll_pitch_yaw.png" alt="俯仰和偏航"></p><p>所以从基本上我们要做的就是让移动和旋转应用于所设置的三维世界全部物体。应该怎么做呢？答案是用另外一种变换，让它变换所有在摄像机运动方向上相反的顶点，再根据摄像机的旋转来旋转它们。当然，这将要用到另外一个矩阵，即所谓的观察矩阵(<code>View Matrix</code>)来完成。这个矩阵首先进行平移，然后沿着轴线进行旋转。</p><p>来看看如何构造这个矩阵。如果你记得变换章节（第6章）的变换矩阵:</p><script type="math/tex; mode=display">Transf = \lbrack ProjMatrix \rbrack \cdot \lbrack TranslationMatrix \rbrack \cdot \lbrack  RotationMatrix \rbrack \cdot \lbrack  ScaleMatrix \rbrack = \lbrack   ProjMatrix \rbrack  \cdot \lbrack  WorldMatrix \rbrack</script><p>在使用观察矩阵之前，应将它与投影矩阵相乘，之后矩阵应该是这样的：</p><script type="math/tex; mode=display">Transf = \lbrack  ProjMatrix \rbrack \cdot \lbrack  ViewMatrix \rbrack \cdot \lbrack  TranslationMatrix \rbrack \cdot \lbrack  RotationMatrix \rbrack \cdot \lbrack ScaleMatrix \rbrack = \lbrack ProjMatrix \rbrack \cdot \lbrack  ViewMatrix \rbrack \cdot \lbrack  WorldMatrix \rbrack</script><p>现在已经有三个矩阵了，我们应该思考一下这些矩阵的生命周期。在游戏运行的时候，投影矩阵不应该更改太多，最坏的情况，每次渲染可能改变一次。如果摄像机移动，则观察矩阵可以在每次渲染改变一次。世界矩阵每渲染一个<code>GameItem</code>改变一次，所以每次渲染调用都会改变许多次。</p><p>因此，如何把每一个矩阵传递到顶点着色器呢？你可能会看到一些代码，为三个矩阵分别定义一个Uniform，但理论上，最有效的方法是组合投影和观察矩阵，将其称为<code>PV</code>矩阵，并传递<code>world</code>和<code>PV</code>矩阵到着色器。这样，将可以与世界坐标一起运算，并且可以避免一些额外的运算。</p><p>实际上，最方便的方法是将观察矩阵与世界矩阵相组合。为什么会这样？因为要记住整个摄像机的概念就是戏法，要做的是移动整个世界来模拟摄像机的位移和只显示一小部分的三维世界。因此，如果直接与世界坐标一起处理，可能会让远离中心点的世界坐标遇到一些精度问题。如果在所谓的摄像机空间中工作利用点的性质，虽然远离世界的中心点，但也靠近摄像机。可以将观察和世界矩阵相结合的矩阵称为模型观察矩阵(<code>Model View Matrix</code>)。</p><p>来开始修改代码实现摄像机吧。首先，先创建一个名为<code>Camera</code>的类，它将储存摄像机的位置与旋转的方向。该类将提供设置位置或旋转方向(<code>setPosition</code> 或 <code>setRotation</code>)的方法，或在当前状态(<code>movePosition</code> 或 <code>moveRotation</code>)下用偏移量更新这些值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector3f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Camera</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector3f position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector3f rotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Camera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        position = <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rotation = <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Camera</span><span class="params">(Vector3f position, Vector3f rotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">        <span class="keyword">this</span>.rotation = rotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3f <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">        position.x = x;</span><br><span class="line">        position.y = y;</span><br><span class="line">        position.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">movePosition</span><span class="params">(<span class="keyword">float</span> offsetX, <span class="keyword">float</span> offsetY, <span class="keyword">float</span> offsetZ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( offsetZ != <span class="number">0</span> ) &#123;</span><br><span class="line">            position.x += (<span class="keyword">float</span>)Math.sin(Math.toRadians(rotation.y)) * -<span class="number">1.0f</span> * offsetZ;</span><br><span class="line">            position.z += (<span class="keyword">float</span>)Math.cos(Math.toRadians(rotation.y)) * offsetZ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( offsetX != <span class="number">0</span>) &#123;</span><br><span class="line">            position.x += (<span class="keyword">float</span>)Math.sin(Math.toRadians(rotation.y - <span class="number">90</span>)) * -<span class="number">1.0f</span> * offsetX;</span><br><span class="line">            position.z += (<span class="keyword">float</span>)Math.cos(Math.toRadians(rotation.y - <span class="number">90</span>)) * offsetX;</span><br><span class="line">        &#125;</span><br><span class="line">        position.y += offsetY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3f <span class="title">getRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotation</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">        rotation.x = x;</span><br><span class="line">        rotation.y = y;</span><br><span class="line">        rotation.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveRotation</span><span class="params">(<span class="keyword">float</span> offsetX, <span class="keyword">float</span> offsetY, <span class="keyword">float</span> offsetZ)</span> </span>&#123;</span><br><span class="line">        rotation.x += offsetX;</span><br><span class="line">        rotation.y += offsetY;</span><br><span class="line">        rotation.z += offsetZ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在<code>Transformation</code>中，将添加一个新矩阵来储存观察矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Matrix4f viewMatrix;</span><br></pre></td></tr></table></figure><p>我们要提供一个更新这个值的方法。与投影矩阵一样，这个矩阵对于渲染周期中所面对的对象都是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matrix4f <span class="title">getViewMatrix</span><span class="params">(Camera camera)</span> </span>&#123;</span><br><span class="line">    Vector3f cameraPos = camera.getPosition();</span><br><span class="line">    Vector3f rotation = camera.getRotation();</span><br><span class="line"></span><br><span class="line">    viewMatrix.identity();</span><br><span class="line">    <span class="comment">// First do the rotation so camera rotates over its position</span></span><br><span class="line">    viewMatrix.rotate((<span class="keyword">float</span>)Math.toRadians(rotation.x), <span class="keyword">new</span> Vector3f(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        .rotate((<span class="keyword">float</span>)Math.toRadians(rotation.y), <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// Then do the translation</span></span><br><span class="line">    viewMatrix.translate(-cameraPos.x, -cameraPos.y, -cameraPos.z);</span><br><span class="line">    <span class="keyword">return</span> viewMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见的，我们首先需要做旋转，然后变换。如果操作顺序相反，我们不会沿着摄像机位置旋转，而是沿着坐标原点旋转。请注意，在<code>Camera</code>类的<code>movePosition</code>方法中，我们不只是简单地增加摄像机位置的偏移量。我们还考虑了沿Y轴的旋转，偏航，以便计算最终位置。如果我们只是通过偏移来增加摄像机的位置，摄像机就不会朝着它的方向移动。</p><p>除了上面提到的，我们现在还没有得到一个可以完全自由移动的摄像机(例如，如果我们沿着X轴旋转，当我们向前移动时，摄像机不会在空中向上或向下移动)。这将在之后的章节中完成，因为这有点复杂。 </p><p>最后，我们将移除之前的<code>getWorldMatrix</code>方法，并添加一个名为<code>getModelViewMatrix</code>的新方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matrix4f <span class="title">getModelViewMatrix</span><span class="params">(GameItem gameItem, Matrix4f viewMatrix)</span> </span>&#123;</span><br><span class="line">    Vector3f rotation = gameItem.getRotation();</span><br><span class="line">    modelViewMatrix.identity().translate(gameItem.getPosition()).</span><br><span class="line">        rotateX((<span class="keyword">float</span>)Math.toRadians(-rotation.x)).</span><br><span class="line">        rotateY((<span class="keyword">float</span>)Math.toRadians(-rotation.y)).</span><br><span class="line">        rotateZ((<span class="keyword">float</span>)Math.toRadians(-rotation.z)).</span><br><span class="line">        scale(gameItem.getScale());</span><br><span class="line">    Matrix4f viewCurr = <span class="keyword">new</span> Matrix4f(viewMatrix);</span><br><span class="line">    <span class="keyword">return</span> viewCurr.mul(modelViewMatrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getModelViewMatrix</code>方法将在每个<code>GameItem</code>实例中调用，因此我们必须对观察矩阵的副本进行处理，因此在每次调用中都不会积累转换(记住<code>Matrix4f</code>类不是不可变的)。</p><p><code>Renderer</code>类的<code>render</code>方法中，在投影矩阵更新之后只需要根据摄像机的值更新观察矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update projection Matrix</span></span><br><span class="line">Matrix4f projectionMatrix = transformation.getProjectionMatrix(FOV, window.getWidth(), window.getHeight(), Z_NEAR, Z_FAR);</span><br><span class="line">shaderProgram.setUniform(<span class="string">"projectionMatrix"</span>, projectionMatrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update view Matrix</span></span><br><span class="line">Matrix4f viewMatrix = transformation.getViewMatrix(camera);</span><br><span class="line"></span><br><span class="line">shaderProgram.setUniform(<span class="string">"texture_sampler"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Render each gameItem</span></span><br><span class="line"><span class="keyword">for</span>(GameItem gameItem : gameItems) &#123;</span><br><span class="line">    <span class="comment">// Set model view matrix for this item</span></span><br><span class="line">    Matrix4f modelViewMatrix = transformation.getModelViewMatrix(gameItem, viewMatrix);</span><br><span class="line">    shaderProgram.setUniform(<span class="string">"modelViewMatrix"</span>, modelViewMatrix);</span><br><span class="line">    <span class="comment">// Render the mes for this game item</span></span><br><span class="line">    gameItem.getMesh().render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们实现摄像机的基本代码，现在我们需要用它。我们Key更改输入处理和更新摄像机的方式。我们将设置以下按键：</p><ul><li>“A”和“D”键使摄像机左右(x轴)移动。</li><li>“W”和“S”键使摄像机前后(z轴)移动。</li><li>“Z”和“X”键使摄像机上下(y轴)移动。</li></ul><p>当鼠标按下右键时，我们可以使用鼠标位置沿X和Y轴旋转摄像机。 </p><p>正如你所看到的，我们将首次使用鼠标。创建一个名为<code>MouseInput</code>的新类，该类将封装鼠标处理的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector2d;</span><br><span class="line"><span class="keyword">import</span> org.joml.Vector2f;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.glfw.GLFW.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MouseInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector2d previousPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector2d currentPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector2f displVec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> inWindow = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> leftButtonPressed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> rightButtonPressed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MouseInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        previousPos = <span class="keyword">new</span> Vector2d(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        currentPos = <span class="keyword">new</span> Vector2d(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        displVec = <span class="keyword">new</span> Vector2f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        glfwSetCursorPosCallback(window.getWindowHandle(), (windowHandle, xpos, ypos) -&gt; &#123;</span><br><span class="line">            currentPos.x = xpos;</span><br><span class="line">            currentPos.y = ypos;</span><br><span class="line">        &#125;);</span><br><span class="line">        glfwSetCursorEnterCallback(window.getWindowHandle(), (windowHandle, entered) -&gt; &#123;</span><br><span class="line">            inWindow = entered;</span><br><span class="line">        &#125;);</span><br><span class="line">        glfwSetMouseButtonCallback(window.getWindowHandle(), (windowHandle, button, action, mode) -&gt; &#123;</span><br><span class="line">            leftButtonPressed = button == GLFW_MOUSE_BUTTON_1 &amp;&amp; action == GLFW_PRESS;</span><br><span class="line">            rightButtonPressed = button == GLFW_MOUSE_BUTTON_2 &amp;&amp; action == GLFW_PRESS;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector2f <span class="title">getDisplVec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> displVec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        displVec.x = <span class="number">0</span>;</span><br><span class="line">        displVec.y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (previousPos.x &gt; <span class="number">0</span> &amp;&amp; previousPos.y &gt; <span class="number">0</span> &amp;&amp; inWindow) &#123;</span><br><span class="line">            <span class="keyword">double</span> deltax = currentPos.x - previousPos.x;</span><br><span class="line">            <span class="keyword">double</span> deltay = currentPos.y - previousPos.y;</span><br><span class="line">            <span class="keyword">boolean</span> rotateX = deltax != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> rotateY = deltay != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rotateX) &#123;</span><br><span class="line">                displVec.y = (<span class="keyword">float</span>) deltax;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rotateY) &#123;</span><br><span class="line">                displVec.x = (<span class="keyword">float</span>) deltay;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        previousPos.x = currentPos.x;</span><br><span class="line">        previousPos.y = currentPos.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeftButtonPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftButtonPressed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRightButtonPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightButtonPressed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MouseInput</code>类提供了一个在初始化过程中应该调用的<code>init</code>方法，并注册一组回调来处理鼠标事件：</p><ul><li><code>glfwSetCursorPosCallback</code>：注册一个回调，该回调将在鼠标移动时被调用。</li><li><code>glfwSetCursorEnterCallback</code>：注册一个回调，该回调将在鼠标进入窗口时被调用。即使鼠标不在窗口内，我们也会收到鼠标事件。当鼠标在窗口内时，使用这个回调来确认鼠标进入窗口。</li><li><code>glfwSetMouseButtonCallback</code>：注册一个回调，该回调在按下鼠标按钮时被调用。</li></ul><p><code>MouseInput</code>类提供了一个<code>input</code>方法，在处理游戏输入时应调用该方法。该方法计算鼠标从先前位置的位移，并将其存储到<code>Vector2f</code>类型的<code>displVec</code>变量中，以便它被游戏使用。</p><p><code>MouseInput</code>类将在<code>GameEngine</code>类中被实例化，并且将作为游戏实现的<code>init</code>和<code>update</code>方法中的参数传递（因此需要相应地更改接口）。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(Window window, MouseInput mouseInput)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> interval, MouseInput mouseInput)</span></span>;</span><br></pre></td></tr></table></figure><p>鼠标输入将在<code>GameEngine</code>类的<code>input</code>方法中被处理，而最终的控制将交由游戏实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mouseInput.input(window);</span><br><span class="line">    gameLogic.input(window, mouseInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经准备好更改<code>DummyGame</code>类来处理键盘和鼠标输入了。该类的输入方法将如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Window window, MouseInput mouseInput)</span> </span>&#123;</span><br><span class="line">    cameraInc.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_W)) &#123;</span><br><span class="line">        cameraInc.z = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_S)) &#123;</span><br><span class="line">        cameraInc.z = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_A)) &#123;</span><br><span class="line">        cameraInc.x = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_D)) &#123;</span><br><span class="line">        cameraInc.x = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_Z)) &#123;</span><br><span class="line">        cameraInc.y = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (window.isKeyPressed(GLFW_KEY_X)) &#123;</span><br><span class="line">        cameraInc.y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将更新一个名为<code>cameraInc</code>的<code>Vector3f</code>变量，它储存了摄像机应有的位移。</p><p><code>DummyGame</code>类的<code>update</code>方法将根据处理键盘和鼠标事件，来修改摄像机的位置和旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> interval, MouseInput mouseInput)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update camera position</span></span><br><span class="line">    camera.movePosition(cameraInc.x * CAMERA_POS_STEP,</span><br><span class="line">        cameraInc.y * CAMERA_POS_STEP,</span><br><span class="line">        cameraInc.z * CAMERA_POS_STEP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update camera based on mouse            </span></span><br><span class="line">    <span class="keyword">if</span> (mouseInput.isRightButtonPressed()) &#123;</span><br><span class="line">        Vector2f rotVec = mouseInput.getDisplVec();</span><br><span class="line">        camera.moveRotation(rotVec.x * MOUSE_SENSITIVITY, rotVec.y * MOUSE_SENSITIVITY, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以向世界添加更多的立方体，将它们放在特定位置并使用新摄像机进行观察。正如你所见的，所有的立方体共享相同的<code>Mesh</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GameItem gameItem1 = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem1.setScale(<span class="number">0.5f</span>);</span><br><span class="line">gameItem1.setPosition(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">GameItem gameItem2 = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem2.setScale(<span class="number">0.5f</span>);</span><br><span class="line">gameItem2.setPosition(<span class="number">0.5f</span>, <span class="number">0.5f</span>, -<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">GameItem gameItem3 = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem3.setScale(<span class="number">0.5f</span>);</span><br><span class="line">gameItem3.setPosition(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">2.5f</span>);</span><br><span class="line"></span><br><span class="line">GameItem gameItem4 = <span class="keyword">new</span> GameItem(mesh);</span><br><span class="line">gameItem4.setScale(<span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">gameItem4.setPosition(<span class="number">0.5f</span>, <span class="number">0</span>, -<span class="number">2.5f</span>);</span><br><span class="line">gameItems = <span class="keyword">new</span> GameItem[]&#123;gameItem1, gameItem2, gameItem3, gameItem4&#125;;</span><br></pre></td></tr></table></figure><p>你会得到如下所示的东西：</p><p><img src="/2019/02/07/Lwjglbook-08-camera/cubes.png" alt="方块"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第七章 纹理</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-07-textures/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-07-textures/</id>
    <published>2019-02-07T09:12:58.000Z</published>
    <updated>2019-02-27T14:42:50.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter7" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter7</a></p><p>英文标题：Textures</p></blockquote><h2 id="创建一个三维立方体"><a href="#创建一个三维立方体" class="headerlink" title="创建一个三维立方体"></a>创建一个三维立方体</h2><p>在本章中，我们将学习如何在渲染中加载纹理并使用它们。为了讲解与纹理相关的所有概念，我们将把之前章节中使用的正方形更改为三维立方体。为了绘制一个立方体，我们只需要正确地设置一个立方体的坐标，就能使用现有代码正确地绘制它。</p><p>为了绘制立方体，我们只需要定义八个顶点。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_coords.png" alt="立方体坐标"></p><p>因此，它的坐标数组将是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] positions = <span class="keyword">new</span> <span class="keyword">float</span>[] &#123;</span><br><span class="line">    <span class="comment">// VO</span></span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V1</span></span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V2</span></span><br><span class="line">    <span class="number">0.5f</span>, -<span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V3</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V4</span></span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V5</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, -<span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V6</span></span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// V7</span></span><br><span class="line">     <span class="number">0.5f</span>, -<span class="number">0.5f</span>, -<span class="number">0.5f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，由于我们多了4个顶点，我们需要更改颜色数组。当前仅重复前四项的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] colours = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，由于立方体是六个面构成的，所以需要绘制十二个三角形（每个面两个），所以我们需要更改索引数组。记住三角形必须按逆时针顺序定义。如果你徒手做这件事，很容易犯错。一定要将你想定义的面摆在你的面前，确认顶点并以逆时针顺序绘制三角形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] indices = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">    <span class="comment">// Front face</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// Top Face</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// Right face</span></span><br><span class="line">    <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="comment">// Left face</span></span><br><span class="line">    <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// Bottom face</span></span><br><span class="line">    <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="comment">// Back face</span></span><br><span class="line">    <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了更好的观察立方体，我们将更改’DummyGame’类中旋转模型的代码，使它沿着三个轴旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update rotation angle</span></span><br><span class="line"><span class="keyword">float</span> rotation = gameItem.getRotation().x + <span class="number">1.5f</span>;</span><br><span class="line"><span class="keyword">if</span> ( rotation &gt; <span class="number">360</span> ) &#123;</span><br><span class="line">    rotation = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">gameItem.setRotation(rotation, rotation, rotation);</span><br></pre></td></tr></table></figure><p>就这样，现在能够显示一个旋转的三维立方体了。现在你可以编译和运行示例代码，会得到如下所示的东西。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_no_depth_test.png" alt="没有开启深度测试的立方体"></p><p>这个立方体有些奇怪。有些面没有被正确的绘制。发生了什么？立方体出现这个现象的原因，是组成立方体的三角形是以一种随即顺序绘制的。事实上距离较远的像素应该在距离较近的像素之前绘制，而不是现在这样。为了做到这一点，我们必须启用深度测试(<code>Depth Test</code>)。</p><p>这可以在<code>Window</code>类的<code>init</code>方法中做到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>现在立方体被正确地渲染了！</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_depth_test.png" alt="开启深度测试的立方体"></p><p>如果你看了本章这一小节的代码，你可能会看到<code>Mesh</code>类做了一次小规模的调整。VBO的ID现在被储存在一个List中，以方便地迭代它们。</p><h2 id="为立方体添加纹理"><a href="#为立方体添加纹理" class="headerlink" title="为立方体添加纹理"></a>为立方体添加纹理</h2><p>现在我们将把纹理应用到立方体上。纹理是用来绘制某个模型的像素的颜色的图像，可以认为纹理是包裹在3D模型周围的皮肤。你要做的就是将纹理图像中的点分配给模型中的顶点。这样，OpenGL能够根据纹理图像计算其他像素的颜色。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/texture_mapping.png" alt="纹理映射"></p><p>纹理图像不需要与模型同样大小，它可以变大或变小。如果要处理的像素不能映射到纹理中的特定点，OpenGL将推断颜色。当创建纹理时，可以控制此过程。</p><p>因此，为了将纹理应用到模型，我们必须做的是将纹理坐标分配给每个顶点。纹理坐标系有些不同于模型坐标系。首先，我们的纹理是二维纹理，所以坐标只有X和Y两个量。此外，原点是图像的左上角，X或Y的最大值都是1。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/texture_coordinates.png" alt="纹理坐标系"></p><p>我们如何将纹理坐标与位置坐标联系起来呢？简单，就像传递颜色信息一样。我们创建了一个VBO，将为每个顶点储存纹理坐标。</p><p>让我们为在三维立方体中应用纹理来修改代码吧。第一步是加载将被用作纹理的图像。对于这件事，在之前版本的LWJGL中，通常使用Slick2D库。在撰写本文的时候，这个库似乎与LWJGL 3不兼容，所以需要使用更冗长的方法。我们将使用一个名为<code>pngdecoder</code>的库，因此，需要在<code>pom.xml</code>文件中声明依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.l33tlabs.twl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pngdecoder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pngdecoder.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后设置库使用的版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="tag">&lt;<span class="name">pngdecoder.version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">pngdecoder.version</span>&gt;</span></span><br><span class="line">    [...]</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在一些教程中你可能看到，必须做的第一件事是调用<code>glEnable(GL_TEXTURE_2D)</code>来启用OpenGL的纹理功能。如果使用固定函数关系，这是正确的。但我们使用的是GLSL着色器，因此不再需要了。</p><p>现在我们将创建一个新的<code>Texture</code>类，它将进行所有必要的步骤以加载纹理。纹理图像将位于<code>resources</code>文件夹中，可以作为CLASSPATH资源访问并使用输入流传递到<code>PNGDecoder</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PNGDecoder decoder = <span class="keyword">new</span> PNGDecoder(</span><br><span class="line">     Texture.class.getResourceAsStream(fileName));</span><br></pre></td></tr></table></figure><p>然后，我们需要解码PNG图像，并通过<code>PNGDecoder</code>的<code>decode</code>方法将其内容储存到缓冲区中。PNG图像以RGBA(RGB意为红绿蓝，A意为Alpha或透明度)格式解码，每个像素使用四个字节。</p><p><code>decode</code>方法需要三个参数：</p><ul><li><code>buffer</code>: 储存解码后图像的<code>ByteBuffer</code>(因为每个像素是四个字节，其大小将是4*宽度*高度)。</li><li><code>stride</code>: 指定从一行开始到下一行的起始字节的距离。现在它是每行的字节数。</li><li><code>format</code>: 图像解码的目标格式(RGBA)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(</span><br><span class="line">    <span class="number">4</span> * decoder.getWidth() * decoder.getHeight());</span><br><span class="line">decoder.decode(buf, decoder.getWidth() * <span class="number">4</span>, Format.RGBA);</span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure><p>一件关于OpenGL的重要事情，由于历史原因，要求纹理图像的大小(每个轴的像素数)必须是二的指数(2, 4, 8, 16, ….)。一些驱动消除了这种限制，但最好还是坚持以免出现问题。</p><p>下一步是将纹理传递到显存中。首先，我们需要创建一个新的纹理ID。与该纹理相关的操作都要使用该ID，因此我们需要绑定它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new OpenGL texture </span></span><br><span class="line"><span class="keyword">int</span> textureId = glGenTextures();</span><br><span class="line"><span class="comment">// Bind the texture</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, textureId);</span><br></pre></td></tr></table></figure><p>然后需要告诉OpenGL如何解包我们的RGBA字节。由于每个数据大小都是一个字节，所以我们需要添加以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最后我们可以传递材质数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, decoder.getWidth(),</span><br><span class="line">    decoder.getHeight(), <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, buf);</span><br></pre></td></tr></table></figure><p><code>glTexImage2D</code>的参数如下：</p><ul><li><code>target</code>: 指定目标纹理(纹理类型)。现在是<code>GL_TEXTURE_2D</code>。</li><li><code>level</code>: 指定纹理细节的等级。0级是基本图像等级。第n级是第n个多级渐远纹理(<code>Mipmap</code>)的图像。之后再谈这个问题。</li><li><code>internal format</code>: 指定纹理中颜色分量的数量。</li><li><code>width</code>: 指定纹理图像的宽度。</li><li><code>height</code>: 指定纹理图像的高度。</li><li><code>border</code>: 此值必须为0。</li><li><code>format</code>: 指定像素数据的格式，现在为RGBA。</li><li><code>type</code>: 指定像素数据的类型。现在，我们使用的是无符号字节。</li><li><code>data</code>: 储存数据的缓冲区。</li></ul><p>在一些代码片段中，你可能会发现在调用<code>glTexImage2D</code>方法钱设置了一些过滤参数。过滤是指在缩放时如何绘制图像，以及如何修改像素。</p><p>如果没有设置这些参数，纹理将不会显示。因此，在<code>glTexImage2D</code>方法调用之前，你会看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br></pre></td></tr></table></figure><p>这些参数基本上在表达，当一个像素与纹理坐标没有直接的一对一关联时，它将选择最近的纹理坐标点。</p><p>到目前为止，我们不会设置这些参数。相反，我们将生成一个多级渐远纹理(<code>Mipmap</code>)。多级渐远纹理是由高细节纹理生成的逐级降低分辨率的纹理集合。当我们的物体缩放时，就将自动使用低分辨率的图像。</p><p>为了生成多级渐远纹理，我们只需要编写以下代码(现在，我们把它放在<code>glTextImage2D</code>方法调用之后)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><p>就这样，我们已经成功地加载了纹理，现在需要使用它。正如之前所说的，我们需要把纹理坐标作为另一个VBO。因此，我们将修改<code>Mesh</code>类来接收浮点数组，其中储存纹理坐标，而不是颜色(我们可以同时有颜色和纹理，但为了简化它，我们将删除颜色)。构造函数现在是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mesh</span><span class="params">(<span class="keyword">float</span>[] positions, <span class="keyword">float</span>[] textCoords, <span class="keyword">int</span>[] indices,</span></span></span><br><span class="line"><span class="function"><span class="params">    Texture texture)</span></span></span><br></pre></td></tr></table></figure><p>纹理坐标VBO与颜色VBO创建的方式相同。唯一的区别是它有两个元素而不是三个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vboId = glGenBuffers();</span><br><span class="line">vboIdList.add(vboId);</span><br><span class="line">textCoordsBuffer = MemoryUtil.memAllocFloat(textCoords.length);</span><br><span class="line">textCoordsBuffer.put(textCoords).flip();</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vboId);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, textCoordsBuffer, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在我们需要在着色器中使用这些纹理。在顶点着色器中，第二个Uniform被修改了，因为现在它是一个<code>vec2</code>(也顺便更改了名称，所以记得在<code>Renderer</code>类中更改它)。顶点着色器就像之前一样，仅仅传递纹理坐标给片元着色器。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> outTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> worldMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * worldMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    outTexCoord = texCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在片元着色器中，我们使用那些纹理坐标来设置像素颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>  <span class="type">vec2</span> outTexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_sampler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="built_in">texture</span>(texture_sampler, outTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析代码之前，让我们理清一些概念。显卡有几个空间或槽来储存纹理。每一个空间被称为纹理单元(<code>Texture Unit</code>)。当使用纹理时，我们必须设置想用的纹理。正如你所看到的，我们有一个新的名为<code>texture_sampler</code>的Uniform。该Uniform是<code>sampler2D</code>，并储存有我们希望使用的纹理单元的值。</p><p>在<code>main</code>函数中，我们使用<code>texture</code>函数来使用纹理。这个函数有两个参数：取样器(<code>Sampler</code>)和纹理坐标，并返回正确的颜色。取样器Uniform允许使用多重纹理(<code>multi-texture</code>)，不过现在不是讨论这个话题的时候，但是我们会在稍后再尝试添加。</p><p>因此，在<code>ShaderProgram</code>类中，我们将创建一个新的方法，允许为整数型Uniform设置数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    glUniform1i(uniforms.get(uniformName), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Renderer</code>类的<code>init</code>方法中，我们将创建一个新的Uniform：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.createUniform(<span class="string">"texture_sampler"</span>);</span><br></pre></td></tr></table></figure><p>此外，在<code>Renderer</code>类的<code>render</code>方法中，我们将Uniform的值设置为0(我们现在不使用多个纹理，所以只使用单元0)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.setUniform(<span class="string">"texture_sampler"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最好，我们只需改变<code>Mesh</code>类的渲染方法就可以使用纹理。在方法开始的地方，我们添加以下几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activate first texture unit</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line"><span class="comment">// Bind the texture</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture.getId());</span><br></pre></td></tr></table></figure><p>我们基本上将<code>texture.getId()</code>所获得的纹理绑定到纹理单元0上。</p><p>现在，我们刚刚修改了代码来支持纹理。现在我们需要为三维立方体设置纹理坐标。我们的纹理图像文件将是这样的：</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_texture.png" alt="立方体纹理"></p><p>在我们的3D模型中，一共有八个顶点。我们首先定义每个顶点的正面纹理坐标。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_texture_front_face.png" alt="立方体纹理的正面"></p><div class="table-container"><table><thead><tr><th>Vertex</th><th>Texture Coordinate</th></tr></thead><tbody><tr><td>V0</td><td>(0.0, 0.0)</td></tr><tr><td>V1</td><td>(0.0, 0.5)</td></tr><tr><td>V2</td><td>(0.5, 0.5)</td></tr><tr><td>V3</td><td>(0.5, 0.0)</td></tr></tbody></table></div><p>然后，定义顶面纹理的映射。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_texture_top_face.png" alt="正方体纹理的顶面"></p><div class="table-container"><table><thead><tr><th>Vertex</th><th>Texture Coordinate</th></tr></thead><tbody><tr><td>V4</td><td>(0.0, 0.5)</td></tr><tr><td>V5</td><td>(0.5, 0.5)</td></tr><tr><td>V0</td><td>(0.0, 1.0)</td></tr><tr><td>V3</td><td>(0.5, 1.0)</td></tr></tbody></table></div><p>正如你所看到的，有一个问题，我们需要为同一个顶点(V0和V3)设置不同的纹理坐标。怎么样才能解决这个问题呢？解决这一问题的唯一方法是重复一些顶点并关联不同的纹理坐标。对于顶面，我们需要重复四个顶点并为它们分配正确的纹理坐标。</p><p>因为前面、后面和侧面都使用相同的纹理，所以我们不需要重复这些顶点。在源代码中有完整的定义，但是我们需要从第8章跳到第20章了。最终的结果就像这样。</p><p><img src="/2019/02/07/Lwjglbook-07-textures/cube_with_texture.png" alt="有纹理的立方体"></p><p>在接下来的章节中，我们将学习如何加载由3D建模工具生成的模型，这样我们就不需要手动定义顶点和纹理坐标了(顺便一提，对于更复杂的模型，手动定义是不存在的)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第六章 变换</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-06-transformations/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-06-transformations/</id>
    <published>2019-02-07T09:12:41.000Z</published>
    <updated>2019-02-27T14:42:50.966Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter6" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter6</a></p><p>英文标题：Transformations</p></blockquote><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>让我们看到在前一章中创建的漂亮的彩色的正方形。如果仔细看，它更像一个矩形，你甚至可以将窗口的宽度从600像素改为900像素，失真就会更加明显。这发生了什么事呢？</p><p>如果你观察顶点着色器的代码，我们只是直接地传递坐标。换句话说，当一个顶点的X坐标为0.5时，我们对OpenGL说在屏幕的X坐标为0.5的位置绘制它。下图是OpenGL坐标（仅含X和Y轴）。</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/coordinates.png" alt="Coordinates"></p><p>将这些坐标投影到窗口坐标，需要考虑到窗口的大小。因此，如果我们的窗口大小为900x480，OpenGL坐标(1, 0)将被投影到窗口坐标(900, 0)，最终创建一个矩形而不是一个正方形。</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/rectangle.png" alt="Rectangle"></p><p>但是，问题远比这更严重。在0.0到1.0和-1.0之间修改正方形的坐标，你看到了什么？正方形是完全绘制在同一个地方，不管它是否沿着Z轴位移。为什么会发生这种情况？远处的物体应该比近处的物体小，但是我们使用相同的X和Y坐标绘制它们。</p><p>但是，等等。这不应该用Z坐标来处理吗？这是正确的但是又不正确。Z坐标告诉OpenGL对象的远近，但是OpenGL对你的对象的大小一无所知。你可以有两个不同大小的物体，一个更近更小，一个更远更大，而且可以以相同的大小正确地投影到屏幕上（有相同的屏幕X和Y坐标，但Z坐标不同）。OpenGL只使用我们正在传递的坐标，所以必须处理这个问题。我们需要正确地投影坐标。</p><p>既然已经确诊了这个问题，我们该怎么做？答案是使用投影矩阵（<code>Projection Matrix</code>）或截锥体（<code>Frustum</code>）。投影矩阵将处理绘制区域的宽高比（宽度和高度的关系），因此物体不会被扭曲。它也将处理距离，所以较远的物体将会被绘制得更小。投影矩阵还将考虑我们的视野和应该显示的最大距离有多远。</p><p>对于不熟悉矩阵的人，矩阵（<code>Matrix</code>）是以行和列排列的二维数组。矩阵中的每个数字被称为元素。矩阵阶次是行和列的数量。例如，这里是一个2x2矩阵（有2行2列）。</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/2_2_matrix.png" alt="2x2 Matrix"></p><p>矩阵有许多可以使用的基本运算法则（如加法、乘法等），你可以在任何数学书中查阅它们。与三维图形相关的矩阵对空间中点的变换非常有用。</p><p>你可以把投影矩阵想象成一个摄像机，它有一个视野和最小和最大距离。该摄像机的可视区域是一个截断的金字塔。下图展示了该区域的俯视图。</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/projection_matrix.png" alt="Projection Matrix concepts"></p><p>投影矩阵将正确地投影三维坐标，以便它们能够在二维屏幕上正确地显示。该矩阵的数学表示如下（不要害怕）:</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/projection_matrix_eq.png" alt="Projection Matrix"></p><p>其中屏幕宽高比（<code>Aspect Ratio</code>）指的是屏幕宽度与屏幕高度的关系（<script type="math/tex">a=width/height</script>）。为了获得给定点的投影坐标，我们只需要将投影矩阵乘以原始坐标，结果将是投影后的另一个向量。</p><p>因此我们需要处理一组数学对象，如向量、矩阵，并要可以对它们进行操作。我们可以选择从头开始编写所有的代码，或者使用已经实现的库。当然我们会选择容易的方法，使用JOML（<code>Java OpenGL Math Library</code>）处理LWJGL内的数学运算。为了使用该库，我们只需要为<code>pom.xml</code>文件添加另一个依赖项。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.joml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;joml.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后设定使用的库版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="tag">&lt;<span class="name">joml.version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">joml.version</span>&gt;</span></span><br><span class="line">    [...]</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在一切都完事了，让我们创建我们的投影矩阵吧。在<code>Renderer</code>类中创建<code>Matrix4f</code>类（由JOML库提供）的实例。<code>Matrix4f</code>类提供了一个<code>perspective</code>方法来创建投影矩阵。该方法需要以下参数：</p><ul><li>视野：可视区域的弧度角大小。我们将定义一个储存该值的常数。</li><li>屏幕宽高比。</li><li>最近视距（z-near）。</li><li>最远视距（z-far）。</li></ul><p>我们将在<code>init</code>方法中实例化该矩阵，因此需要将引用传递给<code>Window</code>实例以获得窗口大小（你可以在源代码看到它）。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Field of View in Radians</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> FOV = (<span class="keyword">float</span>) Math.toRadians(<span class="number">60.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> Z_NEAR = <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> Z_FAR = <span class="number">1000</span>.f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Matrix4f projectionMatrix;</span><br></pre></td></tr></table></figure><p>投影矩阵的创建如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> aspectRatio = (<span class="keyword">float</span>) window.getWidth() / window.getHeight();</span><br><span class="line">projectionMatrix = <span class="keyword">new</span> Matrix4f().perspective(FOV, aspectRatio,</span><br><span class="line">    Z_NEAR, Z_FAR);</span><br></pre></td></tr></table></figure><p>现在我们忽略宽高比可以改变（通过调整窗口大小）。这可以在<code>render</code>方法中检查并相应地改变投影矩阵。</p><p>现在有了矩阵，我们如何使用它呢？我们需要在着色器中使用它，并且它应该被应用到所有顶点上。首先，你可能会想到把它捆绑在顶点输入中（就像坐标和颜色那样）。但这样，我们会浪费很多空间，因为投影矩阵在几次渲染期间都不会发生改变。你可能还想在Java代码中用矩阵处理所有顶点。但是，这样我们输入的VBO就是没用的了，这样就不能使用显卡中的处理器资源了。</p><p>答案是使用“<code>uniform</code>”。Uniform是着色器可以使用的全局的GLSL变量，我们将使用它与着色器交流。</p><p>所以我们需要修改顶点着色器的代码，并声明一个新的称为<code>projectionMatrix</code>的全局变量，并用它来计算投影位置。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> exColour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    exColour = inColour;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所述，我们把<code>projectionMatrix</code>定义为一个4x4的矩阵，新的坐标是通过把它与原始坐标相乘得到的。现在我们需要把投影矩阵的值传递给着色器。首先，我们需要确定全局变量的位置。</p><p>这是通过调用方法<code>glGetUniformLocation</code>完成的，它有两个参数：</p><ul><li>着色器程序的ID</li><li>全局变量名（它应该与着色器里定义的名称相同）</li></ul><p>此方法返回储存全局变量的ID。由于我们可能有一个以上的全局变量，我们将把这些ID储存在由变量名作为索引的Map中（稍后我们需要那个ID）。因此，在<code>ShaderProgram</code>需要创建一个新的字段来保存这些ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; uniforms;</span><br></pre></td></tr></table></figure><p>然后由构造方法初始化它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniforms = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>最后，我们创建一个方法来获得全局变量储存的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUniform</span><span class="params">(String uniformName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uniformLocation = glGetUniformLocation(programId,</span><br><span class="line">        uniformName);</span><br><span class="line">    <span class="keyword">if</span> (uniformLocation &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Could not find uniform:"</span> +</span><br><span class="line">            uniformName);</span><br><span class="line">    &#125;</span><br><span class="line">    uniforms.put(uniformName, uniformLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在着色器程序编译后，我们就可以在<code>Renderer</code>类中调用<code>createUniform</code>方法（现在我们投影矩阵实例化后就调用它）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.createUniform(<span class="string">"projectionMatrix"</span>);</span><br></pre></td></tr></table></figure><p>现在，我们已经准备好一个可以储存投影矩阵数据的储存器。由于投影矩阵在渲染期间不会改变，所以可以在创建后直接设置值。但是我们将在<code>render</code>方法中做这件事。稍后你可以看到，我们可以重用该全局变量来做额外的事情，这些事情需要在每次渲染调用中完成。</p><p>我们将在<code>ShaderProgram</code>类中创建另一个方法来设置数据，称为<code>setUniform</code>。我们通过使用JOML库提供的实用方法将矩阵转换成4x4的<code>FloatBuffer</code>对象，并将它们发送到全局变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUniform</span><span class="params">(String uniformName, Matrix4f value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Dump the matrix into a float buffer</span></span><br><span class="line">    <span class="keyword">try</span> (MemoryStack stack = MemoryStack.stackPush()) &#123;</span><br><span class="line">        FloatBuffer fb = stack.mallocFloat(<span class="number">16</span>);</span><br><span class="line">        value.get(fb);</span><br><span class="line">        glUniformMatrix4fv(uniforms.get(uniformName), <span class="keyword">false</span>, fb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你看到的，我们以不同的方式创建缓冲区。我们使用的是自动管理缓冲区，并将它们分配到堆栈上。这是因为这个缓冲区是大小很小，而且它在本方法外不被使用。因此，我们使用<code>MemoryStack</code>类。</p><p>现在，在着色器绑定之后，<code>Renderer</code>类中的<code>render</code>方法可以使用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.setUniform(<span class="string">"projectionMatrix"</span>, projectionMatrix);</span><br></pre></td></tr></table></figure><p>我们快要完成了。现在我们可以正确地渲染正方形。所以现在可以启动你的程序，然后得到一个…黑色背景上没有任何彩色正方形。发生了什么？我们弄糟了什么吗？实际上没有任何问题。记住我们正在模拟摄像机观察场景的效果。我们提供了两个距离，一个是最远视距（1000f）和一个最近视距（0.01f）。而我们的坐标是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] positions = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">    -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说，我们坐标中的Z坐标在可视区域之外。给它们赋值为-0.05f。现在你会看到像这样的一个巨大的绿色矩形：</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/square_1.png" alt="Square 1"></p><p>这是因为，我们正绘制出离摄像机机太近的正方形。我们实际上是在放大它。如果现在把一个<code>-1.05f</code>的值赋值给Z坐标，就可以看到彩色正方形了。</p><p><img src="/2019/02/07/Lwjglbook-06-transformations/square_coloured.png" alt="Square coloured"></p><p>如果继续向后移动正方形，我们会看到它变小了。还要注意到正方形不再像矩形了。</p><h2 id="使用变换"><a href="#使用变换" class="headerlink" title="使用变换"></a>使用变换</h2><p>让我们回想一下到目前为止我们都做了什么。我们已经学会了如何将数据以有效的格式传递给显卡，以及如何使用顶点和片元着色器来投影这些顶点并设置它们的颜色。现在应该开始在三维空间中绘制更复杂的模型了。但为了做到这件事，我们必须能够加载模型，并在指定的位置以适当的大小和所需的旋转将它渲染在三维空间中。</p><p>现在为了实现这种渲染，我们需要提供一些基本操作来操作模型：</p><ul><li>移动(<code>translation</code>): 在三个轴中的任意一个轴上移动一个物体。</li><li>旋转(<code>Rotation</code>): 按任意一个轴旋转物体任意角度。</li><li>缩放(<code>Scale</code>): 调整物体的大小。</li></ul><p><img src="/2019/02/07/Lwjglbook-06-transformations/transformations.png" alt="Transformations"></p><p>上面的操作统称为变换（<code>Transformation</code>）。你可能猜到要实现这一点的方法是把坐标乘以一组矩阵（一个用于移动，一个用于旋转，一个用于缩放）。这三个矩阵将被组合成一个称为“世界矩阵”的矩阵，并作为一个全局变量传递给顶点着色器。</p><p>之所以被称为世界矩阵是因为我们正在从模型坐标转换为世界坐标。当学习加载3D模型时，你会发现这些模型是在它们自己的坐标系中定义的。它们不知道你的三维空间的大小，但它们需要在里面渲染。因此，当我们用矩阵乘以坐标时，实际上做的是从一个坐标系（模型坐标系）转换到另一个坐标系（三维世界坐标系）。</p><p>世界矩阵应该这样计算（顺序很重要，因为乘法交换律不适用于矩阵）:</p><script type="math/tex; mode=display">World Matrix\left[Translation Matrix\right]\left[Rotation Matrix\right]\left[Scale Matrix\right]</script><p>如果把投影矩阵包含在变换矩阵中，它会是这样的：</p><script type="math/tex; mode=display">Transf=\left[Proj Matrix\right]\left[Translation Matrix\right]\left[Rotation Matrix\right]\left[Scale Matrix\right]=\left[Proj Matrix\right]\left[World Matrix\right]</script><p>变换矩阵是这样的：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & dx \\0 & 1 & 0 & dy \\0 & 0 & 1 & dz \\0 & 0 & 0 & 1\end{bmatrix}</script><p>位移矩阵参数如下：</p><ul><li>dx: 沿X轴位移。</li><li>dy: 沿Y轴位移。</li><li>dz: 沿Z轴位移。</li></ul><p>缩放矩阵是这样定义的；</p><script type="math/tex; mode=display">\begin{bmatrix}sx & 0 & 0 & 0 \\0 & sy & 0 & 0 \\0 & 0 & sz & 0 \\0 & 0 & 0 & 1\end{bmatrix}</script><p>缩放矩阵参数如下：</p><ul><li>sx: 沿着X轴缩放。</li><li>sy: 沿着Y轴缩放。</li><li>sz: 沿着Z轴缩放。</li></ul><p>旋转矩阵要复杂得多，但请记住，它可以由每个绕单独的轴旋转的旋转矩阵相乘得到。</p><p>现在，为了实践这些理论，我们需要重构代码一点点。在游戏中，我们将加载一组模型，用来根据游戏逻辑在不同的位置渲染许多对象（想象一个FPS游戏，它载入了三个不同敌人的模型。确实只有三个模型，但使用这些模型，我们可以渲染想要的任意数量的敌人）。我们需要为每个对象创建一个VAO和一组VBO吗？答案是否定的，只需要每个模型加载一次就行。我们需要做的是根据它的位置，大小和旋转来独立绘制它。当渲染这些模型时，我们需要对它们进行变换。</p><p>因此，我们将创建一个名为<code>GameItem</code>的新类，该类将模型加载到<code>Mesh</code>实例中。一个<code>GameItem</code>实例将由变量储存它的位置、旋转状态和大小。这个就是这个类的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Vector3f;</span><br><span class="line"><span class="keyword">import</span> org.lwjglb.engine.graph.Mesh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Mesh mesh;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector3f position;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> scale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Vector3f rotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameItem</span><span class="params">(Mesh mesh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mesh = mesh;</span><br><span class="line">        position = <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        scale = <span class="number">1</span>;</span><br><span class="line">        rotation = <span class="keyword">new</span> Vector3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3f <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.position.x = x;</span><br><span class="line">        <span class="keyword">this</span>.position.y = y;</span><br><span class="line">        <span class="keyword">this</span>.position.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getScale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScale</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scale = scale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3f <span class="title">getRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotation</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rotation.x = x;</span><br><span class="line">        <span class="keyword">this</span>.rotation.y = y;</span><br><span class="line">        <span class="keyword">this</span>.rotation.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mesh <span class="title">getMesh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mesh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将创建一个名为<code>Transformation</code>的类，让它来处理变换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.joml.Matrix4f;</span><br><span class="line"><span class="keyword">import</span> org.joml.Vector3f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transformation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Matrix4f projectionMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Matrix4f worldMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        worldMatrix = <span class="keyword">new</span> Matrix4f();</span><br><span class="line">        projectionMatrix = <span class="keyword">new</span> Matrix4f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Matrix4f <span class="title">getProjectionMatrix</span><span class="params">(<span class="keyword">float</span> fov, <span class="keyword">float</span> width, <span class="keyword">float</span> height, <span class="keyword">float</span> zNear, <span class="keyword">float</span> zFar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> aspectRatio = width / height;        </span><br><span class="line">        projectionMatrix.identity();</span><br><span class="line">        projectionMatrix.perspective(fov, aspectRatio, zNear, zFar);</span><br><span class="line">        <span class="keyword">return</span> projectionMatrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Matrix4f <span class="title">getWorldMatrix</span><span class="params">(Vector3f offset, Vector3f rotation, <span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">        worldMatrix.identity().translate(offset).</span><br><span class="line">                rotateX((<span class="keyword">float</span>)Math.toRadians(rotation.x)).</span><br><span class="line">                rotateY((<span class="keyword">float</span>)Math.toRadians(rotation.y)).</span><br><span class="line">                rotateZ((<span class="keyword">float</span>)Math.toRadians(rotation.z)).</span><br><span class="line">                scale(scale);</span><br><span class="line">        <span class="keyword">return</span> worldMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，这个类把投影矩阵和世界矩阵结合起来。给定一组参数来进行位移、旋转和缩放，然后返回世界矩阵。<code>getWorldMatrix</code>返回的结果将为每个<code>GameItem</code>实例转换坐标。该类还提供了获得投影矩阵的方法。</p><p>需要注意的一件事是，<code>Matrix4f</code>类的<code>mul</code>方法修改了该实例的内容。因此，如果直接将投影矩阵与变换矩阵相乘，我们会修改投影矩阵本身。这就是为什么总是在每次调用时将每个矩阵初始化为单位矩阵。</p><p>在<code>Renderer</code>类的构造方法中，我们仅实例化了没有任何参数的<code>Transformation</code>类，而在<code>init</code>方法中，我们只创建了Uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Renderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    transformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Window window)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// .... Some code before ...</span></span><br><span class="line">    <span class="comment">// Create uniforms for world and projection matrices</span></span><br><span class="line">    shaderProgram.createUniform(<span class="string">"projectionMatrix"</span>);</span><br><span class="line">    shaderProgram.createUniform(<span class="string">"worldMatrix"</span>);</span><br><span class="line"></span><br><span class="line">    window.setClearColor(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Renderer</code>类的渲染方法中，现在可以接收到一个<code>GameItem</code>的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window, GameItem[] gameItems)</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">            glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">            window.setResized(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    shaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update projection Matrix</span></span><br><span class="line">    Matrix4f projectionMatrix = transformation.getProjectionMatrix(FOV, window.getWidth(), window.getHeight(), Z_NEAR, Z_FAR);</span><br><span class="line">    shaderProgram.setUniform(<span class="string">"projectionMatrix"</span>, projectionMatrix);        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render each gameItem</span></span><br><span class="line">    <span class="keyword">for</span>(GameItem gameItem : gameItems) &#123;</span><br><span class="line">        <span class="comment">// Set world matrix for this item</span></span><br><span class="line">        Matrix4f worldMatrix =</span><br><span class="line">            transformation.getWorldMatrix(</span><br><span class="line">                gameItem.getPosition(),</span><br><span class="line">                gameItem.getRotation(),</span><br><span class="line">                gameItem.getScale());</span><br><span class="line">        shaderProgram.setUniform(<span class="string">"worldMatrix"</span>, worldMatrix);</span><br><span class="line">        <span class="comment">// Render the mes for this game item</span></span><br><span class="line">        gameItem.getMesh().render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shaderProgram.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用<code>render</code>时就更新投影矩阵一次。这样，我们可以处理窗口大小的调整。然后，我们遍历<code>GameItem</code>数组，并根据它们各自的位置、旋转和大小创建变换矩阵。这个矩阵将被传递到着色器并绘制<code>Mesh</code>。投影矩阵对于所有要渲染的项目都是相同的。这就是为什么它在<code>Transformation</code>类中是单独一个变量的原因。</p><p>我们将渲染代码移动到<code>Mesh</code>类中。<br>We moved the rendering code to draw a Mesh to this class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制Mesh</span></span><br><span class="line">    glBindVertexArray(getVaoId());</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    glDrawElements(GL_TRIANGLES, getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置状态</span></span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glDisableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶点着色器只需简单地添加一个新的<code>worldMatrix</code>变量，然后用它与<code>projectionMatrix</code>一同计算坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> exColour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> worldMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projectionMatrix * worldMatrix * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    exColour = inColour;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，代码完全一样。我们使用Uniform来正确地计算坐标，并且考虑截锥、位置、大小和旋转等。</p><p>另外一个重要的问题是，为什么不使用位移、旋转和缩放矩阵，而是把它们组合成一个世界矩阵？原因是我们应该尽量减少在着色器中使用的矩阵。还要记住，在着色器中所做的矩阵乘法是每个顶点一次。投影矩阵在渲染调用期间不会改变，而每一个<code>GameItem</code>实例的世界矩阵也不会改变。如果我们独立位移、旋转和缩放矩阵，我们要做更多的矩阵乘法运算。想象一个有超多顶点的模型，这是很多余的操作。</p><p>但你现在可能会想，如果每个<code>GameItem</code>中的世界矩阵都不会发生变化，为什么不在Java类中做矩阵乘法？我们将投影矩阵和世界矩阵与每个<code>GameItem</code>相乘，把它们作为一个Uniform，这种情况下，我们确实能节省更多的操作。但是，当我们向游戏引擎中添加更多的特性时，我们需要在着色器中使用世界坐标，所以最好以独立的方式处理这两个矩阵。</p><p>最后只需要修改一下<code>DummyGame</code>类，创建一个<code>GameItem</code>实例，让其与<code>Mesh</code>关联，并添加一些操作来位移，旋转和缩放正方形。因为这只是个测试示例，所有没有添加太多，你可以在本书的源代码中找到相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第五章 更多关于渲染的事情</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-05-more-on-rendering/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-05-more-on-rendering/</id>
    <published>2019-02-06T17:29:30.000Z</published>
    <updated>2019-02-27T14:42:50.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter5" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter5</a></p><p>英文标题：More on Rendering</p></blockquote><p>本章中，我们将继续讨论OpenGL如何渲染物体。为了整理代码，我们要创建一个名为<code>Mesh</code>的新类，把一个坐标数组作为输入，创建VBO和VAO对象，把VBO和VAO对象加载到显卡中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.FloatBuffer;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL11.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL15.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL20.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL30.*;</span><br><span class="line"><span class="keyword">import</span> org.lwjgl.system.MemoryUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mesh</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vaoId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vboId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> vertexCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mesh</span><span class="params">(<span class="keyword">float</span>[] positions)</span> </span>&#123;</span><br><span class="line">        FloatBuffer verticesBuffer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            verticesBuffer = MemoryUtil.memAllocFloat(positions.length);</span><br><span class="line">            vertexCount = positions.length / <span class="number">3</span>;</span><br><span class="line">            verticesBuffer.put(positions).flip();</span><br><span class="line"></span><br><span class="line">            vaoId = glGenVertexArrays();</span><br><span class="line">            glBindVertexArray(vaoId);</span><br><span class="line"></span><br><span class="line">            vboId = glGenBuffers();</span><br><span class="line">            glBindBuffer(GL_ARRAY_BUFFER, vboId);</span><br><span class="line">            glBufferData(GL_ARRAY_BUFFER, verticesBuffer, GL_STATIC_DRAW);            </span><br><span class="line">            glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            glBindVertexArray(<span class="number">0</span>);         </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (verticesBuffer  != <span class="keyword">null</span>) &#123;</span><br><span class="line">                MemoryUtil.memFree(verticesBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVaoId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vaoId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除VBO</span></span><br><span class="line">        glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">        glDeleteBuffers(vboId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除VAO</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">        glDeleteVertexArrays(vaoId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将在<code>DummyGame</code>类中实例化<code>Mesh</code>，从<code>Renderer</code>的<code>init</code>方法中删除VAO和VBO代码。在<code>Renderer</code>类的渲染方法中也将接收一个<code>Mesh</code>对象来渲染。<code>cleanup</code>方法也被简化，因为<code>Mesh</code>类已经提供了一个释放VAO和VBO资源的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Mesh mesh)</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">        window.setResized(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    glBindVertexArray(mesh.getVaoId());</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, mesh.getVertexCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原状态</span></span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    shaderProgram.unbind();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shaderProgram != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shaderProgram.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的一点是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, mesh.getVertexCount());</span><br></pre></td></tr></table></figure><p><code>Mesh</code>类通过将坐标数组除以3来计算顶点的数目（因为我们使用X，Y和Z坐标）。现在，我们可以渲染更复杂的形状。来渲染一个正方形吧。一个正方形可以用两个三角形来组成，如图所示。</p><p><img src="/2019/02/07/Lwjglbook-05-more-on-rendering/quad_coordinates.png" alt="Quad coordinates"></p><p>正如你所看到的，这两个三角形中的每一个都由三个顶点组成。第一个三角形由顶点V1、V2和V4（橙色的点）组成，第二个三角形由顶点V4，V2和V3（绿色的点）组成。顶点以逆时针顺序连接，因此要传递的浮点数数组应该是[V1, V2, V4, V4, V2, V3]。因此，<code>DummyGame</code>的<code>init</code>方法将是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    renderer.init();</span><br><span class="line">    <span class="keyword">float</span>[] positions = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    mesh = <span class="keyword">new</span> Mesh(positions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你应该可以看到这样一个正方形：</p><p><img src="/2019/02/07/Lwjglbook-05-more-on-rendering/quad_rendered.png" alt="Quad rendered"></p><p>我们完成了吗？没有。上面的代码仍然存在一些问题。我们使用了重复的坐标来表示正方形。我们传递了两次V2和V4坐标。这是个小形状，它可能不是什么大问题，但想象一个更复杂的3D模型，我们会多次重复传递坐标。记住，我们使用三个浮点数表示顶点的位置，但稍后我们将需要更多的数据来表示纹理等。考虑到在更复杂的形状中，三角形直接共享的顶点数量可以更高，如图所示（其中顶点可以在六个三角形之间共享）。</p><p><img src="/2019/02/07/Lwjglbook-05-more-on-rendering/dolphin.png" alt="Dolphin"></p><p>最后，我们需要更多的内存来储存重复的数据，这就是索引缓冲区（<code>Index Buffer</code>)发挥作用的地方。为了绘制正方形，我们只需要以这样的方式指定每个顶点：V1, V2, V3, V4。每个顶点在数组中都有一个位置。V1在位置0上，V2在位置1上等。</p><div class="table-container"><table><thead><tr><th>V1</th><th>V2</th><th>V3</th><th>V4</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td></tr></tbody></table></div><p>然后，我们通过引用它们的位置来指定这些顶点的顺序：</p><div class="table-container"><table><thead><tr><th>0</th><th>1</th><th>3</th><th>3</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>V1</td><td>V2</td><td>V4</td><td>V4</td><td>V2</td><td>V3</td></tr></tbody></table></div><p>因此，我们需要修改<code>Mesh</code>类来接收另一个参数，一个索引数组，现在绘制的顶点数量是该索引数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mesh</span><span class="params">(<span class="keyword">float</span>[] positions, <span class="keyword">int</span>[] indices)</span> </span>&#123;</span><br><span class="line">    vertexCount = indices.length;</span><br></pre></td></tr></table></figure><p>在创建了储存坐标的VBO之后，我们需要创建另一个VBO来保存索引。因此，重命名持有坐标的VBO的ID的变量名，并为索引VBO（<code>idxVboId</code>）创建一个ID。创建VBO的过程相似，但现在的类型是<code>GL_ELEMENT_ARRAY_BUFFER</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idxVboId = glGenBuffers();</span><br><span class="line">indicesBuffer = MemoryUtil.memAllocInt(indices.length);</span><br><span class="line">indicesBuffer.put(indices).flip();</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, idxVboId);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesBuffer, GL_STATIC_DRAW);</span><br><span class="line">memFree(indicesBuffer);</span><br></pre></td></tr></table></figure><p>因为我们是在处理整数，所有需要创建一个<code>IntBuffer</code>而不是一个<code>FloatBuffer</code>。</p><p>就是这样。现在VAO包含两个VBO，一个储存坐标，另一个储存索引。<code>Mesh</code>类的<code>cleanUp</code>方法也必须考虑到要释放另一个VBO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 VBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    glDeleteBuffers(posVboId);</span><br><span class="line">    glDeleteBuffers(idxVboId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    glDeleteVertexArrays(vaoId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们需要修改<code>glDrawArrays</code>调用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, mesh.getVertexCount());</span><br></pre></td></tr></table></figure><p>改为调用<code>glDrawElements</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawElements(GL_TRIANGLES, mesh.getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>方法的参数如下：</p><ul><li>mode: 指定渲染的图元类型，现在是三角形。没有什么变化。</li><li>count: 指定要渲染的顶点数。</li><li>type: 指定索引数据的类型。现在是无符号整数型。</li><li>indices: 指定要开始使用索引渲染的数据偏移量。</li></ul><p>现在可以使用新的和更有效的方法来绘制复杂的模型了，仅需指定索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    renderer.init();</span><br><span class="line">    <span class="keyword">float</span>[] positions = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        -<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">         <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span>[] indices = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    mesh = <span class="keyword">new</span> Mesh(positions, indices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在给示例代码增加颜色吧。我们把另一组浮点数传递给<code>Mesh</code>类，它储存了正方形中每个顶点的颜色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mesh</span><span class="params">(<span class="keyword">float</span>[] positions, <span class="keyword">float</span>[] colours, <span class="keyword">int</span>[] indices)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>为了使用该数组，我们需要创建另一个VBO，它将与我们的VAO相关联。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色 VBO</span></span><br><span class="line">colourVboId = glGenBuffers();</span><br><span class="line">FloatBuffer colourBuffer = memAllocFloat(colours.length);</span><br><span class="line">colourBuffer.put(colours).flip();</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, colourVboId);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, colourBuffer, GL_STATIC_DRAW);</span><br><span class="line">memFree(colourBuffer);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>请注意<code>glVertexAttribPointer</code>方法的调用，第一个参数现在是“1”。这是着色器希望数据的位置。当然，因为增加了一个VBO，所以我们需要在<code>cleanUp</code>方法中释放它。</p><p>下一步是修改着色器。顶点着色器现在需要两个参数，坐标（位置0）和颜色（位置1）。顶点着色器将只输出接收到的颜色，因此这可以由片元着色器处理。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> exColour;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">    exColour = inColour;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，片元着色器输入由顶点着色器处理的颜色，并使用它来生成颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>  <span class="type">vec3</span> exColour;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(exColour, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要做的是修改渲染代码，使其使用第二个数据数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window, Mesh mesh)</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">        window.setResized(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw the mesh</span></span><br><span class="line">    glBindVertexArray(mesh.getVaoId());</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, mesh.getVertexCount(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>你可以看到，在渲染过程中，我们需要启用位于位置1的VAO属性。现在可以把颜色传递给<code>Mesh</code>类，以便给正方形添加颜色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] colours = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后会得到这样一个色彩鲜艳的正方形。</p><p><img src="/2019/02/07/Lwjglbook-05-more-on-rendering/coloured_quad.png" alt="Coloured quad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第四章 渲染</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-04-rendering/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-04-rendering/</id>
    <published>2019-02-06T17:28:10.000Z</published>
    <updated>2019-02-27T14:42:50.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter4" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter4</a></p><p>英文标题：Rendering</p></blockquote><p>在本章中，我们将学习用OpenGL渲染场景时所要做的事情。如果你已经习惯了OpenGL的旧版本，习惯了使用固定管线，你可能会跳过这一章，不想知道为什么它需要这么复杂。它其实更简单，更灵活，你只需要给它一个表现的机会。现代OpenGL让你只需考虑一个问题，这可以让你以更合理的方式组织代码和开发。</p><p>将三维表示映射到二维屏幕的一系列步骤被称为图形管线（<code>Graphics Pipeline</code>）。OpenGL最初的版本使用了一个被称为固定管线（<code>Fixed-function Pipeline</code>）的模型。该模型在绘制过程中定义了一组固定的操作步骤。程序员被每一步可用的函数集约束，可以使用的效果和进行的操作受到API本身（例如，“设置雾”或“添加光照”）的限制，但是这些功能的实现是固定的，并且不能改变。</p><p>固定管线由以下步骤组成：</p><p><img src="/2019/02/07/Lwjglbook-04-rendering/rendering_pipeline.png" alt="Graphics Pipeline"></p><p>OpenGL 2.0 引入了可编程管线（<code>Programmable Pipeline</code>）的概念。在这个模型中，组成图形管线的不同步骤可以通过使用一组叫做着色器（<code>Shader</code>）的特定程序来控制或编程。下面的图片简单的描述了OpenGL可编程管线：</p><p><img src="/2019/02/07/Lwjglbook-04-rendering/rendering_pipeline_2.png" alt="Programmable Pipeline"></p><p>该渲染最初将以顶点缓冲区为形式的一系列顶点作为输入。但是，什么是顶点？顶点（<code>Vertex</code>）是描述二维或者三维空间中的点的数据结构。如何描述三维空间中的一个点呢？通过指定其X、Y和Z坐标。什么是顶点缓冲区？顶点缓冲区（<code>Vertex Buffer</code>）是使用顶点数组来包装所有需要渲染的顶点的另一种数据结构，并使这些数据能在图形管线的着色器中使用。</p><p>这些顶点由顶点着色器（<code>Vertex Shader</code>）处理，其主要目的是计算每个顶点到屏幕空间中的投影位置。该着色器还可以生成与颜色或纹理相关的其他输出，但其主要目的是将顶点投影到屏幕空间中，即生成点。</p><p>几何处理（<code>Geometry Processing</code>）阶段将由顶点着色器变化的顶点连接成三角形。它考虑到顶点储存的顺序，并使用不同的模型对它们进行分组。为什么是三角形？三角形（<code>Triangle</code>）就是显卡的基本工作单元。它是一个简单的几何形状，可以组合和变换，以构建复杂的三维场景。这个阶段还可以使用特定的着色器来对顶点进行分组。</p><p>光栅化（<code>Rasterization</code>）阶段接收此前生成的三角形，剪辑它们，并将它们转换成像素大小的片元。</p><p>这些片元将在片元处理（<code>Fragment Processing</code>）阶段被片元着色器（<code>Fragment Shader</code>）使用，以生成像素写入到帧缓冲区的最终颜色。帧缓冲区（<code>Framebuffer</code>）是图形管线的最终输出。它储存了每个像素应该被绘制到屏幕上的值。</p><p>注意，显卡被设计成并行处理上述所有操作。输入数据可以并行处理以生成最终场景。</p><p>让我们开始编写第一个着色器程序。着色器是使用基于ANSI C的GLSL（OpenGL着色器语言）编写的。首先，在<code>resources</code>目录下创建一个名为“<code>vertex.vs</code>”（扩展名为顶点着色器英文简写）的文件，内容如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行是一个表示我们正在使用的GLSL语言版本的标识符。下表是GLSL版本、与该版本匹配的OpenGL版本和使用方法（来自维基百科： <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions</a>）。</p><div class="table-container"><table><thead><tr><th>GLSL版本</th><th>OpenGL版本</th><th>着色器标识符</th></tr></thead><tbody><tr><td>1.10.59</td><td>2.0</td><td>#version 110</td></tr><tr><td>1.20.8</td><td>2.1</td><td>#version 120</td></tr><tr><td>1.30.10</td><td>3.0</td><td>#version 130</td></tr><tr><td>1.40.08</td><td>3.1</td><td>#version 140</td></tr><tr><td>1.50.11</td><td>3.2</td><td>#version 150</td></tr><tr><td>3.30.6</td><td>3.3</td><td>#version 330</td></tr><tr><td>4.00.9</td><td>4.0</td><td>#version 400</td></tr><tr><td>4.10.6</td><td>4.1</td><td>#version 410</td></tr><tr><td>4.20.11</td><td>4.2</td><td>#version 420</td></tr><tr><td>4.30.8</td><td>4.3</td><td>#version 430</td></tr><tr><td>4.40</td><td>4.4</td><td>#version 440</td></tr><tr><td>4.50</td><td>4.5</td><td>#version 450</td></tr></tbody></table></div><p>第二行指定此着色器的输入格式。OpenGL缓冲区中的数据可以是我们想要的任何东西，也就是说，语言不会强迫你传递预定义语义的任何特定数据结构。从着色器的角度来看，它希望接收带有数据的缓冲区。它可以是一个坐标，一个有一些附加信息的坐标，或者我们想要的任何东西。顶点着色器只接收浮点数组。当填充缓冲区时，我们定义要由着色器处理的缓冲块。</p><p>首先，需要把这些块变成对我们有意义的东西。现在规定从位置0开始，我们期望接收由三个属性（X、Y、Z）组成的向量。</p><p>着色器有个主代码块，就像任何C语言程序一样，这是示例是非常简单的。它只是将接收到的坐标不经任何变换返回到<code>gl_Position</code>。你现在可能想知道为什么三个属性的向量被转换成四个属性的向量（<code>vec4</code>）。这是因为<code>gl_Position</code>仅接受<code>vec4</code>类型的数据，因为它是齐次坐标（<code>Homogeneous Coordinates</code>）。也就是说，它希望接收到形似(X, Y, Z, W)的东西，其中W代表一个额外的维度。为什么还要添加另一个维度？在之后的章节中，你会看到我们需要做的大部分操作都是基于向量和矩阵的。如果没有额外的维度，一些操作不能组合。例如，不能把旋转和变换操作组合起来。（如果你想学习更多有关于这方面的知识，这个额外的维度允许我们组合仿射和线性变换。你可以通过阅读《3D Math Primer for Graphics and Game development》（作者是Fletcher Dunn 和 Ian Parberry）来更多地了解这一点。）</p><p>现在来看看我们的第一个片元着色器。在<code>resources</code>目录下创建一个名为<code>fragment.fs</code>（扩展名片元着色器英文简写）的文件，内容如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构与我们的顶点着色器非常相似。现在，它将为每个片元设置固定的颜色。输出被定义为第二行的<code>vec4</code>类型的<code>fragColor</code>变量。</p><p>现在我们已经创建了着色器，该如何使用它们呢？以下是我们要做的一系列步骤：</p><ol><li>创建OpenGL程序</li><li>载入顶点和片元着色器文件</li><li>对每个着色器创建一个新的着色器程序并指定它的类型（顶点或片元）</li><li>编译着色器</li><li>将着色器绑定到OpenGL程序上</li><li>连接程序</li></ol><p>最后，着色器将会被载入到显卡中，我们可以通过引用程序ID来使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lwjglb.engine.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.lwjgl.opengl.GL20.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShaderProgram</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> programId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vertexShaderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fragmentShaderId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShaderProgram</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        programId = glCreateProgram();</span><br><span class="line">        <span class="keyword">if</span> (programId == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Could not create Shader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createVertexShader</span><span class="params">(String shaderCode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        vertexShaderId = createShader(shaderCode, GL_VERTEX_SHADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createFragmentShader</span><span class="params">(String shaderCode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        fragmentShaderId = createShader(shaderCode, GL_FRAGMENT_SHADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">createShader</span><span class="params">(String shaderCode, <span class="keyword">int</span> shaderType)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shaderId = glCreateShader(shaderType);</span><br><span class="line">        <span class="keyword">if</span> (shaderId == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error creating shader. Type: "</span> + shaderType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        glShaderSource(shaderId, shaderCode);</span><br><span class="line">        glCompileShader(shaderId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (glGetShaderi(shaderId, GL_COMPILE_STATUS) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error compiling Shader code: "</span> + glGetShaderInfoLog(shaderId, <span class="number">1024</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        glAttachShader(programId, shaderId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shaderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        glLinkProgram(programId);</span><br><span class="line">        <span class="keyword">if</span> (glGetProgrami(programId, GL_LINK_STATUS) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error linking Shader code: "</span> + glGetProgramInfoLog(programId, <span class="number">1024</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vertexShaderId != <span class="number">0</span>) &#123;</span><br><span class="line">            glDetachShader(programId, vertexShaderId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fragmentShaderId != <span class="number">0</span>) &#123;</span><br><span class="line">            glDetachShader(programId, fragmentShaderId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        glValidateProgram(programId);</span><br><span class="line">        <span class="keyword">if</span> (glGetProgrami(programId, GL_VALIDATE_STATUS) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Warning validating Shader code: "</span> + glGetProgramInfoLog(programId, <span class="number">1024</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        glUseProgram(programId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        glUseProgram(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbind();</span><br><span class="line">        <span class="keyword">if</span> (programId != <span class="number">0</span>) &#123;</span><br><span class="line">            glDeleteProgram(programId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShaderProgram</code>类的构造函数在OpenGL中创建一个新的程序，并提供添加顶点和片元着色器的方法。这些着色器被编译并绑定到OpenGL程序中。当所有的着色器都被绑定时，应该调用<code>link</code>方法，来连接所有代码并验证所有操作都已正确地完成。</p><p>一旦着色器程序被连接，编译的顶点和片元着色器可以被释放（通过调用<code>glDetachShader</code>方法）</p><p>关于验证，是通过调用<code>glValidateProgram</code>方法完成的。此方法主要用于调试，当游戏到达生产阶段时，应将其删除。此方法将验证在<strong>当前OpenGL状态</strong>下着色器是否正确。这意味着，即使着色器是正确的，在某些情况下也可能验证失败，这是因为当前状态不够完整（一些数据可能尚未加载），无法运行着色器。因此，我们可以将错误信息输出到标准错误输出中。</p><p><code>ShaderProgram</code>类还提供了在渲染时激活该程序（绑定）和停止使用它（解绑）的方法。最后，它提供了一个<code>cleanup</code>方法，用于当它不再被需要时，释放所有资源。</p><p>既然有一个清理方法，让我们更改<code>IGameLogic</code>接口来添加一个<code>cleanup</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法将在游戏循环结束时调用，所以需要修改<code>GameEngine</code>类的<code>run</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        gameLoop();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception excp) &#123;</span><br><span class="line">        excp.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以使用着色器来显示一个三角形。这将在<code>Renderer</code>类的<code>init</code>方法中进行。首先，我们要创建着色器程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    shaderProgram = <span class="keyword">new</span> ShaderProgram();</span><br><span class="line">    shaderProgram.createVertexShader(Utils.loadResource(<span class="string">"/vertex.vs"</span>));</span><br><span class="line">    shaderProgram.createFragmentShader(Utils.loadResource(<span class="string">"/fragment.fs"</span>));</span><br><span class="line">    shaderProgram.link();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经创建了一个工具类，它提供了一个从类路径中取得文件内容的方法。此方法用于取得着色器的内容。</p><p>现在我们可以把我们的三角形定义为一组浮点数。我们创建一个一维浮点数组，它将定义三角形的顶点。正如你所看到的，数组中没有结构。就目前而言，OpenGL无法知道该数组的结构，这只是一组浮点数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>[] vertices = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图体现了在坐标系中的三角形。</p><p><img src="/2019/02/07/Lwjglbook-04-rendering/triangle_coordinates.png" alt="Coordinates Syste"></p><p>现在有了坐标，我们需要把它们储存到我们的显卡中，并告诉OpenGL它的结构。现在将介绍两个重要的概念，顶点数组对象（<code>Vertex Array Object</code>， VAO）和顶点缓冲对象（<code>Vertex Buffer Object</code>, VBO）。如果你对下一段代码感到疑惑，请记住现在所做的是把将要绘制的模型对象数据传递到显卡的储存器中。当储存它的时候，我们将得到一个ID，稍后再绘制时会使用它。</p><p>先介绍顶点缓冲对象（VBO）吧。VBO只是显卡储存器中存储顶点的内存缓冲区。这是用来暂存一组三角形模型的浮点数的地方。正如之前所说的，OpenGL对我们的数据结构一无所知。事实上，它不仅可以保存坐标，还可以保存其他信息，比如纹理、颜色等。</p><p>顶点数组对象（VAO）是包含一个或多个VBO的对象，通常被称为属性列表。每个属性列表可以保存一种类型的数据：位置、颜色、纹理等。在每个渲染间隔中，你可以自由地储存所需的任何数据。</p><p>一个VAO就像是一个包装，它按一组定义对储存在显卡中的数据分组。当我们创建一个VAO是，我们得到一个ID。我们使用这个ID来渲染它和使用它在创建过程中按特定定义的数据。</p><p>让我们继续编写示例代码。必须做的第一件事就是把浮点数储存在一个<code>FloatBuffer</code>中。这主要是因为我们必须使用基于C语言的OpenGL库的接口，所以必须把浮点数转换成可以由库管理的东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FloatBuffer verticesBuffer = MemoryUtil.memAllocFloat(vertices.length);</span><br><span class="line">verticesBuffer.put(vertices).flip();</span><br></pre></td></tr></table></figure><p>我们使用<code>MemoryUtil</code>类来在堆内存中创建一个缓冲区，以便于OpenGL库访问。在储存了数据（调用<code>put</code>方法）之后，我们需要调用<code>flip</code>方法将缓冲区的位置重置为0（也就是说，我们已经完成了对它的写入）。记住，Java中的对象，被分配在一个叫堆（<code>Heap</code>)的内存空间。堆是JVM内存中保留的一大堆内存。储存在堆中的对象不能通过本地代码访问（JNI，这种机制使得Java不能直接调用本地代码）。Java代码和本地代码直接共享内存数据的唯一方法是直接在Java分配内存。</p><p>如果你来自LWJGL的旧版本，强调一些要点是很重要的。你可能注意到了，我们不使用工具类<code>BufferUtils</code>来创建缓冲区。相反，我们使用<code>MemoryUtil</code>类。这是由于<code>BufferUtils</code>不是非常有效的，并且仅被用于向后兼容。相反，LWJGL 3提供了两种缓冲区的管理方法：</p><ul><li>自动管理缓冲区，即由垃圾回收器自动回收的缓冲区。这些缓冲区主要用于短暂的操作，或者用于传递到GPU的数据，并且不需要存在于进程内存中。这是通过使用<code>org.lwjgl.system.MemoryStack</code>实现的。</li><li>手动管理缓冲区。这种情况下，一旦完成操作，我们需要小心地释放它们。这些缓冲区用于长时间操作或者大量的数据。这是通过使用<code>MemoryUtil</code>类实现的。</li></ul><p>你可以在此处查阅细节：<br><a href="https://blog.lwjgl.org/memory-management-in-lwjgl-3/" title="here" target="_blank" rel="noopener">https://blog.lwjgl.org/memory-management-in-lwjgl-3/</a></p><p>在这种情况下，我们的数据被发送到GPU，这样就可以使用自动管理的缓冲区。但是，稍后我们将使用它们来储存可能需要手动管理的大量数据。这就是为什么我们使用<code>MemoryUtil</code>类，因此，这就是为什么我们要在最后一个块中释放缓冲区资源。在下一章中，我们将学习如何使用自动管理缓冲区。</p><p>现在需要创建VAO然后绑定它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vaoId = glGenVertexArrays();</span><br><span class="line">glBindVertexArray(vaoId);</span><br></pre></td></tr></table></figure><p>然后需要创建VBO，绑定它并将数据输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vboId = glGenBuffers();</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vboId);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, verticesBuffer, GL_STATIC_DRAW);</span><br><span class="line">memFree(verticesBuffer);</span><br></pre></td></tr></table></figure><p>现在是最重要的部分。我们需要定义数据的结构，并将其储存在VAO的属性列表中。这是用下面一行代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>它的参数是：</p><ul><li>index: 指定着色器期望此数据的位置。</li><li>size: 指定每个顶点属性的数据数（从1到4）。现在，我们使用三维坐标，所以它应该是3。</li><li>type: 指定数组中每个数据的类型，现在是浮点数。</li><li>normalized: 指定值是否应规范化。</li><li>stride: 指定连续顶点数据之间的字节偏移量（稍后我们再解释）。</li><li>offset: 指定缓冲区中第一个数据的偏移量。</li></ul><p>在完成了VBO操作之后，我们可以解除它和VAO的绑定（绑定到0）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑VBO</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑VAO</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>一旦完成操作，我们<strong>必须</strong>释放由<code>FloatBuffer</code>占用的堆内存，这是通过手动调用<code>memFree</code>方法完成的，因为Java垃圾回收不会清理分配的堆内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (verticesBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MemoryUtil.memFree(verticesBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是<code>init</code>方法应该有的代码。我们的数据已经在显卡中，准备使用了。现在只需要修改我们的<code>render</code>方法在游戏循环中进行渲染。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">        glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">        window.setResized(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shaderProgram.bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(vaoId);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制顶点</span></span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原状态</span></span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    shaderProgram.unbind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所看到的，我们只需要清理窗口，绑定着色器程序，绑定VAO，绘制储存在VAO关联的VBO中的顶点，然后还原状态。仅此而已。</p><p>我们还在<code>Renderer</code>类中添加了一个<code>cleanup</code>方法用于释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shaderProgram != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shaderProgram.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除VBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    glDeleteBuffers(vboId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    glDeleteVertexArrays(vaoId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样！如果你小心地按着上述步骤做，你会看到类似的东西。</p><p>这是我们的第一个三角形！你也许会想这并不会使它成为前十名的游戏，这是正确的。你也可以认为这是一件无聊的工作来画一个无聊的三角形。但请记住，我们正在介绍关键的概念，并准备基于架构来做更复杂的事情。请耐心等待，继续阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第三章 坐标简介</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/</id>
    <published>2019-02-06T17:26:31.000Z</published>
    <updated>2019-02-27T14:42:50.925Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter3" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter3</a></p><p>英文标题：A brief about coordinates</p></blockquote><p>本章节中我们将讨论坐标和坐标系（coordinate system），尝试以简单的方式介绍一些基本的数学概念，为后面章节将要介绍的技术和内容提供帮助。我们将一些内容简化，为了易于学习而牺牲准确性。</p><p>我们通过指定坐标来确定物体在空间中的位置。想想地图。通过在地图上指定纬度和经度来确定一个点。只需一对数字，就可以精确的确认一个点。这对数字就是点坐标（实际上有些复杂，因为地图是一个不完美的椭圆球体（地球是不完美的椭圆球体）的投影，所以需要更多的数据，但这是一个很好的类比）</p><p>坐标系是一个系统，它使用一个或多个数字，即一个或多个坐标来唯一地指定一个点的位置。存在着多种不同的坐标系（如笛卡尔坐标系，极坐标系等），并且可以将坐标从一个坐标系转换到另一个坐标系。我们将使用笛卡尔坐标系。</p><p>在笛卡尔坐标系中，对于二维，坐标由两个数字定义，它们表示到两个相互垂直的X、Y轴的距离。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/cartesian_coordinate_system.png" alt="Cartesian Coordinate System"> </p><p>继续类比地图，坐标系定义一个原点。对于地理坐标，原点被设置为赤道和零度经线交叉的点。根据我们原点设置的位置，特定点的坐标是不同的。坐标系也可以定义轴的方向。在上图中，X坐标随着点向右移动而增加，Y坐标随着点向上移动而增加。但是，我们也可以定义一个与笛卡尔坐标系不同的，具有不同的轴取向的坐标系，我们将得到不同的坐标。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/alt_cartesian_coordinate_system.png" alt="Alternative Cartesian Coordinate System"></p><p>正如你所看到的那样，我们需要定义一些参数，例如原点和轴方向，以便给构成坐标的数字对给出适当的含义。为了使用一组坐标，我们必须使用对应的坐标系。好消息是我们可以通过平移和旋转来将坐标从一个坐标系转换到另一个坐标系。</p><p>如果我们要处理三维坐标，我们需要增加一个轴，即Z轴。三维坐标将由三个数字(x, y, z)构成。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/3d_cartesian_coordinate_system.png" alt="3D Cartesian Coordinate System"></p><p>在二维笛卡尔坐标系中，只要轴相互垂直，我们就可以改变三维坐标系中的轴的方向。下图展示了另一个三维坐标系。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/alt_3d_cartesian_coordinate_system.png" alt="Alternative 3D Cartesian Coordinate System"></p><p>三维坐标可分为左手系和右手系两种类型。你怎么知道它是什么类型的？用你的手在你的拇指和食指之间形成一个“L”，中指应指向垂直于其他两个手指的方向。拇指应该指向X轴的正方向，食指应该指向Y轴的正方向，而中指应该指向Z轴的正方向。如果你能用左手做到，那么它就是左手系，如果你需要用右手，那它就是右手系。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/righthanded_lefthanded.png" alt="Right Handed vs Left Handed"> </p><p>二维坐标系是相同的，因为通过旋转，我们可以从一个坐标系转换到另一个坐标系。但是，三维坐标系并不都是相同的。如果它们可以使用相同的手来表示，也就是说，如果两者都是左手系或者右手系，那么就能通过旋转一个坐标系到另一个坐标系。</p><p>现在我们已经确定了一些基本的概念，让我们来讲解一些在处理三维图形时常用的术语。当我们在之后的章节中解释如何渲染三维模型时，我们将看到我们使用不同的三维坐标系，这是因为每个坐标系都有不同的设定，不同的目的。一组坐标是没有意义的，除非明确它是某个坐标系的坐标。当你看到这个坐标(40.438031, -3.676626)时，你可能会有一个大胆的想法。但是如果我说他们是几何坐标（经度和纬度），你就会发现它们是马德里某个地方的坐标。</p><p>当我们加载三维物体时，我们将得到一组三维坐标。这些坐标在被称为物体坐标系（object coordinate space）的三维坐标系中表达。当建模师在设计这些三维模型的时候，他们对该模型将显示的三维场景毫不知情，因此只能使用与模型相关的坐标系来定义坐标。</p><p>当我们将绘制一个三维场景时，我们所有的三维物体将与被称为世界的坐标系对应。我们需要将三维物体的坐标系转换到世界坐标系。一些物体需要旋转、拉伸、放大和转换，以便在三维场景中能够正确地显示。</p><p>我们还需要限制所显示的三维空间的范围，例如移动摄像机穿梭在我们的三维空间中。然后我们需要将世界坐标转换成摄像机或视口坐标。最后，这些坐标需要转换为二维的屏幕坐标，所以我们需要将三维视图坐标投影到二维屏幕坐标系。</p><p>下面的图片展示了OpenGL坐标系（Z轴垂直于屏幕），坐标在-1和+1之间。</p><p><img src="/2019/02/07/Lwjglbook-03-a-brief-about-coordinates/opengl_coordinates.png" alt="OpenGL coordinates"> </p><p>如果你不能清晰的理解这些概念，别担心。在下一章节中，它们将用实例表现出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第二章 游戏循环</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-02-the-game-loop/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-02-the-game-loop/</id>
    <published>2019-02-06T17:21:44.000Z</published>
    <updated>2019-02-27T14:42:50.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter2" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter2</a></p><p>英文标题：The Game Loop</p></blockquote><p>在本章中，我们将通过创建我们的游戏循环来开始开发游戏引擎。游戏循环是每个游戏的核心部分。它基本上是一个无休止的循环，负责周期地处理用户的输入、更新游戏状态和渲染图形到屏幕上。</p><p>下面的代码片段展示了游戏循环的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (keepOnRunning) &#123;</span><br><span class="line">    handleInput();</span><br><span class="line">    updateGameState();</span><br><span class="line">    render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，就这样了吗？我们已经完成游戏循环了吗？显然，还没有。上面的代码有很多缺陷。首先，游戏循环运行的速度将取决于运行它的计算机。如果计算机足够快，用户甚至看不到游戏中发生了什么。此外，这个游戏循环将消耗所有的计算机资源。</p><p>因此，我们需要游戏循环独立于运行的计算机，尝试以恒定速率运行。让我们假设，我们希望游戏以每秒50帧（50 Frames Per Second，50 FPS）的恒定速率运行。那么我们的游戏循环代码可能是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> secsPerFrame = <span class="number">1.0</span>d / <span class="number">50.0</span>d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (keepOnRunning) &#123;</span><br><span class="line">    <span class="keyword">double</span> now = getTime();</span><br><span class="line">    handleInput();</span><br><span class="line">    updateGameState();</span><br><span class="line">    render();</span><br><span class="line">    sleep(now + secsPerFrame – getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个游戏循环很简单，可以用于一些游戏，但是它也存在一些缺陷。首先，它假定我们的更新和渲染方法适合以50FPS（即，<code>secsPerFrame</code>等于20毫秒）的速度更新。</p><p>此外，我们的计算机可能会优先考虑暂停游戏循环运行一段时间，来运行其他的任务。因此，我们可能会在非常不稳定的时间周期更新游戏状态，这是不符合游戏物理的要求的。</p><p>最后，线程休眠的时间精度仅仅只有0.1秒，所以即使我们的更新和渲染方法没有消耗时间，我们也不会以恒定的速率更新。所以，正如你看到的，问题没那么简单。</p><p>在网上你可以找到大量的游戏循环的变种。在本书中，我们将用一个不太复杂的，在大多数情况下都能正常工作的方法。我们将用的方法通常被称为固定步长游戏循环（Fixed Step Game Loop）。</p><p>首先，我们可能想要单独控制游戏状态被更新的周期和游戏被渲染到屏幕的周期。为什么我们要这么做？因为，以恒定的速率更新游戏状态更为重要，特别是如果我们使用物理引擎。相反，如果我们的渲染没有及时完成，在运行我们的游戏循环时渲染旧帧是没有意义的。我们可以灵活地跳过某些帧。</p><p>让我们看看现在我们的游戏循环是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> secsPerUpdate = <span class="number">1.0</span>d / <span class="number">30.0</span>d;</span><br><span class="line"><span class="keyword">double</span> previous = getTime();</span><br><span class="line"><span class="keyword">double</span> steps = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">double</span> loopStartTime = getTime();</span><br><span class="line">  <span class="keyword">double</span> elapsed = loopStartTime - previous;</span><br><span class="line">  previous = current;</span><br><span class="line">  steps += elapsed;</span><br><span class="line"></span><br><span class="line">  handleInput();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (steps &gt;= secsPerUpdate) &#123;</span><br><span class="line">    updateGameState();</span><br><span class="line">    steps -= secsPerUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render();</span><br><span class="line">  sync(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个游戏循环，我们可以在固定的周期更新我们的游戏状态。但是我们如何避免耗尽计算机资源，使它不连续渲染呢？这在<code>sync</code>方法中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">double</span> loopStartTime)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">float</span> loopSlot = <span class="number">1f</span> / <span class="number">50</span>;</span><br><span class="line">   <span class="keyword">double</span> endTime = loopStartTime + loopSlot; </span><br><span class="line">   <span class="keyword">while</span>(getTime() &lt; endTime) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在上述方法中做了什么呢？总而言之，我们计算我们的游戏循环迭代应该持续多长时间（它被储存在<code>loopSlot</code>变量中），我们休眠的时间取决于我们在循环中花费的时间。但我们不做一整段时间的休眠，而是进行一些小的休眠。这允许其他任务运行，并避免我们之前提到的休眠准确性问题。然后，我们要做的是：</p><ol><li>计算我们应该退出这个方法的时间（这个变量名为<code>endTime</code>），并开始我们的游戏循环的另一个迭代。</li><li>比较当前时间和结束时间，如果我们没有到达结束时间，就休眠1毫秒。</li></ol><p>现在是时候构造我们的代码，以便开始编写游戏引擎的第一个版本了。但在此之前，我们来讨论一下控制渲染速率的另一种方法。在上面的代码中，我们做微休眠，以控制我们需要等待的时间。但是我们可以选择另一种方法来限制帧率。我们可以使用<strong>垂直同步</strong>（Vertical Synchronization）。垂直同步的主要目的是避免画面撕裂。什么是画面撕裂？这是一种显示现象，当我们更新图像储存区时，它正被渲染。结果是一部分图像显示先前的图像，而另一部分图像显示正在渲染的图像。如果我们启用垂直同步，当GPU中的内容正被渲染到屏幕上时，我们不会向GPU发送数据。</p><blockquote><p>Now it is time to structure our code base in order to start writing our first version of our Game Engine. But before doing that we will talk about another way of controlling the rendering rate. In the code presented above, we are doing micro-sleeps in order to control how much time we need to wait. But we can choose another approach in order to limit the frame rate. We can use v-sync (vertical synchronization). The main purpose of v-sync is to avoid screen tearing. What is screen tearing? It’s a visual effect that is produced when we update the video memory while it’s being rendered. The result will be that part of the image will represent the previous image and the other part will represent the updated one. If we enable v-sync we won’t send an image to the GPU while it is being rendered onto the screen.</p></blockquote><p>当我们开启垂直同步时，我们将与显卡的刷新率同步，显卡将以恒定的帧率渲染。用下面一行代码启用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapInterval(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>有了上面的代码，就意味着我们，至少在一个屏幕更新被绘制到屏幕之前，必须等待。事实上，我们不是直接绘制到屏幕上。相反，我们将数据储存在缓冲区中，然后用下面的方法交换它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSwapBuffers(windowHandle);</span><br></pre></td></tr></table></figure><p>因此，如果我们启用垂直同步，我们就可以实现稳定的帧率，而不需要进行微休眠来检查更新时间。此外，帧率将与我们的显卡刷新率相匹配。也就是说，如果它设定为60Hz（60FPS），那么我们就有60FPS。我们可以通过在<code>glfwSwapInterval</code>方法中设置高于1的数字来降低这个速率（如果我们设置为2，我们将得到30FPS）。</p><p>让我们整理一下源代码。首先，我们将把所有的GLFW窗口初始化代码封装在一个名为<code>Window</code>的类中，提供一些基本的参数（如标题和大小）。<code>Window</code>类还提供一个方法以便在游戏循环中检测按下的按键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeyPressed</span><span class="params">(<span class="keyword">int</span> keyCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> glfwGetKey(windowHandle, keyCode) == GLFW_PRESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了有初始化代码以外，<code>Window</code>类还需要知道调整大小。因此，需要设置一个回调方法，在窗口大小被调整时调用它。回调方法将接收帧缓冲区的以像素为单位的宽度和高度（绘制区域，简单来说就是显示区域）。如果希望得到帧缓冲区的宽度、高度，你可以使用<code>glfwSetWindowSizeCallback</code>方法。屏幕坐标不一定对应像素（例如，具有视网膜显示屏（Retina Display）的Mac设备）。因为我们将在进行OpenGL调用时使用这些信息，所以我们要注意像素不在屏幕坐标中。您可以通过GLFW的文档了解更多信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup resize callback</span></span><br><span class="line">glfwSetFramebufferSizeCallback(windowHandle, (window, width, height) -&gt; &#123;</span><br><span class="line">    Window.<span class="keyword">this</span>.width = width;</span><br><span class="line">    Window.<span class="keyword">this</span>.height = height;</span><br><span class="line">    Window.<span class="keyword">this</span>.setResized(<span class="keyword">true</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们还将创建一个<code>Renderer</code>类，它将处理我们游戏的渲染。现在，它仅会有一个空的<code>init</code>方法，和另一个用预设的颜色清空屏幕的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将创建一个名为<code>IGameLogic</code>的接口，它封装了我们的游戏逻辑。这样，我们就可以让游戏引擎在不同的游戏上重复使用。该接口将具有获取输入、更新游戏状态和渲染游戏内容的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGameLogic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(Window window)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将创建一个名为<code>GameEngine</code>的类，它将包含我们游戏循环的代码。这个类实现了<code>Runnable</code>接口，因为游戏循环将要在单独的线程中运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameEngine</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..[Removed code]..</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread gameLoopThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameEngine</span><span class="params">(String windowTitle, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> vsSync, IGameLogic gameLogic)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        gameLoopThread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">"GAME_LOOP_THREAD"</span>);</span><br><span class="line">        window = <span class="keyword">new</span> Window(windowTitle, width, height, vsSync);</span><br><span class="line">        <span class="keyword">this</span>.gameLogic = gameLogic;</span><br><span class="line">        <span class="comment">//..[Removed code]..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>vSync</code>参数允许我们选择是否使用垂直同步。你可以看到我们创建了一个新线程，它将执行我们的<code>GameEngine</code>类的<code>run</code>方法，该类包含着我们的游戏循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gameLoopThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        gameLoop();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception excp) &#123;</span><br><span class="line">        excp.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>GameEngine</code>类提供了一个<code>start</code>方法，它仅会启动我们的线程，因此<code>run</code>方法将异步执行。<code>run</code>方法将执行初始化，并运行游戏循环，直到我们关闭窗口。在线程中初始化GLFW是非常重要的，在之后我们才更新它。因此，在<code>init</code>方法中，我们的窗口和<code>Renderer</code>实例被初始化。</p><p>在源代码中，你将看到我们创建了其他辅助类，例如<code>Timer</code>（它将提供用于计算已经过的时间的实用方法），并在我们的游戏循环逻辑中使用它们。</p><p>我们的<code>GameEngine</code>类只是将<code>input</code>和<code>update</code>方法委托给<code>IGameLogic</code>实例。在<code>render</code>方法中，它也委托给<code>IGameLogic</code>实例并更新窗口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gameLogic.input(window);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> interval)</span> </span>&#123;</span><br><span class="line">    gameLogic.update(interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gameLogic.render(window);</span><br><span class="line">    window.update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的入口，包含<code>main</code>方法的类只会创建一个<code>GameEngine</code>实例并启动它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> vSync = <span class="keyword">true</span>;</span><br><span class="line">            IGameLogic gameLogic = <span class="keyword">new</span> DummyGame();</span><br><span class="line">            GameEngine gameEng = <span class="keyword">new</span> GameEngine(<span class="string">"GAME"</span>,</span><br><span class="line">                <span class="number">600</span>, <span class="number">480</span>, vSync, gameLogic);</span><br><span class="line">            gameEng.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception excp) &#123;</span><br><span class="line">            excp.printStackTrace();</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们只需要创建游戏逻辑类，本章中我们实现一个简单的游戏逻辑。它只会在按下上或下键时，增加或降低窗口的颜色缓冲区的清空颜色。<code>render</code>方法将会用这个颜色清空窗口的颜色缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyGame</span> <span class="keyword">implements</span> <span class="title">IGameLogic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> direction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> color = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Renderer renderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DummyGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        renderer = <span class="keyword">new</span> Renderer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        renderer.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( window.isKeyPressed(GLFW_KEY_UP) ) &#123;</span><br><span class="line">            direction = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( window.isKeyPressed(GLFW_KEY_DOWN) ) &#123;</span><br><span class="line">            direction = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            direction = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> interval)</span> </span>&#123;</span><br><span class="line">        color += direction * <span class="number">0.01f</span>;</span><br><span class="line">        <span class="keyword">if</span> (color &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            color = <span class="number">1.0f</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( color &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            color = <span class="number">0.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Window window)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( window.isResized() ) &#123;</span><br><span class="line">            glViewport(<span class="number">0</span>, <span class="number">0</span>, window.getWidth(), window.getHeight());</span><br><span class="line">            window.setResized(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        window.setClearColor(color, color, color, <span class="number">0.0f</span>);</span><br><span class="line">        renderer.clear();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>render</code>方法中，当窗口大小被调整时，我们接收通知，以便更新视口将坐标中心定位到窗口的中心。</p><p>我们创建的类层次结构将帮助我们将游戏引擎代码与具体的游戏代码分开。虽然现在可能看起来没有必要，但是我们将每个游戏的通用代码从具体的游戏的逻辑、美术作品和资源中分离出来，以便重用我们的游戏引擎。在之后的章节中，我们需要重构这个类层次结构，因为我们的游戏引擎变得更加复杂。</p><h2 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h2><p>如果你试图在OSX系统运行前面提供的源代码，你将得到这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;GAME_LOOP_THREAD&quot; java.lang.ExceptionInInitializerError</span><br></pre></td></tr></table></figure><p>这是什么意思？这是因为GLFW库的某些功能不能在<code>Thread</code>中调用，因为这不是主<code>Thread</code>。我们在初始化时，包括在<code>GameEngine</code>类的<code>init</code>方法中的窗口创建。这些方法都是由同一类的<code>run</code>方法调用，而<code>run</code>方法由一个新的<code>Thread</code>调用，而不是用来启动程序的主线程调用。</p><p>这是GLFW库的一个限制，它基本上意味着我们应该避免为游戏循环创建新线程。我们可以尝试在主线程中创建所有与窗口相关的东西，但是我们将无法渲染任何东西。问题是，OpenGL的调用需要在创建其上下文（Context）的同一个<code>Thread</code>中运行。</p><p>在Windows和Linux平台上，即使我们不能使用主线程初始化GLFW，示例代码也能运行。问题就是在OS X平台上，所以我们需要更改我们的<code>GameEngine</code>类的<code>run</code>方法的代码使它支持这个平台，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String osName = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( osName.contains(<span class="string">"Mac"</span>) ) &#123;</span><br><span class="line">        gameLoopThread.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gameLoopThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们正做的是当我们在OS X平台上时，忽略游戏循环线程，并直接在主线程运行游戏循环代码。这不是一个完美的解决方案，但它将允许你在Mac上运行示例。在论坛上找到的其他解决方案（例如启动JVM时添加<code>-XstartOnFirstThread</code>参数）似乎不起作用。</p><p>在将来，如果LWJGL提供其他的GUI库来检查此限制是否适用于它们，这可能是值得探讨的。（非常感谢Timo Bühlmann指出这个问题。）</p><blockquote><p>In the future it may be interesting to explore if LWJGL provides other GUI libraries to check if this restriction applies to them. (Many thanks to Timo Bühlmann for pointing out this issue).</p></blockquote><h2 id="平台差异（OS-X）"><a href="#平台差异（OS-X）" class="headerlink" title="平台差异（OS X）"></a>平台差异（OS X）</h2><p>你可以运行上面的代码在Windows或Linux上，但我们仍需要为OSX平台做一些修改。正如GLFW文档中所描述的：</p><blockquote><p>目前OS X仅支持的OpenGL 3.x和4.x版本的上下文是向上兼容的。OS X 10.7 Lion支持OpenGL 3.2版本和OS X 10.9 Mavericks支持OpenGL 3.3和4.1版本。在任何情况下，你的GPU需要支持指定版本的OpenGL，以便上下文创建成功。</p></blockquote><p>因此，为了支持在之后的章节中介绍的特性，我们需要将这些代码添加到<code>Window</code>类创建窗口代码之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">2</span>);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br></pre></td></tr></table></figure><p>这将使程序使用OpenGL 3.2到4.1之间的最高版本。如果没有这些代码，就会使用旧版本的OpenGL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>使用LWJGL3开发3D游戏 第一章 事前准备</title>
    <link href="https://mouse0w0.github.io/2019/02/07/Lwjglbook-01-first-steps/"/>
    <id>https://mouse0w0.github.io/2019/02/07/Lwjglbook-01-first-steps/</id>
    <published>2019-02-06T17:17:15.000Z</published>
    <updated>2019-02-27T14:42:50.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://ahbejarano.gitbook.io/lwjglgamedev/chapter1" target="_blank" rel="noopener">https://ahbejarano.gitbook.io/lwjglgamedev/chapter1</a></p><p>英文标题：First Steps</p></blockquote><p>在本书中，我们将学习开发3D游戏所涉及的主要技术。本书将使用Java语言和Java轻量级游戏库(<a href="http://www.lwjgl.org/" target="_blank" rel="noopener">LWJGL</a>)来编写示例代码。LWJGL库允许我们访问底层的API（应用程序接口），例如OpenGL。</p><p>LWJGL是一个底层的API，它像一个OpenGL包装库。如果你是想在短时间内开始制作一个3D游戏，那么也许你该考虑别的选择，比如使用引擎[JmonkeyEngine]。使用LWJGL这个底层API，在你看到效果之前，你需要了解许多概念并且编写大量的代码。这样做的好处是你可以更好的理解3D图形渲染，并且可以更好的控制它。</p><p>在前文我们说过在本书中我们将使用Java。更确切来说我们将使用Java 10，所以你需要从Oracle的页面下载对应版本的JDK。 请选择适合你的操作系统的安装程序。本书假定你对Java语言有一定的了解。</p><p>如果你需要一个可以运行示例代码的Java IDE（集成开发环境），你可以下载为Java 10提供良好支持的IntelliJ IDEA。 由于Java 10仅支持64位的平台，记得下载64位版本的IntelliJ。IntelliJ提供有一个免费且开源的社区版，你可以在这里下载它： <a href="https://www.jetbrains.com/idea/download/" title="Intellij" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/</a>.</p><p><img src="/2019/02/07/Lwjglbook-01-first-steps/intellij.png" alt=""></p><p>为了构建我们的示例代码，我们将使用<a href="https://maven.apache.org/" target="_blank" rel="noopener">Maven</a>。Maven已经集成在大多数IDE中，你可以在IDE中直接打开不同章节的示例代码。只要打开了示例代码的文件夹，IntelliJ就会检测到它是一个Maven项目。</p><p><img src="/2019/02/07/Lwjglbook-01-first-steps/maven_project.png" alt=""></p><p>Maven基于一个名为<code>pom.xml</code>（Project Object Model，项目对象模型）的XML文件来构建项目，它管理了项目的依赖（需要使用的库）和在构建过程中需要执行的步骤。Maven遵循约定高于配置的原则，即如果你遵守标准的项目结构和命名约定，就不需要在配置文件中明确地声明源文件在哪里或者应该在哪里编译类。</p><p>本书不是一个Maven教程，如果有需要，请在网上搜索Maven的相关资料。源代码文件夹定义了一个父项目，它声明需要使用的插件并且声明需要使用的库的版本。</p><p>LWJGL 3.1 有了一些在项目构建上的改变。现在，它变得更加模块化，我们可以有选择的使用类库，而不是导入一个巨大的Jar文件。<br>但这是有代价的：你需要仔细地逐个指定依赖关系。不过<a href="https://www.lwjgl.org/download" target="_blank" rel="noopener">LWJGL下载</a>页面提供了一个为您生成POM文件的脚本。在我们的示例中，我们将只使用GLFW和OpenGL。你可以在源代码中查看我们的POM文件。</p><p>LWJGL平台依赖库已经可以为你的操作系统自动解压本地库，因此不需要使用其他插件（例如<code>mavennatives</code>）。我们只需要配置三个Profile来设置LWJGL所处的操作系统。Profile将会为Windows、Linux和Mac OS系列设置正确的属性值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>windows-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">native.target</span>&gt;</span>natives-windows<span class="tag">&lt;/<span class="name">native.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>                </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>linux-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Linux<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">native.target</span>&gt;</span>natives-linux<span class="tag">&lt;/<span class="name">native.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>                </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>OSX-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>mac<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">native.target</span>&gt;</span>natives-osx<span class="tag">&lt;/<span class="name">native.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在每一个项目中，LWJGL平台依赖项将使用当前操作系统指定的配置中的属性值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lwjgl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lwjgl-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lwjgl.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>$&#123;native.target&#125;<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，每个项目生成一个可运行的Jar（一种可以通过输入<code>java -jar name_of_the_jar.jar</code>就可运行的Jar）。这是通过使用Maven的<code>maven-jar-plugin</code>插件实现的，该插件创建了一个含有<code>MANIFEST.MF</code>文件的Jar，并且文件内有指定的值。该文件最重要的属性就是<code>Main-Class</code>，它指明了程序的入口。此外，所有的依赖库都被设置在该文件的<code>Class-Path</code>属性中。要在另一台计算机上运行它，你只需要复制位于目标目录下的主Jar文件和Lib目录（包括其中所有的Jar文件）。</p><p>Jar文件包含着LWJGL类和本地库。LWJGL还将负责提取它们，并将它们添加到JVM的库路径中。</p><p>本章的源代码是LWJGL网站(<a href="http://www.lwjgl.org/guide" target="_blank" rel="noopener">http://www.lwjgl.org/guide</a>)的入门示例，你可以看到我们没有使用Swing或JavaFX作为我们的GUI库。我们使用的是<a href="www.glfw.org">GLFW</a>，它是一个用来处理GUI组件（窗口等）和事件（按键按下、鼠标移动等），并且与OpenGL上下文进行简单连接的库。此前版本的LWJGL提供了一个自定义GUI API，但在LWJGL 3中，GLFW是首选的窗口API。</p><p>示例源码是简单的并且有着良好的文档，所以我们不会在书中再次说明。</p><p>如果你正确地配置了环境，你应该能够运行它并且看到一个有着红色背景的窗口。</p><p><img src="/2019/02/07/Lwjglbook-01-first-steps/hello_world.png" alt="Hello World"></p><p><strong>本书中源代码发布于 [</strong>GitHub<strong>](<a href="https://github.com/lwjglgamedev/lwjglbook" target="_blank" rel="noopener">https://github.com/lwjglgamedev/lwjglbook</a>)</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://ahbejarano.gitbook.io/lwjglgamedev/chapter1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ahbejarano.gitboo
      
    
    </summary>
    
      <category term="LwjglBook" scheme="https://mouse0w0.github.io/categories/LwjglBook/"/>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="LWJGL" scheme="https://mouse0w0.github.io/tags/LWJGL/"/>
    
      <category term="OpenGL" scheme="https://mouse0w0.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>你好Gitalk</title>
    <link href="https://mouse0w0.github.io/2019/01/31/Hello-Gitalk/"/>
    <id>https://mouse0w0.github.io/2019/01/31/Hello-Gitalk/</id>
    <published>2019-01-30T17:35:25.000Z</published>
    <updated>2019-02-27T14:42:49.057Z</updated>
    
    <content type="html"><![CDATA[<p>现在，本博客正式列装了评论系统，欢迎各位讨论哦！</p><p>Gitalk仓库地址：<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在，本博客正式列装了评论系统，欢迎各位讨论哦！&lt;/p&gt;
&lt;p&gt;Gitalk仓库地址：&lt;a href=&quot;https://github.com/gitalk/gitalk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/g
      
    
    </summary>
    
    
      <category term="Tool" scheme="https://mouse0w0.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Java本地接口（JNI）</title>
    <link href="https://mouse0w0.github.io/2019/01/30/How-to-use-JNI/"/>
    <id>https://mouse0w0.github.io/2019/01/30/How-to-use-JNI/</id>
    <published>2019-01-30T09:04:21.000Z</published>
    <updated>2019-02-27T14:42:50.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html" target="_blank" rel="noopener">Java Native Interface Specification (Java 11)</a></p><p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html" target="_blank" rel="noopener">Java Programming Tutorial Java Native Interface (JNI)</a></p><p><a href="https://www.jianshu.com/p/f6e3dd8edb13" target="_blank" rel="noopener">JNI 学习笔记</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jni/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ja
      
    
    </summary>
    
    
      <category term="Java" scheme="https://mouse0w0.github.io/tags/Java/"/>
    
      <category term="JNI" scheme="https://mouse0w0.github.io/tags/JNI/"/>
    
      <category term="C/C++" scheme="https://mouse0w0.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
